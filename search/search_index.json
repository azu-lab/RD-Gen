{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RD-Gen # Packages # config dag_builder property_setter dag_exporter common exceptions","title":"HOME"},{"location":"#rd-gen","text":"","title":"RD-Gen"},{"location":"#packages","text":"config dag_builder property_setter dag_exporter common exceptions","title":"Packages"},{"location":"common/","text":"Util # Utilization class. Source code in src\\common\\util.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Util : \"\"\"Utilization class.\"\"\" @staticmethod def ambiguous_equals ( s : str , comparison : str ) -> bool : return s . lower () . replace ( \" \" , \"\" ) == comparison . lower () . replace ( \" \" , \"\" ) @staticmethod def convert_to_property ( param_name : str ) -> str : return param_name . lower () . replace ( \" \" , \"_\" ) . replace ( \"-\" , \"_\" ) @staticmethod def random_choice ( target : Union [ Any , list ]): if isinstance ( target , list ): return random . choice ( target ) else : return target @staticmethod def true_or_false () -> bool : if random . choice ([ 0 , 1 ]) == 1 : return True else : return False @staticmethod def get_entry_nodes ( dag : nx . DiGraph ) -> List [ int ]: return [ v for v , d in dag . in_degree () if d == 0 ] @staticmethod def get_exit_nodes ( dag : nx . DiGraph ) -> List [ int ]: return [ v for v , d in dag . out_degree () if d == 0 ] @staticmethod def get_option_min ( option : Optional [ Union [ list , int , float ]]) -> Optional [ Union [ int , float ]]: if option is None : return None if isinstance ( option , list ): return min ( option ) else : return option @staticmethod def get_option_max ( option : Optional [ Union [ list , int , float ]]) -> Optional [ Union [ int , float ]]: if option is None : return None if isinstance ( option , list ): return max ( option ) else : return option @staticmethod def get_min_in_node ( dag : nx . DiGraph , option : Collection [ int ]) -> int : min_in_node_i : int min_in = sys . maxsize for node_i in option : if ( in_degree := dag . in_degree ( node_i )) < min_in : min_in_node_i = node_i min_in = in_degree if min_in == 0 : break return min_in_node_i @staticmethod def get_min_out_node ( dag : nx . DiGraph , option : Collection [ int ]) -> int : min_out_node_i : int min_out = sys . maxsize for node_i in option : if ( out_degree := dag . out_degree ( node_i )) < min_out : min_out_node_i = node_i min_out = out_degree if min_out == 0 : break return min_out_node_i","title":"common"},{"location":"common/#src.common.Util","text":"Utilization class. Source code in src\\common\\util.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Util : \"\"\"Utilization class.\"\"\" @staticmethod def ambiguous_equals ( s : str , comparison : str ) -> bool : return s . lower () . replace ( \" \" , \"\" ) == comparison . lower () . replace ( \" \" , \"\" ) @staticmethod def convert_to_property ( param_name : str ) -> str : return param_name . lower () . replace ( \" \" , \"_\" ) . replace ( \"-\" , \"_\" ) @staticmethod def random_choice ( target : Union [ Any , list ]): if isinstance ( target , list ): return random . choice ( target ) else : return target @staticmethod def true_or_false () -> bool : if random . choice ([ 0 , 1 ]) == 1 : return True else : return False @staticmethod def get_entry_nodes ( dag : nx . DiGraph ) -> List [ int ]: return [ v for v , d in dag . in_degree () if d == 0 ] @staticmethod def get_exit_nodes ( dag : nx . DiGraph ) -> List [ int ]: return [ v for v , d in dag . out_degree () if d == 0 ] @staticmethod def get_option_min ( option : Optional [ Union [ list , int , float ]]) -> Optional [ Union [ int , float ]]: if option is None : return None if isinstance ( option , list ): return min ( option ) else : return option @staticmethod def get_option_max ( option : Optional [ Union [ list , int , float ]]) -> Optional [ Union [ int , float ]]: if option is None : return None if isinstance ( option , list ): return max ( option ) else : return option @staticmethod def get_min_in_node ( dag : nx . DiGraph , option : Collection [ int ]) -> int : min_in_node_i : int min_in = sys . maxsize for node_i in option : if ( in_degree := dag . in_degree ( node_i )) < min_in : min_in_node_i = node_i min_in = in_degree if min_in == 0 : break return min_in_node_i @staticmethod def get_min_out_node ( dag : nx . DiGraph , option : Collection [ int ]) -> int : min_out_node_i : int min_out = sys . maxsize for node_i in option : if ( out_degree := dag . out_degree ( node_i )) < min_out : min_out_node_i = node_i min_out = out_degree if min_out == 0 : break return min_out_node_i","title":"Util"},{"location":"config/","text":"ComboGenerator # ComboGenerator class. Source code in src\\config\\combo_generator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 class ComboGenerator : \"\"\"ComboGenerator class.\"\"\" def __init__ ( self , config_raw : dict ) -> None : self . _combo_params : List [ str ] = [] self . _combo_values : List [ Union [ List [ int ], List [ float ]]] = [] self . _search_combo_and_format_tuple ( config_raw [ \"Graph structure\" ]) self . _search_combo_and_format_tuple ( config_raw [ \"Properties\" ]) self . _config = Config ( config_raw ) def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos def get_combo_iter ( self ) -> Generator [ Tuple [ str , dict , Config ], None , None ]: \"\"\"Get iterator for combinations. Yields ------ Generator[Tuple[str, dict, Config], None, None] (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v combo_config . update_param_value ( k , { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config ) def _create_combo_dir_name ( self , combo : Tuple [ Union [ int , float ]], index : int , ) -> str : combo_dir_name : str = \"\" naming = self . _config . naming_of_combination_directory if Util . ambiguous_equals ( naming , \"Full spell\" ): for param , value in zip ( self . _combo_params , combo ): param_str_list = param . split ( \" \" ) param_str_list = [ s . capitalize () for s in param_str_list ] if combo_dir_name : combo_dir_name += f '_ { \"\" . join ( param_str_list ) } _ { value } ' else : combo_dir_name = f ' { \"\" . join ( param_str_list ) } _ { value } ' elif Util . ambiguous_equals ( naming , \"Abbreviation\" ): for param , value in zip ( self . _combo_params , combo ): try : param = TO_ABB [ param . lower ()] except KeyError : # Additional parameter param = param if combo_dir_name : combo_dir_name += f \"_ { param } _ { value } \" else : combo_dir_name = f \" { param } _ { value } \" elif Util . ambiguous_equals ( naming , \"Index of combination\" ): combo_dir_name = f \"Combination_ { index + 1 } \" else : raise NotImplementedError return combo_dir_name @staticmethod def _convert_tuple_to_list ( tuple_str : str ) -> Union [ List [ int ], List [ float ]]: tuple_str = tuple_str . replace ( \"(\" , \"\" ) tuple_str = tuple_str . replace ( \")\" , \"\" ) tuple_str = tuple_str . replace ( \" \" , \"\" ) args : Dict [ str , float ] = {} for i , arg in enumerate ( tuple_str . split ( \",\" )): if i == 0 or \"start\" in arg : args [ \"start\" ] = float ( arg . replace ( \"start=\" , \"\" )) elif i == 1 or \"stop\" in arg : args [ \"stop\" ] = float ( arg . replace ( \"stop=\" , \"\" )) elif i == 2 or \"step\" in arg : args [ \"step\" ] = float ( arg . replace ( \"step=\" , \"\" )) if args [ \"start\" ] . is_integer () and args [ \"stop\" ] . is_integer () and args [ \"step\" ] . is_integer (): # int case converted = list ( range ( int ( args [ \"start\" ]), int ( args [ \"stop\" ]), int ( args [ \"step\" ]))) if ( args [ \"stop\" ] - args [ \"start\" ]) % args [ \"step\" ] == 0 : converted . append ( int ( args [ \"stop\" ])) else : # float case def get_num_decimal_places ( n : float ) -> int : ctx = decimal . Context () d = ctx . create_decimal ( repr ( n )) return len ( format ( d , \"f\" ) . split ( \".\" )[ 1 ]) m = max ( get_num_decimal_places ( args [ \"start\" ]), get_num_decimal_places ( args [ \"stop\" ]), get_num_decimal_places ( args [ \"step\" ]), ) converted = [ round ( n , m ) for n in np . arange ( ** args )] # type: ignore if (( args [ \"stop\" ] * ( 10 ** m )) - ( args [ \"start\" ]) * ( 10 ** m )) % ( args [ \"step\" ] * ( 10 ** m ) ) < 10 **- 10 : converted . append ( args [ \"stop\" ]) # type: ignore return converted def _search_combo_and_format_tuple ( self , param_dict : dict ) -> None : for k , v in param_dict . items (): if isinstance ( v , dict ): if \"Combination\" in v . keys (): self . _combo_params . append ( k ) if isinstance ( v [ \"Combination\" ], str ): v [ \"Combination\" ] = self . _convert_tuple_to_list ( v [ \"Combination\" ]) # format self . _combo_values . append ( v [ \"Combination\" ]) elif \"Random\" in v . keys () and isinstance ( v [ \"Random\" ], str ): v [ \"Random\" ] = self . _convert_tuple_to_list ( v [ \"Random\" ]) else : self . _search_combo_and_format_tuple ( v ) get_combo_iter () # Get iterator for combinations. Yields: Type Description Generator [ Tuple [ str , dict , Config ], None, None] (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. Source code in src\\config\\combo_generator.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def get_combo_iter ( self ) -> Generator [ Tuple [ str , dict , Config ], None , None ]: \"\"\"Get iterator for combinations. Yields ------ Generator[Tuple[str, dict, Config], None, None] (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v combo_config . update_param_value ( k , { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config ) get_num_combos () # Get number of combinations. Returns: Type Description int Number of combinations. Source code in src\\config\\combo_generator.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos Config # Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. Notes # If the structure of the configuration file changes, this class must be reprogrammed. Source code in src\\config\\config.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 class Config : \"\"\"Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. Notes ----- If the structure of the configuration file changes, this class must be reprogrammed. \"\"\" def __init__ ( self , config_raw : dict ) -> None : self . seed = config_raw [ \"Seed\" ] self . number_of_dags = config_raw [ \"Number of DAGs\" ] self . graph_structure = config_raw [ \"Graph structure\" ] self . properties = config_raw [ \"Properties\" ] self . output_formats = config_raw [ \"Output formats\" ] def update_param_value ( self , param_name : str , value : Any ) -> None : \"\"\"Update parameter value. Parameters ---------- param_name : str Parameter name. value : Any Value to be set. \"\"\" property_name = Util . convert_to_property ( param_name ) if hasattr ( self , property_name ): object . __setattr__ ( self , property_name , value ) else : # Additional properties if self . node_properties and param_name in self . node_properties . keys (): self . node_properties [ param_name ] = value elif self . edge_properties and param_name in self . edge_properties . keys (): self . edge_properties [ param_name ] = value def set_random_seed ( self ) -> None : random . seed ( self . seed ) def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . graph_structure ) self . _remove_random_fixed ( self . properties ) @staticmethod def _remove_random_fixed ( param_dict : dict ) -> None : for k , v in param_dict . items (): if isinstance ( v , dict ): if set ( v . keys ()) <= { \"Random\" , \"Fixed\" }: # Remove value = list ( v . values ()) assert len ( value ) == 1 param_dict [ k ] = value [ 0 ] else : Config . _remove_random_fixed ( v ) # ----- Graph Structure ----- @property def generation_method ( self ): return self . graph_structure . get ( \"Generation method\" ) @property def number_of_nodes ( self ): return self . graph_structure . get ( \"Number of nodes\" ) @number_of_nodes . setter def number_of_nodes ( self , value ): self . graph_structure [ \"Number of nodes\" ] = value @property def ensure_weakly_connected ( self ): return self . graph_structure . get ( \"Ensure weakly connected\" ) @property def out_degree ( self ): return self . graph_structure . get ( \"Out-degree\" ) @out_degree . setter def out_degree ( self , value ): self . graph_structure [ \"Out-degree\" ] = value @property def in_degree ( self ): return self . graph_structure . get ( \"In-degree\" ) @in_degree . setter def in_degree ( self , value ): self . graph_structure [ \"In-degree\" ] = value @property def probability_of_edge ( self ): return self . graph_structure . get ( \"Probability of edge\" ) @probability_of_edge . setter def probability_of_edge ( self , value ): self . graph_structure [ \"Probability of edge\" ] = value @property def number_of_chains ( self ): return self . graph_structure . get ( \"Number of chains\" ) @number_of_chains . setter def number_of_chains ( self , value ): self . graph_structure [ \"Number of chains\" ] = value @property def main_sequence_length ( self ): return self . graph_structure . get ( \"Main sequence length\" ) @main_sequence_length . setter def main_sequence_length ( self , value ): self . graph_structure [ \"Main sequence length\" ] = value @property def number_of_sub_sequences ( self ): return self . graph_structure . get ( \"Number of sub sequences\" ) @number_of_sub_sequences . setter def number_of_sub_sequences ( self , value ): self . graph_structure [ \"Number of sub sequences\" ] = value @property def vertically_link_chains ( self ): return self . graph_structure . get ( \"Vertically link chains\" ) @property def main_sequence_tail ( self ): if self . vertically_link_chains : return self . graph_structure [ \"Vertically link chains\" ] . get ( \"Main sequence tail\" ) else : return None @main_sequence_tail . setter def main_sequence_tail ( self , value ): self . graph_structure [ \"Vertically link chains\" ][ \"Main sequence tail\" ] = value @property def sub_sequence_tail ( self ): if self . vertically_link_chains : return self . graph_structure [ \"Vertically link chains\" ] . get ( \"Sub sequence tail\" ) else : return None @sub_sequence_tail . setter def sub_sequence_tail ( self , value ): self . graph_structure [ \"Vertically link chains\" ][ \"Sub sequence tail\" ] = value @property def number_of_entry_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): if self . vertically_link_chains : return self . graph_structure [ \"Vertically link chains\" ] . get ( \"Number of entry nodes\" ) else : return None else : return self . graph_structure . get ( \"Number of entry nodes\" ) @number_of_entry_nodes . setter def number_of_entry_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . graph_structure [ \"Vertically link chains\" ][ \"Number of entry nodes\" ] = value else : self . graph_structure [ \"Number of entry nodes\" ] = value @property def merge_chains ( self ): return self . graph_structure . get ( \"Merge chains\" ) @property def middle_of_chain ( self ): if self . merge_chains : return self . graph_structure [ \"Merge chains\" ] . get ( \"Middle of chain\" ) else : return None @middle_of_chain . setter def middle_of_chain ( self , value ): self . graph_structure [ \"Merge chains\" ][ \"Middle of chain\" ] = value @property def exit_node ( self ): if self . merge_chains : return self . graph_structure [ \"Merge chains\" ] . get ( \"Exit node\" ) else : return None @exit_node . setter def exit_node ( self , value ): self . graph_structure [ \"Merge chains\" ][ \"Exit node\" ] = value @property def number_of_exit_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): if self . merge_chains : return self . graph_structure [ \"Merge chains\" ] . get ( \"Number of exit nodes\" ) else : return None else : return self . graph_structure . get ( \"Number of exit nodes\" ) @number_of_exit_nodes . setter def number_of_exit_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . graph_structure [ \"Merge chains\" ][ \"Number of exit nodes\" ] = value else : self . graph_structure [ \"Number of exit nodes\" ] = value # ----- Properties ----- @property def execution_time ( self ): return self . properties . get ( \"Execution time\" ) @execution_time . setter def execution_time ( self , value ): self . properties [ \"Execution time\" ] = value @property def communication_time ( self ): return self . properties . get ( \"Communication time\" ) @communication_time . setter def communication_time ( self , value ): self . properties [ \"Communication time\" ] = value @property def ccr ( self ): return self . properties . get ( \"CCR\" ) @ccr . setter def ccr ( self , value ): self . properties [ \"CCR\" ] = value @property def end_to_end_deadline ( self ): return self . properties . get ( \"End-to-end deadline\" ) @property def ratio_of_deadline_to_critical_path ( self ): if self . end_to_end_deadline : return self . properties [ \"End-to-end deadline\" ] . get ( \"Ratio of deadline to critical path\" ) else : return None @ratio_of_deadline_to_critical_path . setter def ratio_of_deadline_to_critical_path ( self , value ): self . properties [ \"End-to-end deadline\" ][ \"Ratio of deadline to critical path\" ] = value @property def multi_rate ( self ): return self . properties . get ( \"Multi-rate\" ) @property def periodic_type ( self ): if self . multi_rate : return self . properties [ \"Multi-rate\" ] . get ( \"Periodic type\" ) else : return None @periodic_type . setter def periodic_type ( self , value ): self . properties [ \"Multi-rate\" ][ \"Periodic type\" ] = value @property def period ( self ): if self . multi_rate : return self . properties [ \"Multi-rate\" ] . get ( \"Period\" ) else : return None @period . setter def period ( self , value ): self . properties [ \"Multi-rate\" ][ \"Period\" ] = value @property def entry_node_period ( self ): if self . multi_rate : return self . properties [ \"Multi-rate\" ] . get ( \"Entry node period\" ) else : return None @entry_node_period . setter def entry_node_period ( self , value ): self . properties [ \"Multi-rate\" ][ \"Entry node period\" ] = value @property def exit_node_period ( self ): if self . multi_rate : return self . properties [ \"Multi-rate\" ] . get ( \"Exit node period\" ) else : return None @exit_node_period . setter def exit_node_period ( self , value ): self . properties [ \"Multi-rate\" ][ \"Exit node period\" ] = value @property def offset ( self ): if self . multi_rate : return self . properties [ \"Multi-rate\" ] . get ( \"Offset\" ) else : return None @offset . setter def offset ( self , value ): self . properties [ \"Multi-rate\" ][ \"Offset\" ] = value @property def total_utilization ( self ): if self . multi_rate : return self . properties [ \"Multi-rate\" ] . get ( \"Total utilization\" ) else : return None @total_utilization . setter def total_utilization ( self , value ): self . properties [ \"Multi-rate\" ][ \"Total utilization\" ] = value @property def maximum_utilization ( self ): if self . multi_rate : return self . properties [ \"Multi-rate\" ] . get ( \"Maximum utilization\" ) else : return None @maximum_utilization . setter def maximum_utilization ( self , value ): self . properties [ \"Multi-rate\" ][ \"Maximum utilization\" ] = value @property def additional_properties ( self ) -> Optional [ dict ]: return self . properties . get ( \"Additional properties\" ) @property def node_properties ( self ) -> Optional [ dict ]: additional_properties = self . additional_properties if additional_properties : return additional_properties . get ( \"Node properties\" ) else : return None @property def edge_properties ( self ) -> Optional [ dict ]: additional_properties = self . additional_properties if additional_properties : return additional_properties . get ( \"Edge properties\" ) else : return None # ----- Output formats ----- @property def naming_of_combination_directory ( self ): return self . output_formats . get ( \"Naming of combination directory\" ) @property def yaml ( self ): return self . output_formats [ \"DAG\" ] . get ( \"YAML\" ) @property def json ( self ): return self . output_formats [ \"DAG\" ] . get ( \"JSON\" ) @property def xml ( self ): return self . output_formats [ \"DAG\" ] . get ( \"XML\" ) @property def dot ( self ): return self . output_formats [ \"DAG\" ] . get ( \"DOT\" ) @property def figure ( self ): return self . output_formats . get ( \"Figure\" ) @property def draw_legend ( self ): if self . figure : return self . output_formats [ \"Figure\" ] . get ( \"Draw legend\" ) else : return None @property def png ( self ): if self . figure : return self . output_formats [ \"Figure\" ] . get ( \"PNG\" ) else : return None @property def svg ( self ): if self . figure : return self . output_formats [ \"Figure\" ] . get ( \"SVG\" ) else : return None @property def eps ( self ): if self . figure : return self . output_formats [ \"Figure\" ] . get ( \"EPS\" ) else : return None @property def pdf ( self ): if self . figure : return self . output_formats [ \"Figure\" ] . get ( \"PDF\" ) else : return None optimize () # Remove 'Random' and 'Fixed' Source code in src\\config\\config.py 49 50 51 52 def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . graph_structure ) self . _remove_random_fixed ( self . properties ) update_param_value ( param_name , value ) # Update parameter value. Parameters: Name Type Description Default param_name str Parameter name. required value Any Value to be set. required Source code in src\\config\\config.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def update_param_value ( self , param_name : str , value : Any ) -> None : \"\"\"Update parameter value. Parameters ---------- param_name : str Parameter name. value : Any Value to be set. \"\"\" property_name = Util . convert_to_property ( param_name ) if hasattr ( self , property_name ): object . __setattr__ ( self , property_name , value ) else : # Additional properties if self . node_properties and param_name in self . node_properties . keys (): self . node_properties [ param_name ] = value elif self . edge_properties and param_name in self . edge_properties . keys (): self . edge_properties [ param_name ] = value ConfigValidator # Config validator class. Source code in src\\config\\config_validator.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 class ConfigValidator : \"\"\"Config validator class.\"\"\" base_schema = Schema ( { Regex ( \"Seed\" , flags = re . I ): int , Regex ( \"Number of DAGs\" , flags = re . I ): int , Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Generation method\" , flags = re . I ): Or ( Regex ( \"Fan-in/Fan-out\" , flags = re . I ), Regex ( r \"G\\(n,[ ]*p\\)\" , flags = re . I ), Regex ( \"Chain-based\" , flags = re . I ), ), Optional ( Regex ( \"Number of nodes\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), }, Regex ( \"Properties\" , flags = re . I ): { Optional ( Regex ( \"Execution time\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Communication time\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"CCR\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ), Optional ( Regex ( \"End-to-end deadline\" , flags = re . I )): { Regex ( \"Ratio of deadline to critical path\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ) }, Optional ( Regex ( \"Multi-rate\" , flags = re . I )): { Regex ( \"Periodic type\" , flags = re . I ): Or ( Regex ( \"All\" , flags = re . I ), Regex ( \"IO\" , flags = re . I ), Regex ( \"Entry\" , flags = re . I ), Regex ( \"Chain\" , flags = re . I ), ), Regex ( \"Period\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Entry node period\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Exit node period\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Offset\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Total utilization\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ), Optional ( Regex ( \"Maximum utilization\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ), }, Optional ( Regex ( \"Additional properties\" , flags = re . I )): { Optional ( Regex ( \"Node properties\" , flags = re . I )): { str : Or ( { Regex ( \"Fixed\" , flags = re . I ): Or ( float , int )}, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], [ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], [ int ], str )}, ) }, Optional ( Regex ( \"Edge properties\" , flags = re . I )): { str : Or ( { Regex ( \"Fixed\" , flags = re . I ): Or ( float , int )}, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], [ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], [ int ], str )}, ) }, }, }, Regex ( \"Output formats\" , flags = re . I ): { Regex ( \"Naming of combination directory\" , flags = re . I ): Or ( Regex ( \"Abbreviation\" , flags = re . I ), Regex ( \"Full spell\" , flags = re . I ), Regex ( \"Index of combination\" , flags = re . I ), ), Regex ( \"DAG\" , flags = re . I ): { Optional ( Regex ( \"YAML\" , flags = re . I )): bool , Optional ( Regex ( \"JSON\" , flags = re . I )): bool , Optional ( Regex ( \"XML\" , flags = re . I )): bool , Optional ( Regex ( \"DOT\" , flags = re . I )): bool , }, Optional ( Regex ( \"Figure\" , flags = re . I )): { Optional ( Regex ( \"Draw legend\" , flags = re . I )): bool , Optional ( Regex ( \"PNG\" , flags = re . I )): bool , Optional ( Regex ( \"SVG\" , flags = re . I )): bool , Optional ( Regex ( \"EPS\" , flags = re . I )): bool , Optional ( Regex ( \"PDF\" , flags = re . I )): bool , }, }, }, ignore_extra_keys = True , ) fifo_gnp_common_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Number of entry nodes\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Number of exit nodes\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Ensure weakly connected\" , flags = re . I )): bool , } }, ignore_extra_keys = True , ) fan_in_fan_out_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"In-degree\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Out-degree\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), } }, ignore_extra_keys = True , ) g_n_p_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Probability of edge\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ) } }, ignore_extra_keys = True , ) chain_based_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Number of chains\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Main sequence length\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Number of sub sequences\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Vertically link chains\" , re . I )): { Regex ( \"Number of entry nodes\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Main sequence tail\" , re . I ): bool , Regex ( \"Sub sequence tail\" , re . I ): bool , }, Optional ( Regex ( \"Merge chains\" , re . I )): { Regex ( \"Number of exit nodes\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Middle of chain\" , re . I ): bool , Regex ( \"Exit node\" , re . I ): bool , }, } }, ignore_extra_keys = True , ) def __init__ ( self , config_raw : dict ) -> None : self . _config_raw = config_raw def validate ( self ) -> None : \"\"\"Validate config. Check the entered configurations according to the schema. For detail, see https://www.andrewvillazon.com/validate-yaml-python-schema/. \"\"\" self . base_schema . validate ( self . _config_raw ) gm = self . _config_raw [ \"Graph structure\" ][ \"Generation method\" ] if Util . ambiguous_equals ( gm , \"fan-in/fan-out\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . fan_in_fan_out_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"g(n, p)\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . g_n_p_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"chain-based\" ): self . chain_based_schema . validate ( self . _config_raw ) validate () # Validate config. Check the entered configurations according to the schema. For detail, see https://www.andrewvillazon.com/validate-yaml-python-schema/. Source code in src\\config\\config_validator.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 def validate ( self ) -> None : \"\"\"Validate config. Check the entered configurations according to the schema. For detail, see https://www.andrewvillazon.com/validate-yaml-python-schema/. \"\"\" self . base_schema . validate ( self . _config_raw ) gm = self . _config_raw [ \"Graph structure\" ][ \"Generation method\" ] if Util . ambiguous_equals ( gm , \"fan-in/fan-out\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . fan_in_fan_out_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"g(n, p)\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . g_n_p_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"chain-based\" ): self . chain_based_schema . validate ( self . _config_raw )","title":"config"},{"location":"config/#src.config.ComboGenerator","text":"ComboGenerator class. Source code in src\\config\\combo_generator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 class ComboGenerator : \"\"\"ComboGenerator class.\"\"\" def __init__ ( self , config_raw : dict ) -> None : self . _combo_params : List [ str ] = [] self . _combo_values : List [ Union [ List [ int ], List [ float ]]] = [] self . _search_combo_and_format_tuple ( config_raw [ \"Graph structure\" ]) self . _search_combo_and_format_tuple ( config_raw [ \"Properties\" ]) self . _config = Config ( config_raw ) def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos def get_combo_iter ( self ) -> Generator [ Tuple [ str , dict , Config ], None , None ]: \"\"\"Get iterator for combinations. Yields ------ Generator[Tuple[str, dict, Config], None, None] (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v combo_config . update_param_value ( k , { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config ) def _create_combo_dir_name ( self , combo : Tuple [ Union [ int , float ]], index : int , ) -> str : combo_dir_name : str = \"\" naming = self . _config . naming_of_combination_directory if Util . ambiguous_equals ( naming , \"Full spell\" ): for param , value in zip ( self . _combo_params , combo ): param_str_list = param . split ( \" \" ) param_str_list = [ s . capitalize () for s in param_str_list ] if combo_dir_name : combo_dir_name += f '_ { \"\" . join ( param_str_list ) } _ { value } ' else : combo_dir_name = f ' { \"\" . join ( param_str_list ) } _ { value } ' elif Util . ambiguous_equals ( naming , \"Abbreviation\" ): for param , value in zip ( self . _combo_params , combo ): try : param = TO_ABB [ param . lower ()] except KeyError : # Additional parameter param = param if combo_dir_name : combo_dir_name += f \"_ { param } _ { value } \" else : combo_dir_name = f \" { param } _ { value } \" elif Util . ambiguous_equals ( naming , \"Index of combination\" ): combo_dir_name = f \"Combination_ { index + 1 } \" else : raise NotImplementedError return combo_dir_name @staticmethod def _convert_tuple_to_list ( tuple_str : str ) -> Union [ List [ int ], List [ float ]]: tuple_str = tuple_str . replace ( \"(\" , \"\" ) tuple_str = tuple_str . replace ( \")\" , \"\" ) tuple_str = tuple_str . replace ( \" \" , \"\" ) args : Dict [ str , float ] = {} for i , arg in enumerate ( tuple_str . split ( \",\" )): if i == 0 or \"start\" in arg : args [ \"start\" ] = float ( arg . replace ( \"start=\" , \"\" )) elif i == 1 or \"stop\" in arg : args [ \"stop\" ] = float ( arg . replace ( \"stop=\" , \"\" )) elif i == 2 or \"step\" in arg : args [ \"step\" ] = float ( arg . replace ( \"step=\" , \"\" )) if args [ \"start\" ] . is_integer () and args [ \"stop\" ] . is_integer () and args [ \"step\" ] . is_integer (): # int case converted = list ( range ( int ( args [ \"start\" ]), int ( args [ \"stop\" ]), int ( args [ \"step\" ]))) if ( args [ \"stop\" ] - args [ \"start\" ]) % args [ \"step\" ] == 0 : converted . append ( int ( args [ \"stop\" ])) else : # float case def get_num_decimal_places ( n : float ) -> int : ctx = decimal . Context () d = ctx . create_decimal ( repr ( n )) return len ( format ( d , \"f\" ) . split ( \".\" )[ 1 ]) m = max ( get_num_decimal_places ( args [ \"start\" ]), get_num_decimal_places ( args [ \"stop\" ]), get_num_decimal_places ( args [ \"step\" ]), ) converted = [ round ( n , m ) for n in np . arange ( ** args )] # type: ignore if (( args [ \"stop\" ] * ( 10 ** m )) - ( args [ \"start\" ]) * ( 10 ** m )) % ( args [ \"step\" ] * ( 10 ** m ) ) < 10 **- 10 : converted . append ( args [ \"stop\" ]) # type: ignore return converted def _search_combo_and_format_tuple ( self , param_dict : dict ) -> None : for k , v in param_dict . items (): if isinstance ( v , dict ): if \"Combination\" in v . keys (): self . _combo_params . append ( k ) if isinstance ( v [ \"Combination\" ], str ): v [ \"Combination\" ] = self . _convert_tuple_to_list ( v [ \"Combination\" ]) # format self . _combo_values . append ( v [ \"Combination\" ]) elif \"Random\" in v . keys () and isinstance ( v [ \"Random\" ], str ): v [ \"Random\" ] = self . _convert_tuple_to_list ( v [ \"Random\" ]) else : self . _search_combo_and_format_tuple ( v )","title":"ComboGenerator"},{"location":"config/#src.config.combo_generator.ComboGenerator.get_combo_iter","text":"Get iterator for combinations. Yields: Type Description Generator [ Tuple [ str , dict , Config ], None, None] (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. Source code in src\\config\\combo_generator.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def get_combo_iter ( self ) -> Generator [ Tuple [ str , dict , Config ], None , None ]: \"\"\"Get iterator for combinations. Yields ------ Generator[Tuple[str, dict, Config], None, None] (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v combo_config . update_param_value ( k , { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config )","title":"get_combo_iter()"},{"location":"config/#src.config.combo_generator.ComboGenerator.get_num_combos","text":"Get number of combinations. Returns: Type Description int Number of combinations. Source code in src\\config\\combo_generator.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos","title":"get_num_combos()"},{"location":"config/#src.config.Config","text":"Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level.","title":"Config"},{"location":"config/#src.config.Config--notes","text":"If the structure of the configuration file changes, this class must be reprogrammed. Source code in src\\config\\config.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 class Config : \"\"\"Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. Notes ----- If the structure of the configuration file changes, this class must be reprogrammed. \"\"\" def __init__ ( self , config_raw : dict ) -> None : self . seed = config_raw [ \"Seed\" ] self . number_of_dags = config_raw [ \"Number of DAGs\" ] self . graph_structure = config_raw [ \"Graph structure\" ] self . properties = config_raw [ \"Properties\" ] self . output_formats = config_raw [ \"Output formats\" ] def update_param_value ( self , param_name : str , value : Any ) -> None : \"\"\"Update parameter value. Parameters ---------- param_name : str Parameter name. value : Any Value to be set. \"\"\" property_name = Util . convert_to_property ( param_name ) if hasattr ( self , property_name ): object . __setattr__ ( self , property_name , value ) else : # Additional properties if self . node_properties and param_name in self . node_properties . keys (): self . node_properties [ param_name ] = value elif self . edge_properties and param_name in self . edge_properties . keys (): self . edge_properties [ param_name ] = value def set_random_seed ( self ) -> None : random . seed ( self . seed ) def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . graph_structure ) self . _remove_random_fixed ( self . properties ) @staticmethod def _remove_random_fixed ( param_dict : dict ) -> None : for k , v in param_dict . items (): if isinstance ( v , dict ): if set ( v . keys ()) <= { \"Random\" , \"Fixed\" }: # Remove value = list ( v . values ()) assert len ( value ) == 1 param_dict [ k ] = value [ 0 ] else : Config . _remove_random_fixed ( v ) # ----- Graph Structure ----- @property def generation_method ( self ): return self . graph_structure . get ( \"Generation method\" ) @property def number_of_nodes ( self ): return self . graph_structure . get ( \"Number of nodes\" ) @number_of_nodes . setter def number_of_nodes ( self , value ): self . graph_structure [ \"Number of nodes\" ] = value @property def ensure_weakly_connected ( self ): return self . graph_structure . get ( \"Ensure weakly connected\" ) @property def out_degree ( self ): return self . graph_structure . get ( \"Out-degree\" ) @out_degree . setter def out_degree ( self , value ): self . graph_structure [ \"Out-degree\" ] = value @property def in_degree ( self ): return self . graph_structure . get ( \"In-degree\" ) @in_degree . setter def in_degree ( self , value ): self . graph_structure [ \"In-degree\" ] = value @property def probability_of_edge ( self ): return self . graph_structure . get ( \"Probability of edge\" ) @probability_of_edge . setter def probability_of_edge ( self , value ): self . graph_structure [ \"Probability of edge\" ] = value @property def number_of_chains ( self ): return self . graph_structure . get ( \"Number of chains\" ) @number_of_chains . setter def number_of_chains ( self , value ): self . graph_structure [ \"Number of chains\" ] = value @property def main_sequence_length ( self ): return self . graph_structure . get ( \"Main sequence length\" ) @main_sequence_length . setter def main_sequence_length ( self , value ): self . graph_structure [ \"Main sequence length\" ] = value @property def number_of_sub_sequences ( self ): return self . graph_structure . get ( \"Number of sub sequences\" ) @number_of_sub_sequences . setter def number_of_sub_sequences ( self , value ): self . graph_structure [ \"Number of sub sequences\" ] = value @property def vertically_link_chains ( self ): return self . graph_structure . get ( \"Vertically link chains\" ) @property def main_sequence_tail ( self ): if self . vertically_link_chains : return self . graph_structure [ \"Vertically link chains\" ] . get ( \"Main sequence tail\" ) else : return None @main_sequence_tail . setter def main_sequence_tail ( self , value ): self . graph_structure [ \"Vertically link chains\" ][ \"Main sequence tail\" ] = value @property def sub_sequence_tail ( self ): if self . vertically_link_chains : return self . graph_structure [ \"Vertically link chains\" ] . get ( \"Sub sequence tail\" ) else : return None @sub_sequence_tail . setter def sub_sequence_tail ( self , value ): self . graph_structure [ \"Vertically link chains\" ][ \"Sub sequence tail\" ] = value @property def number_of_entry_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): if self . vertically_link_chains : return self . graph_structure [ \"Vertically link chains\" ] . get ( \"Number of entry nodes\" ) else : return None else : return self . graph_structure . get ( \"Number of entry nodes\" ) @number_of_entry_nodes . setter def number_of_entry_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . graph_structure [ \"Vertically link chains\" ][ \"Number of entry nodes\" ] = value else : self . graph_structure [ \"Number of entry nodes\" ] = value @property def merge_chains ( self ): return self . graph_structure . get ( \"Merge chains\" ) @property def middle_of_chain ( self ): if self . merge_chains : return self . graph_structure [ \"Merge chains\" ] . get ( \"Middle of chain\" ) else : return None @middle_of_chain . setter def middle_of_chain ( self , value ): self . graph_structure [ \"Merge chains\" ][ \"Middle of chain\" ] = value @property def exit_node ( self ): if self . merge_chains : return self . graph_structure [ \"Merge chains\" ] . get ( \"Exit node\" ) else : return None @exit_node . setter def exit_node ( self , value ): self . graph_structure [ \"Merge chains\" ][ \"Exit node\" ] = value @property def number_of_exit_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): if self . merge_chains : return self . graph_structure [ \"Merge chains\" ] . get ( \"Number of exit nodes\" ) else : return None else : return self . graph_structure . get ( \"Number of exit nodes\" ) @number_of_exit_nodes . setter def number_of_exit_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . graph_structure [ \"Merge chains\" ][ \"Number of exit nodes\" ] = value else : self . graph_structure [ \"Number of exit nodes\" ] = value # ----- Properties ----- @property def execution_time ( self ): return self . properties . get ( \"Execution time\" ) @execution_time . setter def execution_time ( self , value ): self . properties [ \"Execution time\" ] = value @property def communication_time ( self ): return self . properties . get ( \"Communication time\" ) @communication_time . setter def communication_time ( self , value ): self . properties [ \"Communication time\" ] = value @property def ccr ( self ): return self . properties . get ( \"CCR\" ) @ccr . setter def ccr ( self , value ): self . properties [ \"CCR\" ] = value @property def end_to_end_deadline ( self ): return self . properties . get ( \"End-to-end deadline\" ) @property def ratio_of_deadline_to_critical_path ( self ): if self . end_to_end_deadline : return self . properties [ \"End-to-end deadline\" ] . get ( \"Ratio of deadline to critical path\" ) else : return None @ratio_of_deadline_to_critical_path . setter def ratio_of_deadline_to_critical_path ( self , value ): self . properties [ \"End-to-end deadline\" ][ \"Ratio of deadline to critical path\" ] = value @property def multi_rate ( self ): return self . properties . get ( \"Multi-rate\" ) @property def periodic_type ( self ): if self . multi_rate : return self . properties [ \"Multi-rate\" ] . get ( \"Periodic type\" ) else : return None @periodic_type . setter def periodic_type ( self , value ): self . properties [ \"Multi-rate\" ][ \"Periodic type\" ] = value @property def period ( self ): if self . multi_rate : return self . properties [ \"Multi-rate\" ] . get ( \"Period\" ) else : return None @period . setter def period ( self , value ): self . properties [ \"Multi-rate\" ][ \"Period\" ] = value @property def entry_node_period ( self ): if self . multi_rate : return self . properties [ \"Multi-rate\" ] . get ( \"Entry node period\" ) else : return None @entry_node_period . setter def entry_node_period ( self , value ): self . properties [ \"Multi-rate\" ][ \"Entry node period\" ] = value @property def exit_node_period ( self ): if self . multi_rate : return self . properties [ \"Multi-rate\" ] . get ( \"Exit node period\" ) else : return None @exit_node_period . setter def exit_node_period ( self , value ): self . properties [ \"Multi-rate\" ][ \"Exit node period\" ] = value @property def offset ( self ): if self . multi_rate : return self . properties [ \"Multi-rate\" ] . get ( \"Offset\" ) else : return None @offset . setter def offset ( self , value ): self . properties [ \"Multi-rate\" ][ \"Offset\" ] = value @property def total_utilization ( self ): if self . multi_rate : return self . properties [ \"Multi-rate\" ] . get ( \"Total utilization\" ) else : return None @total_utilization . setter def total_utilization ( self , value ): self . properties [ \"Multi-rate\" ][ \"Total utilization\" ] = value @property def maximum_utilization ( self ): if self . multi_rate : return self . properties [ \"Multi-rate\" ] . get ( \"Maximum utilization\" ) else : return None @maximum_utilization . setter def maximum_utilization ( self , value ): self . properties [ \"Multi-rate\" ][ \"Maximum utilization\" ] = value @property def additional_properties ( self ) -> Optional [ dict ]: return self . properties . get ( \"Additional properties\" ) @property def node_properties ( self ) -> Optional [ dict ]: additional_properties = self . additional_properties if additional_properties : return additional_properties . get ( \"Node properties\" ) else : return None @property def edge_properties ( self ) -> Optional [ dict ]: additional_properties = self . additional_properties if additional_properties : return additional_properties . get ( \"Edge properties\" ) else : return None # ----- Output formats ----- @property def naming_of_combination_directory ( self ): return self . output_formats . get ( \"Naming of combination directory\" ) @property def yaml ( self ): return self . output_formats [ \"DAG\" ] . get ( \"YAML\" ) @property def json ( self ): return self . output_formats [ \"DAG\" ] . get ( \"JSON\" ) @property def xml ( self ): return self . output_formats [ \"DAG\" ] . get ( \"XML\" ) @property def dot ( self ): return self . output_formats [ \"DAG\" ] . get ( \"DOT\" ) @property def figure ( self ): return self . output_formats . get ( \"Figure\" ) @property def draw_legend ( self ): if self . figure : return self . output_formats [ \"Figure\" ] . get ( \"Draw legend\" ) else : return None @property def png ( self ): if self . figure : return self . output_formats [ \"Figure\" ] . get ( \"PNG\" ) else : return None @property def svg ( self ): if self . figure : return self . output_formats [ \"Figure\" ] . get ( \"SVG\" ) else : return None @property def eps ( self ): if self . figure : return self . output_formats [ \"Figure\" ] . get ( \"EPS\" ) else : return None @property def pdf ( self ): if self . figure : return self . output_formats [ \"Figure\" ] . get ( \"PDF\" ) else : return None","title":"Notes"},{"location":"config/#src.config.config.Config.optimize","text":"Remove 'Random' and 'Fixed' Source code in src\\config\\config.py 49 50 51 52 def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . graph_structure ) self . _remove_random_fixed ( self . properties )","title":"optimize()"},{"location":"config/#src.config.config.Config.update_param_value","text":"Update parameter value. Parameters: Name Type Description Default param_name str Parameter name. required value Any Value to be set. required Source code in src\\config\\config.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def update_param_value ( self , param_name : str , value : Any ) -> None : \"\"\"Update parameter value. Parameters ---------- param_name : str Parameter name. value : Any Value to be set. \"\"\" property_name = Util . convert_to_property ( param_name ) if hasattr ( self , property_name ): object . __setattr__ ( self , property_name , value ) else : # Additional properties if self . node_properties and param_name in self . node_properties . keys (): self . node_properties [ param_name ] = value elif self . edge_properties and param_name in self . edge_properties . keys (): self . edge_properties [ param_name ] = value","title":"update_param_value()"},{"location":"config/#src.config.ConfigValidator","text":"Config validator class. Source code in src\\config\\config_validator.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 class ConfigValidator : \"\"\"Config validator class.\"\"\" base_schema = Schema ( { Regex ( \"Seed\" , flags = re . I ): int , Regex ( \"Number of DAGs\" , flags = re . I ): int , Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Generation method\" , flags = re . I ): Or ( Regex ( \"Fan-in/Fan-out\" , flags = re . I ), Regex ( r \"G\\(n,[ ]*p\\)\" , flags = re . I ), Regex ( \"Chain-based\" , flags = re . I ), ), Optional ( Regex ( \"Number of nodes\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), }, Regex ( \"Properties\" , flags = re . I ): { Optional ( Regex ( \"Execution time\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Communication time\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"CCR\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ), Optional ( Regex ( \"End-to-end deadline\" , flags = re . I )): { Regex ( \"Ratio of deadline to critical path\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ) }, Optional ( Regex ( \"Multi-rate\" , flags = re . I )): { Regex ( \"Periodic type\" , flags = re . I ): Or ( Regex ( \"All\" , flags = re . I ), Regex ( \"IO\" , flags = re . I ), Regex ( \"Entry\" , flags = re . I ), Regex ( \"Chain\" , flags = re . I ), ), Regex ( \"Period\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Entry node period\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Exit node period\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Offset\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Total utilization\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ), Optional ( Regex ( \"Maximum utilization\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ), }, Optional ( Regex ( \"Additional properties\" , flags = re . I )): { Optional ( Regex ( \"Node properties\" , flags = re . I )): { str : Or ( { Regex ( \"Fixed\" , flags = re . I ): Or ( float , int )}, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], [ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], [ int ], str )}, ) }, Optional ( Regex ( \"Edge properties\" , flags = re . I )): { str : Or ( { Regex ( \"Fixed\" , flags = re . I ): Or ( float , int )}, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], [ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], [ int ], str )}, ) }, }, }, Regex ( \"Output formats\" , flags = re . I ): { Regex ( \"Naming of combination directory\" , flags = re . I ): Or ( Regex ( \"Abbreviation\" , flags = re . I ), Regex ( \"Full spell\" , flags = re . I ), Regex ( \"Index of combination\" , flags = re . I ), ), Regex ( \"DAG\" , flags = re . I ): { Optional ( Regex ( \"YAML\" , flags = re . I )): bool , Optional ( Regex ( \"JSON\" , flags = re . I )): bool , Optional ( Regex ( \"XML\" , flags = re . I )): bool , Optional ( Regex ( \"DOT\" , flags = re . I )): bool , }, Optional ( Regex ( \"Figure\" , flags = re . I )): { Optional ( Regex ( \"Draw legend\" , flags = re . I )): bool , Optional ( Regex ( \"PNG\" , flags = re . I )): bool , Optional ( Regex ( \"SVG\" , flags = re . I )): bool , Optional ( Regex ( \"EPS\" , flags = re . I )): bool , Optional ( Regex ( \"PDF\" , flags = re . I )): bool , }, }, }, ignore_extra_keys = True , ) fifo_gnp_common_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Number of entry nodes\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Number of exit nodes\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Ensure weakly connected\" , flags = re . I )): bool , } }, ignore_extra_keys = True , ) fan_in_fan_out_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"In-degree\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Out-degree\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), } }, ignore_extra_keys = True , ) g_n_p_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Probability of edge\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ) } }, ignore_extra_keys = True , ) chain_based_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Number of chains\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Main sequence length\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Number of sub sequences\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Vertically link chains\" , re . I )): { Regex ( \"Number of entry nodes\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Main sequence tail\" , re . I ): bool , Regex ( \"Sub sequence tail\" , re . I ): bool , }, Optional ( Regex ( \"Merge chains\" , re . I )): { Regex ( \"Number of exit nodes\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Middle of chain\" , re . I ): bool , Regex ( \"Exit node\" , re . I ): bool , }, } }, ignore_extra_keys = True , ) def __init__ ( self , config_raw : dict ) -> None : self . _config_raw = config_raw def validate ( self ) -> None : \"\"\"Validate config. Check the entered configurations according to the schema. For detail, see https://www.andrewvillazon.com/validate-yaml-python-schema/. \"\"\" self . base_schema . validate ( self . _config_raw ) gm = self . _config_raw [ \"Graph structure\" ][ \"Generation method\" ] if Util . ambiguous_equals ( gm , \"fan-in/fan-out\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . fan_in_fan_out_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"g(n, p)\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . g_n_p_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"chain-based\" ): self . chain_based_schema . validate ( self . _config_raw )","title":"ConfigValidator"},{"location":"config/#src.config.config_validator.ConfigValidator.validate","text":"Validate config. Check the entered configurations according to the schema. For detail, see https://www.andrewvillazon.com/validate-yaml-python-schema/. Source code in src\\config\\config_validator.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 def validate ( self ) -> None : \"\"\"Validate config. Check the entered configurations according to the schema. For detail, see https://www.andrewvillazon.com/validate-yaml-python-schema/. \"\"\" self . base_schema . validate ( self . _config_raw ) gm = self . _config_raw [ \"Graph structure\" ][ \"Generation method\" ] if Util . ambiguous_equals ( gm , \"fan-in/fan-out\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . fan_in_fan_out_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"g(n, p)\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . g_n_p_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"chain-based\" ): self . chain_based_schema . validate ( self . _config_raw )","title":"validate()"},{"location":"dag_builder/","text":"Chain # Bases: nx . DiGraph Chain class. Source code in src\\dag_builder\\chain_based_builder.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Chain ( nx . DiGraph ): \"\"\"Chain class.\"\"\" def __init__ ( self , start_idx : int ) -> None : \"\"\"Constructor. Parameters ---------- start_idx : int Index of chain head. \"\"\" super () . __init__ () self . start_idx : int = start_idx self . end_idx : int self . main_tail : int @property def head ( self ) -> int : return self . start_idx @property def sub_sequence_tails ( self ) -> List [ int ]: tails = Util . get_exit_nodes ( self ) tails . remove ( self . main_tail ) return tails def build_chain ( self , main_sequence_length : int , number_of_sub_sequence : Optional [ int ] = None , ) -> None : \"\"\"Build chain. Build the chain so that the main sequence is the longest. Parameters ---------- main_sequence_length : int Main sequence length number_of_sub_sequence : Optional[int], optional Number of sub sequence, by default None \"\"\" def create_sequence ( start_idx : int , len_sequence : int ) -> None : self . add_node ( start_idx ) for i in range ( start_idx , start_idx + len_sequence - 1 ): self . add_edge ( i , i + 1 ) # Build main sequence main_seq_i = [ i for i in range ( self . start_idx , self . start_idx + main_sequence_length )] self . main_tail = self . end_idx = main_seq_i [ - 1 ] create_sequence ( self . start_idx , main_sequence_length ) # Build sub sequence (Optional) if number_of_sub_sequence : for _ in range ( number_of_sub_sequence ): src_i = random . choice ( main_seq_i [: - 1 ]) sub_seq_len = main_sequence_length - main_seq_i . index ( src_i ) - 1 sub_seq_start_idx = self . end_idx + 1 create_sequence ( sub_seq_start_idx , sub_seq_len ) self . add_edge ( src_i , sub_seq_start_idx ) self . end_idx = sub_seq_start_idx + sub_seq_len - 1 __init__ ( start_idx ) # Constructor. Parameters: Name Type Description Default start_idx int Index of chain head. required Source code in src\\dag_builder\\chain_based_builder.py 15 16 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , start_idx : int ) -> None : \"\"\"Constructor. Parameters ---------- start_idx : int Index of chain head. \"\"\" super () . __init__ () self . start_idx : int = start_idx self . end_idx : int self . main_tail : int build_chain ( main_sequence_length , number_of_sub_sequence = None ) # Build chain. Build the chain so that the main sequence is the longest. Parameters: Name Type Description Default main_sequence_length int Main sequence length required number_of_sub_sequence Optional [ int ], optional Number of sub sequence, by default None None Source code in src\\dag_builder\\chain_based_builder.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def build_chain ( self , main_sequence_length : int , number_of_sub_sequence : Optional [ int ] = None , ) -> None : \"\"\"Build chain. Build the chain so that the main sequence is the longest. Parameters ---------- main_sequence_length : int Main sequence length number_of_sub_sequence : Optional[int], optional Number of sub sequence, by default None \"\"\" def create_sequence ( start_idx : int , len_sequence : int ) -> None : self . add_node ( start_idx ) for i in range ( start_idx , start_idx + len_sequence - 1 ): self . add_edge ( i , i + 1 ) # Build main sequence main_seq_i = [ i for i in range ( self . start_idx , self . start_idx + main_sequence_length )] self . main_tail = self . end_idx = main_seq_i [ - 1 ] create_sequence ( self . start_idx , main_sequence_length ) # Build sub sequence (Optional) if number_of_sub_sequence : for _ in range ( number_of_sub_sequence ): src_i = random . choice ( main_seq_i [: - 1 ]) sub_seq_len = main_sequence_length - main_seq_i . index ( src_i ) - 1 sub_seq_start_idx = self . end_idx + 1 create_sequence ( sub_seq_start_idx , sub_seq_len ) self . add_edge ( src_i , sub_seq_start_idx ) self . end_idx = sub_seq_start_idx + sub_seq_len - 1 ChainBasedBuilder # Bases: DAGBuilderBase Chain-based class. Source code in src\\dag_builder\\chain_based_builder.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 class ChainBasedBuilder ( DAGBuilderBase ): \"\"\"Chain-based class.\"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) def _validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" main_sequence_length = Util . get_option_max ( config . main_sequence_length ) number_of_sub_sequences = config . number_of_sub_sequences if main_sequence_length == 1 and number_of_sub_sequences : raise InfeasibleConfigError ( \"Since the length of 'Main sequence length' is 1, \" \"the sub-sequence cannot be built.\" ) if config . vertically_link_chains : main_sequence_tail = config . main_sequence_tail sub_sequence_tail = config . sub_sequence_tail if main_sequence_tail is False and sub_sequence_tail is False : raise InfeasibleConfigError ( \"Either 'Main sequence tail' or 'Sub sequence tail' must be set to True.\" ) number_of_chains = Util . get_option_max ( config . number_of_chains ) number_of_entry_nodes = Util . get_option_min ( config . number_of_entry_nodes ) if number_of_entry_nodes and number_of_chains < number_of_entry_nodes : # type: ignore raise InfeasibleConfigError ( \"'Number of chains' < 'Number of entry nodes.'\" ) if config . merge_chains : middle_of_chain = config . middle_of_chain exit_node = config . exit_node if middle_of_chain is False and exit_node is False : raise InfeasibleConfigError ( \"Either 'Middle of chain' or 'Exit node' must be set to True.\" ) number_of_chains = Util . get_option_max ( config . number_of_chains ) number_of_exit_nodes = Util . get_option_min ( config . number_of_exit_nodes ) number_of_sub_sequences = Util . get_option_min ( config . number_of_sub_sequences ) or 0 if number_of_chains * ( number_of_sub_sequences + 1 ) < number_of_exit_nodes : raise InfeasibleConfigError ( \"'Number of chains' * 'Number of sub sequence' < 'Number of exit nodes.'\" ) def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using chain-based method. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Build each chain chains : List [ Chain ] = [] start_idx = 0 for _ in range ( self . _config . number_of_chains ): chain = Chain ( start_idx ) main_sequence_length = Util . random_choice ( self . _config . main_sequence_length ) number_of_sub_sequence = ( Util . random_choice ( self . _config . number_of_sub_sequences ) if self . _config . number_of_sub_sequences else None ) chain . build_chain ( main_sequence_length , number_of_sub_sequence ) chains . append ( chain ) start_idx = chain . end_idx + 1 # Create chain-based DAG chain_based_dag = ChainBasedDAG ( chains ) # Vertically link chains (optional) if self . _config . vertically_link_chains : chain_based_dag . vertically_link_chains ( Util . random_choice ( self . _config . number_of_entry_nodes ), self . _config . main_sequence_tail , self . _config . sub_sequence_tail , ) # Merge chains (optional) if self . _config . merge_chains : try : chain_based_dag . merge_chains ( Util . random_choice ( self . _config . number_of_exit_nodes ), self . _config . middle_of_chain , self . _config . exit_node , ) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield chain_based_dag build () # Build DAG using chain-based method. Yields: Type Description Generator DAG generator. Raises: Type Description BuildFailedError The number of build failures exceeded the maximum number of attempts. Source code in src\\dag_builder\\chain_based_builder.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using chain-based method. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Build each chain chains : List [ Chain ] = [] start_idx = 0 for _ in range ( self . _config . number_of_chains ): chain = Chain ( start_idx ) main_sequence_length = Util . random_choice ( self . _config . main_sequence_length ) number_of_sub_sequence = ( Util . random_choice ( self . _config . number_of_sub_sequences ) if self . _config . number_of_sub_sequences else None ) chain . build_chain ( main_sequence_length , number_of_sub_sequence ) chains . append ( chain ) start_idx = chain . end_idx + 1 # Create chain-based DAG chain_based_dag = ChainBasedDAG ( chains ) # Vertically link chains (optional) if self . _config . vertically_link_chains : chain_based_dag . vertically_link_chains ( Util . random_choice ( self . _config . number_of_entry_nodes ), self . _config . main_sequence_tail , self . _config . sub_sequence_tail , ) # Merge chains (optional) if self . _config . merge_chains : try : chain_based_dag . merge_chains ( Util . random_choice ( self . _config . number_of_exit_nodes ), self . _config . middle_of_chain , self . _config . exit_node , ) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield chain_based_dag ChainBasedDAG # Bases: nx . DiGraph Chain-based DAG class. Source code in src\\dag_builder\\chain_based_builder.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class ChainBasedDAG ( nx . DiGraph ): \"\"\"Chain-based DAG class.\"\"\" def __init__ ( self , chains : List [ Chain ]) -> None : super () . __init__ () self . chains = chains for chain in self . chains : self . add_nodes_from ( chain . nodes ) self . add_edges_from ( chain . edges ) @property def chain_heads ( self ) -> List [ int ]: return [ chain . head for chain in self . chains ] def vertically_link_chains ( self , number_of_entry_nodes : int , link_main_tail : bool , link_sub_tail : bool ) -> None : \"\"\"Vertically link chains. Parameters ---------- number_of_entry_nodes : int Number of entry nodes. link_main_tail : bool Allow link in main sequence tails. link_sub_tail : bool Allow link in sub sequence tails. \"\"\" # Determine source option src_chains = set ( random . sample ( self . chains , number_of_entry_nodes )) src_option = [] for chain in src_chains : if link_main_tail : src_option . append ( chain . main_tail ) if link_sub_tail : src_option += chain . sub_sequence_tails # Determine targets tgt_chains = set ( self . chains ) - src_chains targets = [ chain . head for chain in tgt_chains ] # Add edges for tgt_i in targets : src_i = Util . get_min_out_node ( self , src_option ) self . add_edge ( src_i , tgt_i ) def merge_chains ( self , number_of_exit_nodes : int , merge_middle : bool , merge_exit : bool ) -> None : \"\"\"Merge chains. Parameters ---------- number_of_exit_nodes : int Number of exit nodes. merge_middle : bool Allow merge to middle nodes. merge_exit : bool Allow merge to exit nodes. Raises ------ BuildFailedError No merging is possible. \"\"\" selected_exits = set ( random . sample ( Util . get_exit_nodes ( self ), number_of_exit_nodes )) sources = set ( Util . get_exit_nodes ( self )) - set ( selected_exits ) # Determine target option tgt_option = set ( self . nodes ()) - set ( Util . get_entry_nodes ( self )) - sources if not merge_exit : tgt_option -= selected_exits if not merge_middle : tgt_option = selected_exits def anc ( dag , src_i : int ) -> set : tmp = nx . DiGraph () tmp . add_nodes_from ( dag . nodes ) tmp . add_edges_from ( dag . edges ) return nx . ancestors ( tmp , src_i ) # Add edges copy_dag = nx . DiGraph () # Use a copy because of a bug in nx.ancestor function. copy_dag . add_nodes_from ( self . nodes ) copy_dag . add_edges_from ( self . edges ) for src_i in sources : _tgt_option = tgt_option - nx . ancestors ( copy_dag , src_i ) if not _tgt_option : raise BuildFailedError ( \"No merging is possible.\" ) tgt_i = Util . get_min_in_node ( self , _tgt_option ) self . add_edge ( src_i , tgt_i ) copy_dag . add_edge ( src_i , tgt_i ) merge_chains ( number_of_exit_nodes , merge_middle , merge_exit ) # Merge chains. Parameters: Name Type Description Default number_of_exit_nodes int Number of exit nodes. required merge_middle bool Allow merge to middle nodes. required merge_exit bool Allow merge to exit nodes. required Raises: Type Description BuildFailedError No merging is possible. Source code in src\\dag_builder\\chain_based_builder.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def merge_chains ( self , number_of_exit_nodes : int , merge_middle : bool , merge_exit : bool ) -> None : \"\"\"Merge chains. Parameters ---------- number_of_exit_nodes : int Number of exit nodes. merge_middle : bool Allow merge to middle nodes. merge_exit : bool Allow merge to exit nodes. Raises ------ BuildFailedError No merging is possible. \"\"\" selected_exits = set ( random . sample ( Util . get_exit_nodes ( self ), number_of_exit_nodes )) sources = set ( Util . get_exit_nodes ( self )) - set ( selected_exits ) # Determine target option tgt_option = set ( self . nodes ()) - set ( Util . get_entry_nodes ( self )) - sources if not merge_exit : tgt_option -= selected_exits if not merge_middle : tgt_option = selected_exits def anc ( dag , src_i : int ) -> set : tmp = nx . DiGraph () tmp . add_nodes_from ( dag . nodes ) tmp . add_edges_from ( dag . edges ) return nx . ancestors ( tmp , src_i ) # Add edges copy_dag = nx . DiGraph () # Use a copy because of a bug in nx.ancestor function. copy_dag . add_nodes_from ( self . nodes ) copy_dag . add_edges_from ( self . edges ) for src_i in sources : _tgt_option = tgt_option - nx . ancestors ( copy_dag , src_i ) if not _tgt_option : raise BuildFailedError ( \"No merging is possible.\" ) tgt_i = Util . get_min_in_node ( self , _tgt_option ) self . add_edge ( src_i , tgt_i ) copy_dag . add_edge ( src_i , tgt_i ) vertically_link_chains ( number_of_entry_nodes , link_main_tail , link_sub_tail ) # Vertically link chains. Parameters: Name Type Description Default number_of_entry_nodes int Number of entry nodes. required link_main_tail bool Allow link in main sequence tails. required link_sub_tail bool Allow link in sub sequence tails. required Source code in src\\dag_builder\\chain_based_builder.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def vertically_link_chains ( self , number_of_entry_nodes : int , link_main_tail : bool , link_sub_tail : bool ) -> None : \"\"\"Vertically link chains. Parameters ---------- number_of_entry_nodes : int Number of entry nodes. link_main_tail : bool Allow link in main sequence tails. link_sub_tail : bool Allow link in sub sequence tails. \"\"\" # Determine source option src_chains = set ( random . sample ( self . chains , number_of_entry_nodes )) src_option = [] for chain in src_chains : if link_main_tail : src_option . append ( chain . main_tail ) if link_sub_tail : src_option += chain . sub_sequence_tails # Determine targets tgt_chains = set ( self . chains ) - src_chains targets = [ chain . head for chain in tgt_chains ] # Add edges for tgt_i in targets : src_i = Util . get_min_out_node ( self , src_option ) self . add_edge ( src_i , tgt_i ) DAGBuilderBase # DAG builder base class. Source code in src\\dag_builder\\dag_builder_base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class DAGBuilderBase ( metaclass = ABCMeta ): \"\"\"DAG builder base class.\"\"\" def __init__ ( self , config : Config , max_try : int = 100 ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. max_try : int, optional Maximum number of build attempts for a single DAG, by default 100 \"\"\" self . _validate_config ( config ) self . _config = config self . _max_try = max_try @abstractmethod def build ( self ) -> Generator [ nx . DiGraph , None , None ]: raise NotImplementedError @abstractmethod def _validate_config ( self , config : Config ): raise NotImplementedError @staticmethod def _force_create_entry_nodes ( G : nx . DiGraph , number_of_entry_nodes : int ) -> None : \"\"\"Create an entry node forcibly. Add 'number_of_entry_nodes' number of new nodes to the DAG and make them entry nodes. All original entry nodes are connected to the newly added node. Parameters ---------- G : nx.DiGraph DAG. number_of_entry_nodes : int Number of entry nodes. \"\"\" original_entries = Util . get_entry_nodes ( G ) new_entries = [ G . number_of_nodes () + i for i in range ( number_of_entry_nodes )] G . add_nodes_from ( new_entries ) DAGBuilderBase . _add_minimum_edges ( new_entries , original_entries , G ) @staticmethod def _force_create_exit_nodes ( G : nx . DiGraph , number_of_exit_nodes : int ) -> None : \"\"\"Create an exit node forcibly. Add 'number_of_exit_nodes' number of new nodes to the DAG and make them exit nodes. All original exit nodes are connected to the newly added node. Parameters ---------- G : nx.DiGraph DAG. number_of_exit_nodes : int Number of exit nodes. \"\"\" original_exits = Util . get_exit_nodes ( G ) new_exits = [ G . number_of_nodes () + i for i in range ( number_of_exit_nodes )] G . add_nodes_from ( new_exits ) DAGBuilderBase . _add_minimum_edges ( original_exits , new_exits , G ) @staticmethod def _add_minimum_edges ( src_layer : List [ int ], tgt_layer : List [ int ], G : nx . DiGraph ) -> None : \"\"\"Add minimum edges Connects the source and target layers with a minimum number of edges. The function terminates when the out-degree of the source layer is greater than or equal to 1 and the in-degree of the target layer is greater than or equal to 1. Parameters ---------- src_layer : List[int] Indices of nodes that are the source of the edge. tgt_layer : List[int] Indices of nodes that are the target of the edge. G : nx.DiGraph DAG. \"\"\" def is_finish () -> bool : for src_node_i in src_layer : if G . out_degree ( src_node_i ) == 0 : return False for tgt_node_i in tgt_layer : if G . in_degree ( tgt_node_i ) == 0 : return False return True while not is_finish (): min_out_src_i = Util . get_min_out_node ( G , src_layer ) min_in_tgt_i = Util . get_min_in_node ( G , tgt_layer ) G . add_edge ( min_out_src_i , min_in_tgt_i ) @staticmethod def _ensure_weakly_connected ( G : nx . DiGraph , keep_num_entry : bool , keep_num_exit : bool ) -> None : \"\"\"Ensure weakly connected. Parameters ---------- G : nx.DiGraph DAG. keep_num_entry : bool Keep the number of entry nodes. keep_num_exit : bool Keep the number of exit nodes. Raises ------ BuildFailedError The number of entry nodes and the number of exit nodes cannot be kept because of the size 1 component. \"\"\" comps = list ( nx . weakly_connected_components ( G )) if len ( comps ) == 1 : return None comps . sort ( key = lambda x : len ( x )) tgt_comp = comps . pop ( - 1 ) # Most big component entry_nodes = set ( Util . get_entry_nodes ( G )) exit_nodes = set ( Util . get_exit_nodes ( G )) if keep_num_entry and keep_num_exit and ( entry_nodes & exit_nodes ): raise BuildFailedError ( \"The number of entry nodes and the number of exit nodes\" \"cannot be maintained because of the size 1 component.\" ) for src_comp in comps : src_option = src_comp - exit_nodes if keep_num_exit else src_comp tgt_option = tgt_comp - entry_nodes if keep_num_entry else tgt_comp src_i = Util . get_min_out_node ( G , src_option ) tgt_i = Util . get_min_in_node ( G , tgt_option ) G . add_edge ( src_i , tgt_i ) __init__ ( config , max_try = 100 ) # Constructor. Parameters: Name Type Description Default config Config Config. required max_try int , optional Maximum number of build attempts for a single DAG, by default 100 100 Source code in src\\dag_builder\\dag_builder_base.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , config : Config , max_try : int = 100 ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. max_try : int, optional Maximum number of build attempts for a single DAG, by default 100 \"\"\" self . _validate_config ( config ) self . _config = config self . _max_try = max_try DAGBuilderFactory # DAG builder factory class. Source code in src\\dag_builder\\dag_builder_factory.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class DAGBuilderFactory : \"\"\"DAG builder factory class.\"\"\" @staticmethod def create_instance ( config : Config ) -> DAGBuilderBase : \"\"\"Create DAG builder instance. Currently supported generation methods: - Fan-in/fan-out method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - G(n, p) method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - Chain-based method Parameters ---------- config : Config Config. Returns ------- DAGBuilderBase DAG builder. Raises ------ NotImplementedError Not implement. \"\"\" generation_method = config . generation_method if Util . ambiguous_equals ( generation_method , \"fan-in/fan-out\" ): return FanInFanOutBuilder ( config ) elif Util . ambiguous_equals ( generation_method , \"g(n, p)\" ): return GNPBuilder ( config ) elif Util . ambiguous_equals ( generation_method , \"chain-based\" ): return ChainBasedBuilder ( config ) else : raise NotImplementedError create_instance ( config ) staticmethod # Create DAG builder instance. Currently supported generation methods: - Fan-in/fan-out method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - G(n, p) method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - Chain-based method Parameters: Name Type Description Default config Config Config. required Returns: Type Description DAGBuilderBase DAG builder. Raises: Type Description NotImplementedError Not implement. Source code in src\\dag_builder\\dag_builder_factory.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @staticmethod def create_instance ( config : Config ) -> DAGBuilderBase : \"\"\"Create DAG builder instance. Currently supported generation methods: - Fan-in/fan-out method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - G(n, p) method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - Chain-based method Parameters ---------- config : Config Config. Returns ------- DAGBuilderBase DAG builder. Raises ------ NotImplementedError Not implement. \"\"\" generation_method = config . generation_method if Util . ambiguous_equals ( generation_method , \"fan-in/fan-out\" ): return FanInFanOutBuilder ( config ) elif Util . ambiguous_equals ( generation_method , \"g(n, p)\" ): return GNPBuilder ( config ) elif Util . ambiguous_equals ( generation_method , \"chain-based\" ): return ChainBasedBuilder ( config ) else : raise NotImplementedError FanInFanOutBuilder # Bases: DAGBuilderBase Fan-in/fan-out class. Source code in src\\dag_builder\\fan_in_fan_out_builder.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class FanInFanOutBuilder ( DAGBuilderBase ): \"\"\"Fan-in/fan-out class.\"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) self . _max_out = ( max ( self . _config . out_degree ) if isinstance ( self . _config . out_degree , list ) else self . _config . out_degree ) self . _max_in = ( max ( self . _config . in_degree ) if isinstance ( self . _config . in_degree , list ) else self . _config . in_degree ) def _validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = Util . get_option_min ( config . number_of_entry_nodes ) number_of_exit_nodes = Util . get_option_min ( config . number_of_exit_nodes ) or 1 number_of_nodes = Util . get_option_max ( config . number_of_nodes ) if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : # type: ignore raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" ) def build ( self ) -> Generator : \"\"\"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): num_build_fail = 0 # Determine number_of_nodes (Loop finish condition) num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize dag num_entry = Util . random_choice ( self . _config . number_of_entry_nodes ) G = self . _init_dag ( num_entry ) while G . number_of_nodes () != num_nodes : if Util . true_or_false (): # Fan-out max_diff_node_i , diff = self . _search_max_diff_node ( G ) num_add = random . randint ( 1 , diff ) add_node_i_list = [ G . number_of_nodes () + i for i in range ( num_add )] nx . add_star ( G , [ max_diff_node_i ] + add_node_i_list ) else : # Fan-in num_sources = random . randint ( 1 , self . _max_in ) nodes = list ( G . nodes ()) random . shuffle ( nodes ) sources = [] for node_i in nodes : if G . out_degree ( node_i ) < self . _max_out : sources . append ( node_i ) if len ( sources ) == num_sources : break add_node_i = G . number_of_nodes () G . add_node ( add_node_i ) for source_node_i in sources : G . add_edge ( source_node_i , add_node_i ) # Check build fail if G . number_of_nodes () > num_nodes : num_build_fail += 1 if num_build_fail == self . _max_try : msg = ( \"A DAG satisfying 'Number of nodes' could not be built \" f \"in { self . _max_try } tries.\" ) raise BuildFailedError ( msg ) else : G = self . _init_dag ( num_entry ) # reset # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : self . _ensure_weakly_connected ( G , True , bool ( num_exit )) yield G def _search_max_diff_node ( self , G : nx . DiGraph ) -> Tuple [ int , int ]: \"\"\"Search max difference node. Find the node with the biggest difference between its out-degree and max value of 'out-degree' parameter. Returns ------- Tuple[int, int] - Index of node with the biggest difference - Difference size \"\"\" min_out_i = Util . get_min_out_node ( G , G . nodes ) max_diff = self . _max_out - G . out_degree ( min_out_i ) return min_out_i , max_diff def _init_dag ( self , num_entry : int ) -> nx . DiGraph : G = nx . DiGraph () for _ in range ( num_entry ): G . add_node ( G . number_of_nodes ()) return G build () # Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields: Type Description Generator DAG generator. Raises: Type Description BuildFailedError The number of build failures exceeded the maximum number of attempts. Source code in src\\dag_builder\\fan_in_fan_out_builder.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def build ( self ) -> Generator : \"\"\"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): num_build_fail = 0 # Determine number_of_nodes (Loop finish condition) num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize dag num_entry = Util . random_choice ( self . _config . number_of_entry_nodes ) G = self . _init_dag ( num_entry ) while G . number_of_nodes () != num_nodes : if Util . true_or_false (): # Fan-out max_diff_node_i , diff = self . _search_max_diff_node ( G ) num_add = random . randint ( 1 , diff ) add_node_i_list = [ G . number_of_nodes () + i for i in range ( num_add )] nx . add_star ( G , [ max_diff_node_i ] + add_node_i_list ) else : # Fan-in num_sources = random . randint ( 1 , self . _max_in ) nodes = list ( G . nodes ()) random . shuffle ( nodes ) sources = [] for node_i in nodes : if G . out_degree ( node_i ) < self . _max_out : sources . append ( node_i ) if len ( sources ) == num_sources : break add_node_i = G . number_of_nodes () G . add_node ( add_node_i ) for source_node_i in sources : G . add_edge ( source_node_i , add_node_i ) # Check build fail if G . number_of_nodes () > num_nodes : num_build_fail += 1 if num_build_fail == self . _max_try : msg = ( \"A DAG satisfying 'Number of nodes' could not be built \" f \"in { self . _max_try } tries.\" ) raise BuildFailedError ( msg ) else : G = self . _init_dag ( num_entry ) # reset # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : self . _ensure_weakly_connected ( G , True , bool ( num_exit )) yield G GNPBuilder # Bases: DAGBuilderBase G(n, p) class. Source code in src\\dag_builder\\g_n_p_builder.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class GNPBuilder ( DAGBuilderBase ): \"\"\"G(n, p) class.\"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) def _validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = Util . get_option_min ( config . number_of_entry_nodes ) or 1 number_of_exit_nodes = Util . get_option_min ( config . number_of_exit_nodes ) or 1 number_of_nodes = Util . get_option_max ( config . number_of_nodes ) if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : # type: ignore raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" ) if config . probability_of_edge > 1.0 : logger . warning ( \"'Probability of edge' > 1.0\" ) def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using G(n, p) method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Determine number_of_nodes num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_entry = self . _config . number_of_entry_nodes if num_entry : num_entry = Util . random_choice ( num_entry ) num_nodes -= num_entry num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize DAG G = nx . DiGraph () for i in range ( num_nodes ): G . add_node ( G . number_of_nodes ()) # Add edge prob_edge = Util . random_choice ( self . _config . probability_of_edge ) for i in range ( num_nodes ): for j in range ( num_nodes ): if random . randint ( 1 , 100 ) < prob_edge * 100 and i < j : G . add_edge ( i , j ) # Add entry nodes (Optional) if num_entry : self . _force_create_entry_nodes ( G , num_entry ) # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : try : self . _ensure_weakly_connected ( G , bool ( num_entry ), bool ( num_exit )) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield G build () # Build DAG using G(n, p) method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields: Type Description Generator DAG generator. Raises: Type Description BuildFailedError The number of build failures exceeded the maximum number of attempts. Source code in src\\dag_builder\\g_n_p_builder.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using G(n, p) method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Determine number_of_nodes num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_entry = self . _config . number_of_entry_nodes if num_entry : num_entry = Util . random_choice ( num_entry ) num_nodes -= num_entry num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize DAG G = nx . DiGraph () for i in range ( num_nodes ): G . add_node ( G . number_of_nodes ()) # Add edge prob_edge = Util . random_choice ( self . _config . probability_of_edge ) for i in range ( num_nodes ): for j in range ( num_nodes ): if random . randint ( 1 , 100 ) < prob_edge * 100 and i < j : G . add_edge ( i , j ) # Add entry nodes (Optional) if num_entry : self . _force_create_entry_nodes ( G , num_entry ) # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : try : self . _ensure_weakly_connected ( G , bool ( num_entry ), bool ( num_exit )) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield G","title":"dag_builder"},{"location":"dag_builder/#src.dag_builder.Chain","text":"Bases: nx . DiGraph Chain class. Source code in src\\dag_builder\\chain_based_builder.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Chain ( nx . DiGraph ): \"\"\"Chain class.\"\"\" def __init__ ( self , start_idx : int ) -> None : \"\"\"Constructor. Parameters ---------- start_idx : int Index of chain head. \"\"\" super () . __init__ () self . start_idx : int = start_idx self . end_idx : int self . main_tail : int @property def head ( self ) -> int : return self . start_idx @property def sub_sequence_tails ( self ) -> List [ int ]: tails = Util . get_exit_nodes ( self ) tails . remove ( self . main_tail ) return tails def build_chain ( self , main_sequence_length : int , number_of_sub_sequence : Optional [ int ] = None , ) -> None : \"\"\"Build chain. Build the chain so that the main sequence is the longest. Parameters ---------- main_sequence_length : int Main sequence length number_of_sub_sequence : Optional[int], optional Number of sub sequence, by default None \"\"\" def create_sequence ( start_idx : int , len_sequence : int ) -> None : self . add_node ( start_idx ) for i in range ( start_idx , start_idx + len_sequence - 1 ): self . add_edge ( i , i + 1 ) # Build main sequence main_seq_i = [ i for i in range ( self . start_idx , self . start_idx + main_sequence_length )] self . main_tail = self . end_idx = main_seq_i [ - 1 ] create_sequence ( self . start_idx , main_sequence_length ) # Build sub sequence (Optional) if number_of_sub_sequence : for _ in range ( number_of_sub_sequence ): src_i = random . choice ( main_seq_i [: - 1 ]) sub_seq_len = main_sequence_length - main_seq_i . index ( src_i ) - 1 sub_seq_start_idx = self . end_idx + 1 create_sequence ( sub_seq_start_idx , sub_seq_len ) self . add_edge ( src_i , sub_seq_start_idx ) self . end_idx = sub_seq_start_idx + sub_seq_len - 1","title":"Chain"},{"location":"dag_builder/#src.dag_builder.chain_based_builder.Chain.__init__","text":"Constructor. Parameters: Name Type Description Default start_idx int Index of chain head. required Source code in src\\dag_builder\\chain_based_builder.py 15 16 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , start_idx : int ) -> None : \"\"\"Constructor. Parameters ---------- start_idx : int Index of chain head. \"\"\" super () . __init__ () self . start_idx : int = start_idx self . end_idx : int self . main_tail : int","title":"__init__()"},{"location":"dag_builder/#src.dag_builder.chain_based_builder.Chain.build_chain","text":"Build chain. Build the chain so that the main sequence is the longest. Parameters: Name Type Description Default main_sequence_length int Main sequence length required number_of_sub_sequence Optional [ int ], optional Number of sub sequence, by default None None Source code in src\\dag_builder\\chain_based_builder.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def build_chain ( self , main_sequence_length : int , number_of_sub_sequence : Optional [ int ] = None , ) -> None : \"\"\"Build chain. Build the chain so that the main sequence is the longest. Parameters ---------- main_sequence_length : int Main sequence length number_of_sub_sequence : Optional[int], optional Number of sub sequence, by default None \"\"\" def create_sequence ( start_idx : int , len_sequence : int ) -> None : self . add_node ( start_idx ) for i in range ( start_idx , start_idx + len_sequence - 1 ): self . add_edge ( i , i + 1 ) # Build main sequence main_seq_i = [ i for i in range ( self . start_idx , self . start_idx + main_sequence_length )] self . main_tail = self . end_idx = main_seq_i [ - 1 ] create_sequence ( self . start_idx , main_sequence_length ) # Build sub sequence (Optional) if number_of_sub_sequence : for _ in range ( number_of_sub_sequence ): src_i = random . choice ( main_seq_i [: - 1 ]) sub_seq_len = main_sequence_length - main_seq_i . index ( src_i ) - 1 sub_seq_start_idx = self . end_idx + 1 create_sequence ( sub_seq_start_idx , sub_seq_len ) self . add_edge ( src_i , sub_seq_start_idx ) self . end_idx = sub_seq_start_idx + sub_seq_len - 1","title":"build_chain()"},{"location":"dag_builder/#src.dag_builder.ChainBasedBuilder","text":"Bases: DAGBuilderBase Chain-based class. Source code in src\\dag_builder\\chain_based_builder.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 class ChainBasedBuilder ( DAGBuilderBase ): \"\"\"Chain-based class.\"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) def _validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" main_sequence_length = Util . get_option_max ( config . main_sequence_length ) number_of_sub_sequences = config . number_of_sub_sequences if main_sequence_length == 1 and number_of_sub_sequences : raise InfeasibleConfigError ( \"Since the length of 'Main sequence length' is 1, \" \"the sub-sequence cannot be built.\" ) if config . vertically_link_chains : main_sequence_tail = config . main_sequence_tail sub_sequence_tail = config . sub_sequence_tail if main_sequence_tail is False and sub_sequence_tail is False : raise InfeasibleConfigError ( \"Either 'Main sequence tail' or 'Sub sequence tail' must be set to True.\" ) number_of_chains = Util . get_option_max ( config . number_of_chains ) number_of_entry_nodes = Util . get_option_min ( config . number_of_entry_nodes ) if number_of_entry_nodes and number_of_chains < number_of_entry_nodes : # type: ignore raise InfeasibleConfigError ( \"'Number of chains' < 'Number of entry nodes.'\" ) if config . merge_chains : middle_of_chain = config . middle_of_chain exit_node = config . exit_node if middle_of_chain is False and exit_node is False : raise InfeasibleConfigError ( \"Either 'Middle of chain' or 'Exit node' must be set to True.\" ) number_of_chains = Util . get_option_max ( config . number_of_chains ) number_of_exit_nodes = Util . get_option_min ( config . number_of_exit_nodes ) number_of_sub_sequences = Util . get_option_min ( config . number_of_sub_sequences ) or 0 if number_of_chains * ( number_of_sub_sequences + 1 ) < number_of_exit_nodes : raise InfeasibleConfigError ( \"'Number of chains' * 'Number of sub sequence' < 'Number of exit nodes.'\" ) def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using chain-based method. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Build each chain chains : List [ Chain ] = [] start_idx = 0 for _ in range ( self . _config . number_of_chains ): chain = Chain ( start_idx ) main_sequence_length = Util . random_choice ( self . _config . main_sequence_length ) number_of_sub_sequence = ( Util . random_choice ( self . _config . number_of_sub_sequences ) if self . _config . number_of_sub_sequences else None ) chain . build_chain ( main_sequence_length , number_of_sub_sequence ) chains . append ( chain ) start_idx = chain . end_idx + 1 # Create chain-based DAG chain_based_dag = ChainBasedDAG ( chains ) # Vertically link chains (optional) if self . _config . vertically_link_chains : chain_based_dag . vertically_link_chains ( Util . random_choice ( self . _config . number_of_entry_nodes ), self . _config . main_sequence_tail , self . _config . sub_sequence_tail , ) # Merge chains (optional) if self . _config . merge_chains : try : chain_based_dag . merge_chains ( Util . random_choice ( self . _config . number_of_exit_nodes ), self . _config . middle_of_chain , self . _config . exit_node , ) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield chain_based_dag","title":"ChainBasedBuilder"},{"location":"dag_builder/#src.dag_builder.chain_based_builder.ChainBasedBuilder.build","text":"Build DAG using chain-based method. Yields: Type Description Generator DAG generator. Raises: Type Description BuildFailedError The number of build failures exceeded the maximum number of attempts. Source code in src\\dag_builder\\chain_based_builder.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using chain-based method. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Build each chain chains : List [ Chain ] = [] start_idx = 0 for _ in range ( self . _config . number_of_chains ): chain = Chain ( start_idx ) main_sequence_length = Util . random_choice ( self . _config . main_sequence_length ) number_of_sub_sequence = ( Util . random_choice ( self . _config . number_of_sub_sequences ) if self . _config . number_of_sub_sequences else None ) chain . build_chain ( main_sequence_length , number_of_sub_sequence ) chains . append ( chain ) start_idx = chain . end_idx + 1 # Create chain-based DAG chain_based_dag = ChainBasedDAG ( chains ) # Vertically link chains (optional) if self . _config . vertically_link_chains : chain_based_dag . vertically_link_chains ( Util . random_choice ( self . _config . number_of_entry_nodes ), self . _config . main_sequence_tail , self . _config . sub_sequence_tail , ) # Merge chains (optional) if self . _config . merge_chains : try : chain_based_dag . merge_chains ( Util . random_choice ( self . _config . number_of_exit_nodes ), self . _config . middle_of_chain , self . _config . exit_node , ) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield chain_based_dag","title":"build()"},{"location":"dag_builder/#src.dag_builder.ChainBasedDAG","text":"Bases: nx . DiGraph Chain-based DAG class. Source code in src\\dag_builder\\chain_based_builder.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class ChainBasedDAG ( nx . DiGraph ): \"\"\"Chain-based DAG class.\"\"\" def __init__ ( self , chains : List [ Chain ]) -> None : super () . __init__ () self . chains = chains for chain in self . chains : self . add_nodes_from ( chain . nodes ) self . add_edges_from ( chain . edges ) @property def chain_heads ( self ) -> List [ int ]: return [ chain . head for chain in self . chains ] def vertically_link_chains ( self , number_of_entry_nodes : int , link_main_tail : bool , link_sub_tail : bool ) -> None : \"\"\"Vertically link chains. Parameters ---------- number_of_entry_nodes : int Number of entry nodes. link_main_tail : bool Allow link in main sequence tails. link_sub_tail : bool Allow link in sub sequence tails. \"\"\" # Determine source option src_chains = set ( random . sample ( self . chains , number_of_entry_nodes )) src_option = [] for chain in src_chains : if link_main_tail : src_option . append ( chain . main_tail ) if link_sub_tail : src_option += chain . sub_sequence_tails # Determine targets tgt_chains = set ( self . chains ) - src_chains targets = [ chain . head for chain in tgt_chains ] # Add edges for tgt_i in targets : src_i = Util . get_min_out_node ( self , src_option ) self . add_edge ( src_i , tgt_i ) def merge_chains ( self , number_of_exit_nodes : int , merge_middle : bool , merge_exit : bool ) -> None : \"\"\"Merge chains. Parameters ---------- number_of_exit_nodes : int Number of exit nodes. merge_middle : bool Allow merge to middle nodes. merge_exit : bool Allow merge to exit nodes. Raises ------ BuildFailedError No merging is possible. \"\"\" selected_exits = set ( random . sample ( Util . get_exit_nodes ( self ), number_of_exit_nodes )) sources = set ( Util . get_exit_nodes ( self )) - set ( selected_exits ) # Determine target option tgt_option = set ( self . nodes ()) - set ( Util . get_entry_nodes ( self )) - sources if not merge_exit : tgt_option -= selected_exits if not merge_middle : tgt_option = selected_exits def anc ( dag , src_i : int ) -> set : tmp = nx . DiGraph () tmp . add_nodes_from ( dag . nodes ) tmp . add_edges_from ( dag . edges ) return nx . ancestors ( tmp , src_i ) # Add edges copy_dag = nx . DiGraph () # Use a copy because of a bug in nx.ancestor function. copy_dag . add_nodes_from ( self . nodes ) copy_dag . add_edges_from ( self . edges ) for src_i in sources : _tgt_option = tgt_option - nx . ancestors ( copy_dag , src_i ) if not _tgt_option : raise BuildFailedError ( \"No merging is possible.\" ) tgt_i = Util . get_min_in_node ( self , _tgt_option ) self . add_edge ( src_i , tgt_i ) copy_dag . add_edge ( src_i , tgt_i )","title":"ChainBasedDAG"},{"location":"dag_builder/#src.dag_builder.chain_based_builder.ChainBasedDAG.merge_chains","text":"Merge chains. Parameters: Name Type Description Default number_of_exit_nodes int Number of exit nodes. required merge_middle bool Allow merge to middle nodes. required merge_exit bool Allow merge to exit nodes. required Raises: Type Description BuildFailedError No merging is possible. Source code in src\\dag_builder\\chain_based_builder.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def merge_chains ( self , number_of_exit_nodes : int , merge_middle : bool , merge_exit : bool ) -> None : \"\"\"Merge chains. Parameters ---------- number_of_exit_nodes : int Number of exit nodes. merge_middle : bool Allow merge to middle nodes. merge_exit : bool Allow merge to exit nodes. Raises ------ BuildFailedError No merging is possible. \"\"\" selected_exits = set ( random . sample ( Util . get_exit_nodes ( self ), number_of_exit_nodes )) sources = set ( Util . get_exit_nodes ( self )) - set ( selected_exits ) # Determine target option tgt_option = set ( self . nodes ()) - set ( Util . get_entry_nodes ( self )) - sources if not merge_exit : tgt_option -= selected_exits if not merge_middle : tgt_option = selected_exits def anc ( dag , src_i : int ) -> set : tmp = nx . DiGraph () tmp . add_nodes_from ( dag . nodes ) tmp . add_edges_from ( dag . edges ) return nx . ancestors ( tmp , src_i ) # Add edges copy_dag = nx . DiGraph () # Use a copy because of a bug in nx.ancestor function. copy_dag . add_nodes_from ( self . nodes ) copy_dag . add_edges_from ( self . edges ) for src_i in sources : _tgt_option = tgt_option - nx . ancestors ( copy_dag , src_i ) if not _tgt_option : raise BuildFailedError ( \"No merging is possible.\" ) tgt_i = Util . get_min_in_node ( self , _tgt_option ) self . add_edge ( src_i , tgt_i ) copy_dag . add_edge ( src_i , tgt_i )","title":"merge_chains()"},{"location":"dag_builder/#src.dag_builder.chain_based_builder.ChainBasedDAG.vertically_link_chains","text":"Vertically link chains. Parameters: Name Type Description Default number_of_entry_nodes int Number of entry nodes. required link_main_tail bool Allow link in main sequence tails. required link_sub_tail bool Allow link in sub sequence tails. required Source code in src\\dag_builder\\chain_based_builder.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def vertically_link_chains ( self , number_of_entry_nodes : int , link_main_tail : bool , link_sub_tail : bool ) -> None : \"\"\"Vertically link chains. Parameters ---------- number_of_entry_nodes : int Number of entry nodes. link_main_tail : bool Allow link in main sequence tails. link_sub_tail : bool Allow link in sub sequence tails. \"\"\" # Determine source option src_chains = set ( random . sample ( self . chains , number_of_entry_nodes )) src_option = [] for chain in src_chains : if link_main_tail : src_option . append ( chain . main_tail ) if link_sub_tail : src_option += chain . sub_sequence_tails # Determine targets tgt_chains = set ( self . chains ) - src_chains targets = [ chain . head for chain in tgt_chains ] # Add edges for tgt_i in targets : src_i = Util . get_min_out_node ( self , src_option ) self . add_edge ( src_i , tgt_i )","title":"vertically_link_chains()"},{"location":"dag_builder/#src.dag_builder.DAGBuilderBase","text":"DAG builder base class. Source code in src\\dag_builder\\dag_builder_base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class DAGBuilderBase ( metaclass = ABCMeta ): \"\"\"DAG builder base class.\"\"\" def __init__ ( self , config : Config , max_try : int = 100 ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. max_try : int, optional Maximum number of build attempts for a single DAG, by default 100 \"\"\" self . _validate_config ( config ) self . _config = config self . _max_try = max_try @abstractmethod def build ( self ) -> Generator [ nx . DiGraph , None , None ]: raise NotImplementedError @abstractmethod def _validate_config ( self , config : Config ): raise NotImplementedError @staticmethod def _force_create_entry_nodes ( G : nx . DiGraph , number_of_entry_nodes : int ) -> None : \"\"\"Create an entry node forcibly. Add 'number_of_entry_nodes' number of new nodes to the DAG and make them entry nodes. All original entry nodes are connected to the newly added node. Parameters ---------- G : nx.DiGraph DAG. number_of_entry_nodes : int Number of entry nodes. \"\"\" original_entries = Util . get_entry_nodes ( G ) new_entries = [ G . number_of_nodes () + i for i in range ( number_of_entry_nodes )] G . add_nodes_from ( new_entries ) DAGBuilderBase . _add_minimum_edges ( new_entries , original_entries , G ) @staticmethod def _force_create_exit_nodes ( G : nx . DiGraph , number_of_exit_nodes : int ) -> None : \"\"\"Create an exit node forcibly. Add 'number_of_exit_nodes' number of new nodes to the DAG and make them exit nodes. All original exit nodes are connected to the newly added node. Parameters ---------- G : nx.DiGraph DAG. number_of_exit_nodes : int Number of exit nodes. \"\"\" original_exits = Util . get_exit_nodes ( G ) new_exits = [ G . number_of_nodes () + i for i in range ( number_of_exit_nodes )] G . add_nodes_from ( new_exits ) DAGBuilderBase . _add_minimum_edges ( original_exits , new_exits , G ) @staticmethod def _add_minimum_edges ( src_layer : List [ int ], tgt_layer : List [ int ], G : nx . DiGraph ) -> None : \"\"\"Add minimum edges Connects the source and target layers with a minimum number of edges. The function terminates when the out-degree of the source layer is greater than or equal to 1 and the in-degree of the target layer is greater than or equal to 1. Parameters ---------- src_layer : List[int] Indices of nodes that are the source of the edge. tgt_layer : List[int] Indices of nodes that are the target of the edge. G : nx.DiGraph DAG. \"\"\" def is_finish () -> bool : for src_node_i in src_layer : if G . out_degree ( src_node_i ) == 0 : return False for tgt_node_i in tgt_layer : if G . in_degree ( tgt_node_i ) == 0 : return False return True while not is_finish (): min_out_src_i = Util . get_min_out_node ( G , src_layer ) min_in_tgt_i = Util . get_min_in_node ( G , tgt_layer ) G . add_edge ( min_out_src_i , min_in_tgt_i ) @staticmethod def _ensure_weakly_connected ( G : nx . DiGraph , keep_num_entry : bool , keep_num_exit : bool ) -> None : \"\"\"Ensure weakly connected. Parameters ---------- G : nx.DiGraph DAG. keep_num_entry : bool Keep the number of entry nodes. keep_num_exit : bool Keep the number of exit nodes. Raises ------ BuildFailedError The number of entry nodes and the number of exit nodes cannot be kept because of the size 1 component. \"\"\" comps = list ( nx . weakly_connected_components ( G )) if len ( comps ) == 1 : return None comps . sort ( key = lambda x : len ( x )) tgt_comp = comps . pop ( - 1 ) # Most big component entry_nodes = set ( Util . get_entry_nodes ( G )) exit_nodes = set ( Util . get_exit_nodes ( G )) if keep_num_entry and keep_num_exit and ( entry_nodes & exit_nodes ): raise BuildFailedError ( \"The number of entry nodes and the number of exit nodes\" \"cannot be maintained because of the size 1 component.\" ) for src_comp in comps : src_option = src_comp - exit_nodes if keep_num_exit else src_comp tgt_option = tgt_comp - entry_nodes if keep_num_entry else tgt_comp src_i = Util . get_min_out_node ( G , src_option ) tgt_i = Util . get_min_in_node ( G , tgt_option ) G . add_edge ( src_i , tgt_i )","title":"DAGBuilderBase"},{"location":"dag_builder/#src.dag_builder.dag_builder_base.DAGBuilderBase.__init__","text":"Constructor. Parameters: Name Type Description Default config Config Config. required max_try int , optional Maximum number of build attempts for a single DAG, by default 100 100 Source code in src\\dag_builder\\dag_builder_base.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , config : Config , max_try : int = 100 ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. max_try : int, optional Maximum number of build attempts for a single DAG, by default 100 \"\"\" self . _validate_config ( config ) self . _config = config self . _max_try = max_try","title":"__init__()"},{"location":"dag_builder/#src.dag_builder.DAGBuilderFactory","text":"DAG builder factory class. Source code in src\\dag_builder\\dag_builder_factory.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class DAGBuilderFactory : \"\"\"DAG builder factory class.\"\"\" @staticmethod def create_instance ( config : Config ) -> DAGBuilderBase : \"\"\"Create DAG builder instance. Currently supported generation methods: - Fan-in/fan-out method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - G(n, p) method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - Chain-based method Parameters ---------- config : Config Config. Returns ------- DAGBuilderBase DAG builder. Raises ------ NotImplementedError Not implement. \"\"\" generation_method = config . generation_method if Util . ambiguous_equals ( generation_method , \"fan-in/fan-out\" ): return FanInFanOutBuilder ( config ) elif Util . ambiguous_equals ( generation_method , \"g(n, p)\" ): return GNPBuilder ( config ) elif Util . ambiguous_equals ( generation_method , \"chain-based\" ): return ChainBasedBuilder ( config ) else : raise NotImplementedError","title":"DAGBuilderFactory"},{"location":"dag_builder/#src.dag_builder.dag_builder_factory.DAGBuilderFactory.create_instance","text":"Create DAG builder instance. Currently supported generation methods: - Fan-in/fan-out method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - G(n, p) method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - Chain-based method Parameters: Name Type Description Default config Config Config. required Returns: Type Description DAGBuilderBase DAG builder. Raises: Type Description NotImplementedError Not implement. Source code in src\\dag_builder\\dag_builder_factory.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @staticmethod def create_instance ( config : Config ) -> DAGBuilderBase : \"\"\"Create DAG builder instance. Currently supported generation methods: - Fan-in/fan-out method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - G(n, p) method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - Chain-based method Parameters ---------- config : Config Config. Returns ------- DAGBuilderBase DAG builder. Raises ------ NotImplementedError Not implement. \"\"\" generation_method = config . generation_method if Util . ambiguous_equals ( generation_method , \"fan-in/fan-out\" ): return FanInFanOutBuilder ( config ) elif Util . ambiguous_equals ( generation_method , \"g(n, p)\" ): return GNPBuilder ( config ) elif Util . ambiguous_equals ( generation_method , \"chain-based\" ): return ChainBasedBuilder ( config ) else : raise NotImplementedError","title":"create_instance()"},{"location":"dag_builder/#src.dag_builder.FanInFanOutBuilder","text":"Bases: DAGBuilderBase Fan-in/fan-out class. Source code in src\\dag_builder\\fan_in_fan_out_builder.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class FanInFanOutBuilder ( DAGBuilderBase ): \"\"\"Fan-in/fan-out class.\"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) self . _max_out = ( max ( self . _config . out_degree ) if isinstance ( self . _config . out_degree , list ) else self . _config . out_degree ) self . _max_in = ( max ( self . _config . in_degree ) if isinstance ( self . _config . in_degree , list ) else self . _config . in_degree ) def _validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = Util . get_option_min ( config . number_of_entry_nodes ) number_of_exit_nodes = Util . get_option_min ( config . number_of_exit_nodes ) or 1 number_of_nodes = Util . get_option_max ( config . number_of_nodes ) if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : # type: ignore raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" ) def build ( self ) -> Generator : \"\"\"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): num_build_fail = 0 # Determine number_of_nodes (Loop finish condition) num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize dag num_entry = Util . random_choice ( self . _config . number_of_entry_nodes ) G = self . _init_dag ( num_entry ) while G . number_of_nodes () != num_nodes : if Util . true_or_false (): # Fan-out max_diff_node_i , diff = self . _search_max_diff_node ( G ) num_add = random . randint ( 1 , diff ) add_node_i_list = [ G . number_of_nodes () + i for i in range ( num_add )] nx . add_star ( G , [ max_diff_node_i ] + add_node_i_list ) else : # Fan-in num_sources = random . randint ( 1 , self . _max_in ) nodes = list ( G . nodes ()) random . shuffle ( nodes ) sources = [] for node_i in nodes : if G . out_degree ( node_i ) < self . _max_out : sources . append ( node_i ) if len ( sources ) == num_sources : break add_node_i = G . number_of_nodes () G . add_node ( add_node_i ) for source_node_i in sources : G . add_edge ( source_node_i , add_node_i ) # Check build fail if G . number_of_nodes () > num_nodes : num_build_fail += 1 if num_build_fail == self . _max_try : msg = ( \"A DAG satisfying 'Number of nodes' could not be built \" f \"in { self . _max_try } tries.\" ) raise BuildFailedError ( msg ) else : G = self . _init_dag ( num_entry ) # reset # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : self . _ensure_weakly_connected ( G , True , bool ( num_exit )) yield G def _search_max_diff_node ( self , G : nx . DiGraph ) -> Tuple [ int , int ]: \"\"\"Search max difference node. Find the node with the biggest difference between its out-degree and max value of 'out-degree' parameter. Returns ------- Tuple[int, int] - Index of node with the biggest difference - Difference size \"\"\" min_out_i = Util . get_min_out_node ( G , G . nodes ) max_diff = self . _max_out - G . out_degree ( min_out_i ) return min_out_i , max_diff def _init_dag ( self , num_entry : int ) -> nx . DiGraph : G = nx . DiGraph () for _ in range ( num_entry ): G . add_node ( G . number_of_nodes ()) return G","title":"FanInFanOutBuilder"},{"location":"dag_builder/#src.dag_builder.fan_in_fan_out_builder.FanInFanOutBuilder.build","text":"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields: Type Description Generator DAG generator. Raises: Type Description BuildFailedError The number of build failures exceeded the maximum number of attempts. Source code in src\\dag_builder\\fan_in_fan_out_builder.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def build ( self ) -> Generator : \"\"\"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): num_build_fail = 0 # Determine number_of_nodes (Loop finish condition) num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize dag num_entry = Util . random_choice ( self . _config . number_of_entry_nodes ) G = self . _init_dag ( num_entry ) while G . number_of_nodes () != num_nodes : if Util . true_or_false (): # Fan-out max_diff_node_i , diff = self . _search_max_diff_node ( G ) num_add = random . randint ( 1 , diff ) add_node_i_list = [ G . number_of_nodes () + i for i in range ( num_add )] nx . add_star ( G , [ max_diff_node_i ] + add_node_i_list ) else : # Fan-in num_sources = random . randint ( 1 , self . _max_in ) nodes = list ( G . nodes ()) random . shuffle ( nodes ) sources = [] for node_i in nodes : if G . out_degree ( node_i ) < self . _max_out : sources . append ( node_i ) if len ( sources ) == num_sources : break add_node_i = G . number_of_nodes () G . add_node ( add_node_i ) for source_node_i in sources : G . add_edge ( source_node_i , add_node_i ) # Check build fail if G . number_of_nodes () > num_nodes : num_build_fail += 1 if num_build_fail == self . _max_try : msg = ( \"A DAG satisfying 'Number of nodes' could not be built \" f \"in { self . _max_try } tries.\" ) raise BuildFailedError ( msg ) else : G = self . _init_dag ( num_entry ) # reset # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : self . _ensure_weakly_connected ( G , True , bool ( num_exit )) yield G","title":"build()"},{"location":"dag_builder/#src.dag_builder.GNPBuilder","text":"Bases: DAGBuilderBase G(n, p) class. Source code in src\\dag_builder\\g_n_p_builder.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class GNPBuilder ( DAGBuilderBase ): \"\"\"G(n, p) class.\"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) def _validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = Util . get_option_min ( config . number_of_entry_nodes ) or 1 number_of_exit_nodes = Util . get_option_min ( config . number_of_exit_nodes ) or 1 number_of_nodes = Util . get_option_max ( config . number_of_nodes ) if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : # type: ignore raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" ) if config . probability_of_edge > 1.0 : logger . warning ( \"'Probability of edge' > 1.0\" ) def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using G(n, p) method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Determine number_of_nodes num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_entry = self . _config . number_of_entry_nodes if num_entry : num_entry = Util . random_choice ( num_entry ) num_nodes -= num_entry num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize DAG G = nx . DiGraph () for i in range ( num_nodes ): G . add_node ( G . number_of_nodes ()) # Add edge prob_edge = Util . random_choice ( self . _config . probability_of_edge ) for i in range ( num_nodes ): for j in range ( num_nodes ): if random . randint ( 1 , 100 ) < prob_edge * 100 and i < j : G . add_edge ( i , j ) # Add entry nodes (Optional) if num_entry : self . _force_create_entry_nodes ( G , num_entry ) # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : try : self . _ensure_weakly_connected ( G , bool ( num_entry ), bool ( num_exit )) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield G","title":"GNPBuilder"},{"location":"dag_builder/#src.dag_builder.g_n_p_builder.GNPBuilder.build","text":"Build DAG using G(n, p) method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields: Type Description Generator DAG generator. Raises: Type Description BuildFailedError The number of build failures exceeded the maximum number of attempts. Source code in src\\dag_builder\\g_n_p_builder.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using G(n, p) method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Determine number_of_nodes num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_entry = self . _config . number_of_entry_nodes if num_entry : num_entry = Util . random_choice ( num_entry ) num_nodes -= num_entry num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize DAG G = nx . DiGraph () for i in range ( num_nodes ): G . add_node ( G . number_of_nodes ()) # Add edge prob_edge = Util . random_choice ( self . _config . probability_of_edge ) for i in range ( num_nodes ): for j in range ( num_nodes ): if random . randint ( 1 , 100 ) < prob_edge * 100 and i < j : G . add_edge ( i , j ) # Add entry nodes (Optional) if num_entry : self . _force_create_entry_nodes ( G , num_entry ) # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : try : self . _ensure_weakly_connected ( G , bool ( num_entry ), bool ( num_exit )) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield G","title":"build()"},{"location":"dag_exporter/","text":"DAGExporter # DAG exporter class. Source code in src\\dag_exporter\\dag_exporter.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 class DAGExporter : \"\"\"DAG exporter class.\"\"\" def __init__ ( self , config : Config ) -> None : self . _config = config def export ( self , dag : nx . DiGraph , dest_dir : str , file_name : str ) -> None : \"\"\"Export DAG. Parameters ---------- dag : nx.DiGraph DAG. dest_dir : str Destination directory. file_name : str File name. \"\"\" self . _export_dag ( dag , dest_dir , file_name ) if self . _config . figure : self . _export_fig ( dag , dest_dir , file_name ) def _export_dag ( self , dag : nx . DiGraph , dest_dir : str , file_name : str ) -> None : \"\"\"Export DAG description file. Supported extension: [YAML/JSON/DOT/XML]. Parameters ---------- dag : nx.DiGraph DAG. dest_dir : str Destination directory. file_name : str File name. \"\"\" if self . _config . yaml : data = json_graph . node_link_data ( dag ) s = json . dumps ( data ) dic = json . loads ( s ) with open ( f \" { dest_dir } / { file_name } .yaml\" , \"w\" ) as f : yaml . dump ( dic , f ) if self . _config . json : data = json_graph . node_link_data ( dag ) s = json . dumps ( data ) with open ( f \" { dest_dir } / { file_name } .json\" , \"w\" ) as f : json . dump ( s , f ) if self . _config . dot : nx . drawing . nx_pydot . write_dot ( dag , f \" { dest_dir } / { file_name } .dot\" ) if self . _config . xml : nx . write_graphml_xml ( dag , f \" { dest_dir } / { file_name } .xml\" ) def _export_fig ( self , dag : nx . DiGraph , dest_dir : str , file_name : str ) -> None : \"\"\"Export DAG figure. Supported extension: [PNG/PDF/EPS/SVG]. Parameters ---------- dag : nx.DiGraph DAG. dest_dir : str Destination directory. file_name : str File name. \"\"\" # Preprocessing for node_i in dag . nodes (): dag . nodes [ node_i ][ \"label\" ] = ( f \"[ { node_i } ] \\n \" f 'C: { dag . nodes [ node_i ][ \"execution_time\" ] } ' ) if period := dag . nodes [ node_i ] . get ( \"period\" ): dag . nodes [ node_i ][ \"shape\" ] = \"box\" dag . nodes [ node_i ][ \"label\" ] += f \" \\n T: { period } \" if deadline := dag . nodes [ node_i ] . get ( \"end_to_end_deadline\" ): dag . nodes [ node_i ][ \"style\" ] = \"bold\" dag . nodes [ node_i ][ \"label\" ] += f \" \\n D: { deadline } \" for src_i , tgt_i in dag . edges (): if comm := dag . edges [ src_i , tgt_i ] . get ( \"communication_time\" ): dag . edges [ src_i , tgt_i ][ \"label\" ] = f \" { comm } \" dag . edges [ src_i , tgt_i ][ \"fontsize\" ] = 10 # Add legend if self . _config . draw_legend : legend_str = [ \"----- Legend ---- \\n\\n \" , \"Circle node: Event-driven node\\l\" , \"[i]: Task index\\l\" , \"C: Worst-case execution time (WCET)\\l\" , ] if self . _config . multi_rate : legend_str . insert ( 1 , \"Square node: Timer-driven node\\l\" ) legend_str . append ( \"T: Period\\l\" ) if self . _config . end_to_end_deadline : legend_str . append ( \"D: End-to-end deadline\\l\" ) if self . _config . communication_time : legend_str . append ( \"Number attached to arrow: Communication time\\l\" ) dag . add_node ( - 1 , label = \"\" . join ( legend_str ), fontsize = 15 , shape = \"box3d\" ) # Export pdot = nx . drawing . nx_pydot . to_pydot ( dag ) if self . _config . png : pdot . write_png ( f \" { dest_dir } / { file_name } .png\" ) if self . _config . svg : pdot . write_svg ( f \" { dest_dir } / { file_name } .svg\" ) if self . _config . pdf : pdot . write_pdf ( f \" { dest_dir } / { file_name } .pdf\" ) if self . _config . eps : pdot . write_ps ( f \" { dest_dir } / { file_name } .ps\" ) subprocess . run ( f \"eps2eps { dest_dir } / { file_name } .ps { dest_dir } / { file_name } .eps \\ && rm { dest_dir } / { file_name } .ps\" , shell = True , ) export ( dag , dest_dir , file_name ) # Export DAG. Parameters: Name Type Description Default dag nx . DiGraph DAG. required dest_dir str Destination directory. required file_name str File name. required Source code in src\\dag_exporter\\dag_exporter.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def export ( self , dag : nx . DiGraph , dest_dir : str , file_name : str ) -> None : \"\"\"Export DAG. Parameters ---------- dag : nx.DiGraph DAG. dest_dir : str Destination directory. file_name : str File name. \"\"\" self . _export_dag ( dag , dest_dir , file_name ) if self . _config . figure : self . _export_fig ( dag , dest_dir , file_name )","title":"dag_exporter"},{"location":"dag_exporter/#src.dag_exporter.DAGExporter","text":"DAG exporter class. Source code in src\\dag_exporter\\dag_exporter.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 class DAGExporter : \"\"\"DAG exporter class.\"\"\" def __init__ ( self , config : Config ) -> None : self . _config = config def export ( self , dag : nx . DiGraph , dest_dir : str , file_name : str ) -> None : \"\"\"Export DAG. Parameters ---------- dag : nx.DiGraph DAG. dest_dir : str Destination directory. file_name : str File name. \"\"\" self . _export_dag ( dag , dest_dir , file_name ) if self . _config . figure : self . _export_fig ( dag , dest_dir , file_name ) def _export_dag ( self , dag : nx . DiGraph , dest_dir : str , file_name : str ) -> None : \"\"\"Export DAG description file. Supported extension: [YAML/JSON/DOT/XML]. Parameters ---------- dag : nx.DiGraph DAG. dest_dir : str Destination directory. file_name : str File name. \"\"\" if self . _config . yaml : data = json_graph . node_link_data ( dag ) s = json . dumps ( data ) dic = json . loads ( s ) with open ( f \" { dest_dir } / { file_name } .yaml\" , \"w\" ) as f : yaml . dump ( dic , f ) if self . _config . json : data = json_graph . node_link_data ( dag ) s = json . dumps ( data ) with open ( f \" { dest_dir } / { file_name } .json\" , \"w\" ) as f : json . dump ( s , f ) if self . _config . dot : nx . drawing . nx_pydot . write_dot ( dag , f \" { dest_dir } / { file_name } .dot\" ) if self . _config . xml : nx . write_graphml_xml ( dag , f \" { dest_dir } / { file_name } .xml\" ) def _export_fig ( self , dag : nx . DiGraph , dest_dir : str , file_name : str ) -> None : \"\"\"Export DAG figure. Supported extension: [PNG/PDF/EPS/SVG]. Parameters ---------- dag : nx.DiGraph DAG. dest_dir : str Destination directory. file_name : str File name. \"\"\" # Preprocessing for node_i in dag . nodes (): dag . nodes [ node_i ][ \"label\" ] = ( f \"[ { node_i } ] \\n \" f 'C: { dag . nodes [ node_i ][ \"execution_time\" ] } ' ) if period := dag . nodes [ node_i ] . get ( \"period\" ): dag . nodes [ node_i ][ \"shape\" ] = \"box\" dag . nodes [ node_i ][ \"label\" ] += f \" \\n T: { period } \" if deadline := dag . nodes [ node_i ] . get ( \"end_to_end_deadline\" ): dag . nodes [ node_i ][ \"style\" ] = \"bold\" dag . nodes [ node_i ][ \"label\" ] += f \" \\n D: { deadline } \" for src_i , tgt_i in dag . edges (): if comm := dag . edges [ src_i , tgt_i ] . get ( \"communication_time\" ): dag . edges [ src_i , tgt_i ][ \"label\" ] = f \" { comm } \" dag . edges [ src_i , tgt_i ][ \"fontsize\" ] = 10 # Add legend if self . _config . draw_legend : legend_str = [ \"----- Legend ---- \\n\\n \" , \"Circle node: Event-driven node\\l\" , \"[i]: Task index\\l\" , \"C: Worst-case execution time (WCET)\\l\" , ] if self . _config . multi_rate : legend_str . insert ( 1 , \"Square node: Timer-driven node\\l\" ) legend_str . append ( \"T: Period\\l\" ) if self . _config . end_to_end_deadline : legend_str . append ( \"D: End-to-end deadline\\l\" ) if self . _config . communication_time : legend_str . append ( \"Number attached to arrow: Communication time\\l\" ) dag . add_node ( - 1 , label = \"\" . join ( legend_str ), fontsize = 15 , shape = \"box3d\" ) # Export pdot = nx . drawing . nx_pydot . to_pydot ( dag ) if self . _config . png : pdot . write_png ( f \" { dest_dir } / { file_name } .png\" ) if self . _config . svg : pdot . write_svg ( f \" { dest_dir } / { file_name } .svg\" ) if self . _config . pdf : pdot . write_pdf ( f \" { dest_dir } / { file_name } .pdf\" ) if self . _config . eps : pdot . write_ps ( f \" { dest_dir } / { file_name } .ps\" ) subprocess . run ( f \"eps2eps { dest_dir } / { file_name } .ps { dest_dir } / { file_name } .eps \\ && rm { dest_dir } / { file_name } .ps\" , shell = True , )","title":"DAGExporter"},{"location":"dag_exporter/#src.dag_exporter.dag_exporter.DAGExporter.export","text":"Export DAG. Parameters: Name Type Description Default dag nx . DiGraph DAG. required dest_dir str Destination directory. required file_name str File name. required Source code in src\\dag_exporter\\dag_exporter.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def export ( self , dag : nx . DiGraph , dest_dir : str , file_name : str ) -> None : \"\"\"Export DAG. Parameters ---------- dag : nx.DiGraph DAG. dest_dir : str Destination directory. file_name : str File name. \"\"\" self . _export_dag ( dag , dest_dir , file_name ) if self . _config . figure : self . _export_fig ( dag , dest_dir , file_name )","title":"export()"},{"location":"exceptions/","text":"BuildFailedError # Bases: Error Failed to build. Source code in src\\exceptions.py 12 13 14 15 16 class BuildFailedError ( Error ): \"\"\"Failed to build.\"\"\" def __init__ ( self , message : str ) -> None : self . message = message Error # Bases: Exception Base class for exception. Source code in src\\exceptions.py 1 2 class Error ( Exception ): \"\"\"Base class for exception.\"\"\" InfeasibleConfigError # Bases: Error Infeasible parameters entered. Source code in src\\exceptions.py 5 6 7 8 9 class InfeasibleConfigError ( Error ): \"\"\"Infeasible parameters entered.\"\"\" def __init__ ( self , message : str ) -> None : self . message = message","title":"exceptions"},{"location":"exceptions/#src.exceptions.BuildFailedError","text":"Bases: Error Failed to build. Source code in src\\exceptions.py 12 13 14 15 16 class BuildFailedError ( Error ): \"\"\"Failed to build.\"\"\" def __init__ ( self , message : str ) -> None : self . message = message","title":"BuildFailedError"},{"location":"exceptions/#src.exceptions.Error","text":"Bases: Exception Base class for exception. Source code in src\\exceptions.py 1 2 class Error ( Exception ): \"\"\"Base class for exception.\"\"\"","title":"Error"},{"location":"exceptions/#src.exceptions.InfeasibleConfigError","text":"Bases: Error Infeasible parameters entered. Source code in src\\exceptions.py 5 6 7 8 9 class InfeasibleConfigError ( Error ): \"\"\"Infeasible parameters entered.\"\"\" def __init__ ( self , message : str ) -> None : self . message = message","title":"InfeasibleConfigError"},{"location":"property_setter/","text":"AdditionalSetter # Bases: PropertySetterBase Additional setter class. Set additional parameters completely at random. Source code in src\\property_setter\\additional_setter.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class AdditionalSetter ( PropertySetterBase ): \"\"\"Additional setter class. Set additional parameters completely at random. \"\"\" def __init__ ( self , config : Config ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. \"\"\" super () . __init__ ( config ) def _validate_config ( self , config : Config ) -> None : pass def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Completely random set additional properties. Parameters ---------- dag : nx.DiGraph DAG \"\"\" if node_properties := self . _config . node_properties : for param_name , option in node_properties . items (): for node_i in dag . nodes : dag . nodes [ node_i ][ param_name ] = Util . random_choice ( option ) if edge_properties := self . _config . edge_properties : for param_name , option in edge_properties . items (): for src_i , tgt_i in dag . edges : dag . edges [ src_i , tgt_i ][ param_name ] = Util . random_choice ( option ) __init__ ( config ) # Constructor. Parameters: Name Type Description Default config Config Config. required Source code in src\\property_setter\\additional_setter.py 15 16 17 18 19 20 21 22 23 24 def __init__ ( self , config : Config ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. \"\"\" super () . __init__ ( config ) set ( dag ) # Completely random set additional properties. Parameters: Name Type Description Default dag nx . DiGraph DAG required Source code in src\\property_setter\\additional_setter.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Completely random set additional properties. Parameters ---------- dag : nx.DiGraph DAG \"\"\" if node_properties := self . _config . node_properties : for param_name , option in node_properties . items (): for node_i in dag . nodes : dag . nodes [ node_i ][ param_name ] = Util . random_choice ( option ) if edge_properties := self . _config . edge_properties : for param_name , option in edge_properties . items (): for src_i , tgt_i in dag . edges : dag . edges [ src_i , tgt_i ][ param_name ] = Util . random_choice ( option ) CCRSetter # Bases: PropertySetterBase CCR setter class. Source code in src\\property_setter\\ccr_setter.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class CCRSetter ( PropertySetterBase ): \"\"\"CCR setter class.\"\"\" def __init__ ( self , config : Config ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. \"\"\" super () . __init__ ( config ) def _validate_config ( self , config : Config ) -> None : execution_time = config . execution_time communication_time = config . communication_time if execution_time and communication_time : logger . warning ( \"Both 'Execution time' and 'Communication time' are specified, \" \"but 'Communication time' is determined based on 'Execution time' and 'CCR'. \" \"So, the range of 'Communication time' entered is ignored.\" ) def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Set CCR. Parameters ---------- dag : nx.DiGraph DAG. Notes ----- If both 'Execution time' and 'Communication time' are specified, 'Execution time' is given priority and 'Communication time' is calculated based on 'Execution time' and 'CCR' (i.e., the range of 'Communication time' specified is ignored). \"\"\" ccr = Util . random_choice ( self . _config . ccr ) if self . _config . execution_time : self . _set_by_exec ( dag , ccr ) else : self . _set_by_comm ( dag , ccr ) def _set_by_exec ( self , dag : nx . DiGraph , ccr : float ) -> None : # Set execution time sum_exec = 0 for node_i in dag . nodes (): exec = Util . random_choice ( self . _config . execution_time ) dag . nodes [ node_i ][ \"execution_time\" ] = exec sum_exec += exec # Calculate sum_comm sum_comm = int ( ccr * sum_exec ) # Set communication time comm_grouping = self . _grouping ( sum_comm , dag . number_of_edges ()) if not comm_grouping : self . _output_round_up_warning ( \"Communication time\" , \"CCR\" ) comm_grouping = [ 1 for _ in range ( dag . number_of_edges ())] for edge , comm in zip ( dag . edges (), comm_grouping ): dag . edges [ edge [ 0 ], edge [ 1 ]][ \"communication_time\" ] = comm def _set_by_comm ( self , dag : nx . DiGraph , ccr : float ) -> None : # Set communication time sum_comm = 0 for src_i , tgt_i in dag . edges (): comm = Util . random_choice ( self . _config . communication_time ) dag . edges [ src_i , tgt_i ][ \"communication_time\" ] = comm sum_comm += comm # Calculate sum_exec sum_exec = int ( sum_comm / ccr ) # Set communication time exec_grouping = self . _grouping ( sum_exec , dag . number_of_nodes ()) if not exec_grouping : self . _output_round_up_warning ( \"Execution time\" , \"CCR\" ) exec_grouping = [ 1 for _ in range ( dag . number_of_nodes ())] for node_i , exec in zip ( dag . nodes (), exec_grouping ): dag . nodes [ node_i ][ \"execution_time\" ] = exec __init__ ( config ) # Constructor. Parameters: Name Type Description Default config Config Config. required Source code in src\\property_setter\\ccr_setter.py 15 16 17 18 19 20 21 22 23 24 def __init__ ( self , config : Config ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. \"\"\" super () . __init__ ( config ) set ( dag ) # Set CCR. Parameters: Name Type Description Default dag nx . DiGraph DAG. required Notes # If both 'Execution time' and 'Communication time' are specified, 'Execution time' is given priority and 'Communication time' is calculated based on 'Execution time' and 'CCR' (i.e., the range of 'Communication time' specified is ignored). Source code in src\\property_setter\\ccr_setter.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Set CCR. Parameters ---------- dag : nx.DiGraph DAG. Notes ----- If both 'Execution time' and 'Communication time' are specified, 'Execution time' is given priority and 'Communication time' is calculated based on 'Execution time' and 'CCR' (i.e., the range of 'Communication time' specified is ignored). \"\"\" ccr = Util . random_choice ( self . _config . ccr ) if self . _config . execution_time : self . _set_by_exec ( dag , ccr ) else : self . _set_by_comm ( dag , ccr ) DeadlineSetter # Bases: PropertySetterBase Deadline setter class. Source code in src\\property_setter\\deadline_setter.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class DeadlineSetter ( PropertySetterBase ): \"\"\"Deadline setter class.\"\"\" def __init__ ( self , config : Config ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. \"\"\" super () . __init__ ( config ) def _validate_config ( self , config : Config ) -> None : pass def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Set end-to-end deadline based on critical path length. Parameters ---------- dag : nx.DiGraph DAG. \"\"\" for exit_i in Util . get_exit_nodes ( dag ): max_cp_len = 0 for entry_i in Util . get_entry_nodes ( dag ): cp_len = self . _get_cp_len ( dag , entry_i , exit_i ) if cp_len > max_cp_len : max_cp_len = cp_len dag . nodes [ exit_i ][ \"end_to_end_deadline\" ] = int ( max_cp_len * Util . random_choice ( self . _config . ratio_of_deadline_to_critical_path ) ) @staticmethod def _get_cp_len ( dag : nx . DiGraph , source : int , exit : int ) -> int : \"\"\"Get critical path length. Parameters ---------- dag : nx.DiGraph DAG. source : int Index of path source. exit : int Index of path exit. Returns ------- int Critical path length. Notes ----- If the edge has 'Communication time', 'Communication time' is also included in critical path length. \"\"\" cp_len = 0 for path in nx . all_simple_paths ( dag , source = source , target = exit ): path_len = 0 for i in range ( len ( path )): path_len += dag . nodes [ path [ i ]][ \"execution_time\" ] if i != len ( path ) - 1 and dag . edges [ path [ i ], path [ i + 1 ]] . get ( \"communication_time\" ): path_len += dag . edges [ path [ i ], path [ i + 1 ]][ \"communication_time\" ] if path_len > cp_len : cp_len = path_len return cp_len __init__ ( config ) # Constructor. Parameters: Name Type Description Default config Config Config. required Source code in src\\property_setter\\deadline_setter.py 11 12 13 14 15 16 17 18 19 20 def __init__ ( self , config : Config ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. \"\"\" super () . __init__ ( config ) set ( dag ) # Set end-to-end deadline based on critical path length. Parameters: Name Type Description Default dag nx . DiGraph DAG. required Source code in src\\property_setter\\deadline_setter.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Set end-to-end deadline based on critical path length. Parameters ---------- dag : nx.DiGraph DAG. \"\"\" for exit_i in Util . get_exit_nodes ( dag ): max_cp_len = 0 for entry_i in Util . get_entry_nodes ( dag ): cp_len = self . _get_cp_len ( dag , entry_i , exit_i ) if cp_len > max_cp_len : max_cp_len = cp_len dag . nodes [ exit_i ][ \"end_to_end_deadline\" ] = int ( max_cp_len * Util . random_choice ( self . _config . ratio_of_deadline_to_critical_path ) ) PropertySetterFactory # Property setter factory class. Source code in src\\property_setter\\property_setter_factory.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class PropertySetterFactory : \"\"\"Property setter factory class.\"\"\" @staticmethod def create_utilization_setter ( config : Config ) -> UtilizationSetter : \"\"\"Create utilization setter. Parameters ---------- config : Config Config. Returns ------- UtilizationSetter Utilization setter. \"\"\" return UtilizationSetter ( config ) @staticmethod def create_ccr_setter ( config : Config ) -> CCRSetter : \"\"\"Create CCR setter. Parameters ---------- config : Config Config. Returns ------- CCRSetter CCR setter. \"\"\" return CCRSetter ( config ) @staticmethod def create_deadline_setter ( config : Config ) -> DeadlineSetter : \"\"\"Create deadline setter. Parameters ---------- config : Config Config. Returns ------- DeadlineSetter Deadline setter. \"\"\" return DeadlineSetter ( config ) @staticmethod def create_random_setter ( config : Config , parameter_name : str , target : str ) -> RandomSetter : \"\"\"Create random setter. Parameters ---------- config : Config Config parameter_name : str Parameter name target : str \"node\" or \"edge\" Returns ------- RandomSetter Random setter. \"\"\" return RandomSetter ( config , parameter_name , target ) @staticmethod def create_additional_setter ( config : Config ) -> AdditionalSetter : \"\"\"Create additional setter. Parameters ---------- config : Config Config. Returns ------- AdditionalSetter Additional setter. \"\"\" return AdditionalSetter ( config ) create_additional_setter ( config ) staticmethod # Create additional setter. Parameters: Name Type Description Default config Config Config. required Returns: Type Description AdditionalSetter Additional setter. Source code in src\\property_setter\\property_setter_factory.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @staticmethod def create_additional_setter ( config : Config ) -> AdditionalSetter : \"\"\"Create additional setter. Parameters ---------- config : Config Config. Returns ------- AdditionalSetter Additional setter. \"\"\" return AdditionalSetter ( config ) create_ccr_setter ( config ) staticmethod # Create CCR setter. Parameters: Name Type Description Default config Config Config. required Returns: Type Description CCRSetter CCR setter. Source code in src\\property_setter\\property_setter_factory.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @staticmethod def create_ccr_setter ( config : Config ) -> CCRSetter : \"\"\"Create CCR setter. Parameters ---------- config : Config Config. Returns ------- CCRSetter CCR setter. \"\"\" return CCRSetter ( config ) create_deadline_setter ( config ) staticmethod # Create deadline setter. Parameters: Name Type Description Default config Config Config. required Returns: Type Description DeadlineSetter Deadline setter. Source code in src\\property_setter\\property_setter_factory.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @staticmethod def create_deadline_setter ( config : Config ) -> DeadlineSetter : \"\"\"Create deadline setter. Parameters ---------- config : Config Config. Returns ------- DeadlineSetter Deadline setter. \"\"\" return DeadlineSetter ( config ) create_random_setter ( config , parameter_name , target ) staticmethod # Create random setter. Parameters: Name Type Description Default config Config Config required parameter_name str Parameter name required target str \"node\" or \"edge\" required Returns: Type Description RandomSetter Random setter. Source code in src\\property_setter\\property_setter_factory.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 @staticmethod def create_random_setter ( config : Config , parameter_name : str , target : str ) -> RandomSetter : \"\"\"Create random setter. Parameters ---------- config : Config Config parameter_name : str Parameter name target : str \"node\" or \"edge\" Returns ------- RandomSetter Random setter. \"\"\" return RandomSetter ( config , parameter_name , target ) create_utilization_setter ( config ) staticmethod # Create utilization setter. Parameters: Name Type Description Default config Config Config. required Returns: Type Description UtilizationSetter Utilization setter. Source code in src\\property_setter\\property_setter_factory.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @staticmethod def create_utilization_setter ( config : Config ) -> UtilizationSetter : \"\"\"Create utilization setter. Parameters ---------- config : Config Config. Returns ------- UtilizationSetter Utilization setter. \"\"\" return UtilizationSetter ( config ) RandomSetter # Bases: PropertySetterBase Random setter class. Set the specified parameters completely at random. Source code in src\\property_setter\\random_setter.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class RandomSetter ( PropertySetterBase ): \"\"\"Random setter class. Set the specified parameters completely at random. \"\"\" def __init__ ( self , config : Config , parameter_name : str , target : str ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. parameter_name : str Parameter name. target : str Target to be set. \"node\" or \"edge\". \"\"\" super () . __init__ ( config ) self . _param_name = parameter_name self . _target = target def _validate_config ( self , config : Config ) -> None : pass def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Completely random set. Parameters ---------- dag : nx.DiGraph DAG \"\"\" property_name = Util . convert_to_property ( self . _param_name ) option = getattr ( self . _config , property_name ) if self . _target == \"node\" : for node_i in dag . nodes (): dag . nodes [ node_i ][ property_name ] = Util . random_choice ( option ) else : for src_i , tgt_i in dag . edges (): dag . edges [ src_i , tgt_i ][ property_name ] = Util . random_choice ( option ) __init__ ( config , parameter_name , target ) # Constructor. Parameters: Name Type Description Default config Config Config. required parameter_name str Parameter name. required target str Target to be set. \"node\" or \"edge\". required Source code in src\\property_setter\\random_setter.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def __init__ ( self , config : Config , parameter_name : str , target : str ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. parameter_name : str Parameter name. target : str Target to be set. \"node\" or \"edge\". \"\"\" super () . __init__ ( config ) self . _param_name = parameter_name self . _target = target set ( dag ) # Completely random set. Parameters: Name Type Description Default dag nx . DiGraph DAG required Source code in src\\property_setter\\random_setter.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Completely random set. Parameters ---------- dag : nx.DiGraph DAG \"\"\" property_name = Util . convert_to_property ( self . _param_name ) option = getattr ( self . _config , property_name ) if self . _target == \"node\" : for node_i in dag . nodes (): dag . nodes [ node_i ][ property_name ] = Util . random_choice ( option ) else : for src_i , tgt_i in dag . edges (): dag . edges [ src_i , tgt_i ][ property_name ] = Util . random_choice ( option ) UtilizationSetter # Bases: PropertySetterBase Utilization setter class. Notes # If both 'Period' and 'Execution time' are specified, 'Execution time' is determined based on utilization and period (i.e., the range of 'Execution time' specified is ignored). The minimum value of 'Execution time' is 1 and never 0. Source code in src\\property_setter\\utilization_setter.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 class UtilizationSetter ( PropertySetterBase ): \"\"\"Utilization setter class. Notes ----- If both 'Period' and 'Execution time' are specified, 'Execution time' is determined based on utilization and period (i.e., the range of 'Execution time' specified is ignored). The minimum value of 'Execution time' is 1 and never 0. \"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) def _validate_config ( self , config : Config ) -> None : period = config . period execution_time = config . execution_time if period and execution_time : logger . warning ( \"Both 'Period' and 'Execution time' are specified, \" \"but 'Execution time' is determined based on utilization and period. \" \"So, the range of 'Execution time' entered is ignored.\" ) def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Set period and execution time based on utilization. Parameters ---------- dag : nx.DiGraph DAG. Notes ----- If a chain-based DAG is entered 'Periodic type' is 'Chain', the chain utilization is used (see https://par.nsf.gov/servlets/purl/10276465). \"\"\" total_utilization = self . _config . total_utilization is_chain_case = isinstance ( dag , ChainBasedDAG ) and Util . ambiguous_equals ( self . _config . periodic_type , \"chain\" ) if is_chain_case : if total_utilization : self . _set_by_total_utilization_chain ( dag ) else : self . _set_by_only_max_utilization_chain ( dag ) else : if total_utilization : self . _set_by_total_utilization ( dag ) else : self . _set_by_only_max_utilization ( dag ) # Set remain execution times for node_i in dag . nodes : if not dag . nodes [ node_i ] . get ( \"execution_time\" ): dag . nodes [ node_i ][ \"execution_time\" ] = Util . random_choice ( self . _config . execution_time ) def _set_by_total_utilization ( self , dag : nx . DiGraph ) -> None : \"\"\"Set period and execution time based on total utilization. Parameters ---------- dag : nx.DiGraph DAG. \"\"\" timer_driven_nodes = self . _get_timer_driven_nodes ( dag ) utilizations = self . _UUniFast ( Util . random_choice ( self . _config . total_utilization ), len ( timer_driven_nodes ), self . _config . maximum_utilization , ) for timer_i , utilization in zip ( timer_driven_nodes , utilizations ): selected_period = self . _choice_period ( dag , timer_i ) dag . nodes [ timer_i ][ \"period\" ] = selected_period exec = int ( utilization * selected_period ) if exec == 0 : self . _output_round_up_warning ( \"Execution time\" , \"Utilization\" ) exec = 1 dag . nodes [ timer_i ][ \"execution_time\" ] = exec def _set_by_total_utilization_chain ( self , chain_based_dag : ChainBasedDAG ) -> None : timer_driven_nodes = self . _get_timer_driven_nodes ( chain_based_dag ) utilizations = self . _UUniFast ( Util . random_choice ( self . _config . total_utilization ), len ( timer_driven_nodes ), self . _config . maximum_utilization , ) for chain in chain_based_dag . chains : selected_period = self . _choice_period ( chain_based_dag , chain . head ) chain_based_dag . nodes [ chain . head ][ \"period\" ] = selected_period utilization = utilizations [ timer_driven_nodes . index ( chain . head )] sum_exec = int ( utilization * selected_period ) exec_grouping = self . _grouping ( sum_exec , chain . number_of_nodes ()) # type: ignore if not exec_grouping : self . _output_round_up_warning ( \"Execution time\" , \"Utilization\" ) exec_grouping = [ 1 for _ in range ( chain . number_of_nodes ())] for node_i , exec in zip ( chain . nodes , exec_grouping ): chain_based_dag . nodes [ node_i ][ \"execution_time\" ] = exec def _set_by_only_max_utilization ( self , dag : nx . DiGraph ) -> None : \"\"\"Set period and execution time randomly by only maximum utilization. Parameters ---------- dag : nx.DiGraph DAG. Notes ----- If 'Maximum utilization' is not specified, 'Maximum utilization' is set to 1.0. \"\"\" max_u = self . _config . maximum_utilization or 1.0 for node_i in self . _get_timer_driven_nodes ( dag ): selected_period = self . _choice_period ( dag , node_i ) dag . nodes [ node_i ][ \"period\" ] = selected_period min_u = 1 / selected_period # Ensure 'Execution time' is at least 1. if min_u > max_u : self . _output_round_up_warning ( \"Execution time\" , \"Utilization\" ) exec = 1 else : utilization = random . uniform ( min_u , max_u ) exec = int ( utilization * selected_period ) dag . nodes [ node_i ][ \"execution_time\" ] = exec def _set_by_only_max_utilization_chain ( self , chain_based_dag : ChainBasedDAG ) -> None : \"\"\"Set period and execution time randomly by only maximum utilization. Parameters ---------- chain_based_dag: ChainBasedDAG Chain-based DAG. Notes ----- If 'Maximum utilization' is not specified, 'Maximum utilization' is set to 1.0. \"\"\" max_u = self . _config . maximum_utilization or 1.0 for chain in chain_based_dag . chains : selected_period = self . _choice_period ( chain_based_dag , chain . head ) chain_based_dag . nodes [ chain . head ][ \"period\" ] = selected_period min_u = ( chain . number_of_nodes () / selected_period ) # Ensure 'Execution time' is at least 1. if min_u > max_u : self . _output_round_up_warning ( \"Execution time\" , \"Utilization\" ) exec_grouping = [ 1 for _ in range ( chain . number_of_nodes ())] else : utilization = random . uniform ( min_u , max_u ) sum_exec = int ( utilization * selected_period ) exec_grouping = self . _grouping ( sum_exec , chain . number_of_nodes ()) # type: ignore if not exec_grouping : self . _output_round_up_warning ( \"Execution time\" , \"Utilization\" ) exec_grouping = [ 1 for _ in range ( chain . number_of_nodes ())] for node_i , exec in zip ( chain . nodes , exec_grouping ): chain_based_dag . nodes [ node_i ][ \"execution_time\" ] = exec @staticmethod def _UUniFast ( total_u : float , n : int , max_u : Optional [ float ] = None ) -> List [ float ]: \"\"\"Determine utilization based on UUniFast method. For detail, see https://idp.springer.com/authorize/casa?redirect_uri=https://link.springer.com/content/pdf/10.1007/s11241-005-0507-9.pdf&casa_token=ILaVXw6_1aUAAAAA:KEgQ8Iv70JXyNHj7hs11YvW2KRIPm89ab_1bILtRZFI5sBU1A7QGYaNDMshx4up16pA4W2gDohyAQmJqWyc. Parameters ---------- total_u : float Total utilization. n : int Number of elements to distribute utilization. max_u : float Maximum utilization, by default None. Returns ------- List[float] List of utilizations. Notes ----- - If both 'Total utilization' and 'Maximum utilization' cannot be met, ignore 'Total utilization' and set each utilization to 'Maximum utilization'. - If $'total_u' / 'n' \\simeq 'max_u'$, it takes an enormous amount of time to distribute them. Therefore, if the number of attempts exceeds the threshold, the utilization is distributed equally. \"\"\" if max_u : if ( total_u / n ) >= max_u : logger . warning ( \"Only either 'Total utilization' or 'Maximum utilization' can be satisfied.\" \"Therefore, 'Total utilization' is ignored \" \"and each utilization is set to 'Maximum utilization'.\" \"To prevent this, it is recommended to reduce 'Total utilization', \" \"increase 'Maximum utilization', or increase the number of nodes.\" ) utilizations = [ max_u for _ in range ( n )] else : utilizations = UtilizationSetter . _UUniFast_with_max_u ( total_u , n , max_u ) else : # Original UUniFast method remain_u = total_u utilizations : List [ float ] = [] # type: ignore for i in range ( n - 1 ): next_u = - sys . maxsize next_u = remain_u * ( random . uniform ( 0 , 1 ) ** ( 1 / ( n - i ))) utilizations . append ( remain_u - next_u ) remain_u = next_u utilizations . append ( remain_u ) return utilizations @staticmethod def _UUniFast_with_max_u ( total_u : float , n : int , max_u : float ) -> List [ float ]: \"\"\"Determine utilization based on UUniFast method not to exceed 'max_u'. Parameters ---------- total_u : float Total utilization. n : int Number of elements to distribute utilization. max_u : float Maximum utilization. Returns ------- List[float] List of utilizations. Notes ----- If $'total_u' / 'n' \\simeq 'max_u'$, it takes an enormous amount of time to distribute them. Therefore, if the number of attempts exceeds the threshold, the utilization is distributed equally. \"\"\" max_try = 100 # HACK for try_i in range ( 1 , max_try + 1 ): remain_u = total_u utilizations : List [ float ] = [] for i in range ( n - 1 ): next_u = - sys . maxsize while remain_u - next_u >= max_u : next_u = remain_u * ( random . uniform ( 0 , 1 ) ** ( 1 / ( n - i ))) utilizations . append ( remain_u - next_u ) remain_u = next_u if remain_u < max_u : utilizations . append ( remain_u ) break if try_i == max_try : # HACK: Distribute equally. utilizations = [ total_u / n for _ in range ( n )] return utilizations def _choice_period ( self , dag : nx . DiGraph , node_i : int ) -> int : if self . _config . entry_node_period and node_i in Util . get_entry_nodes ( dag ): return Util . random_choice ( self . _config . entry_node_period ) if self . _config . exit_node_period and node_i in Util . get_exit_nodes ( dag ): return Util . random_choice ( self . _config . exit_node_period ) return Util . random_choice ( self . _config . period ) def _get_timer_driven_nodes ( self , dag : nx . DiGraph ) -> List [ int ]: \"\"\"Get indices of timer-driven nodes according to 'Periodic type'. Parameters ---------- dag : nx.DiGraph DAG. Returns ------- List[int] List of indexes of timer-driven nodes. \"\"\" periodic_type = self . _config . periodic_type timer_driven_nodes : List [ int ] if Util . ambiguous_equals ( periodic_type , \"All\" ): timer_driven_nodes = list ( dag . nodes ()) elif Util . ambiguous_equals ( periodic_type , \"IO\" ): timer_driven_nodes = list ( set ( Util . get_entry_nodes ( dag ) + Util . get_exit_nodes ( dag ))) elif Util . ambiguous_equals ( periodic_type , \"Entry\" ): timer_driven_nodes = Util . get_entry_nodes ( dag ) elif isinstance ( dag , ChainBasedDAG ) and Util . ambiguous_equals ( periodic_type , \"Chain\" ): timer_driven_nodes = dag . chain_heads return timer_driven_nodes set ( dag ) # Set period and execution time based on utilization. Parameters: Name Type Description Default dag nx . DiGraph DAG. required Notes # If a chain-based DAG is entered 'Periodic type' is 'Chain', the chain utilization is used (see https://par.nsf.gov/servlets/purl/10276465). Source code in src\\property_setter\\utilization_setter.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Set period and execution time based on utilization. Parameters ---------- dag : nx.DiGraph DAG. Notes ----- If a chain-based DAG is entered 'Periodic type' is 'Chain', the chain utilization is used (see https://par.nsf.gov/servlets/purl/10276465). \"\"\" total_utilization = self . _config . total_utilization is_chain_case = isinstance ( dag , ChainBasedDAG ) and Util . ambiguous_equals ( self . _config . periodic_type , \"chain\" ) if is_chain_case : if total_utilization : self . _set_by_total_utilization_chain ( dag ) else : self . _set_by_only_max_utilization_chain ( dag ) else : if total_utilization : self . _set_by_total_utilization ( dag ) else : self . _set_by_only_max_utilization ( dag ) # Set remain execution times for node_i in dag . nodes : if not dag . nodes [ node_i ] . get ( \"execution_time\" ): dag . nodes [ node_i ][ \"execution_time\" ] = Util . random_choice ( self . _config . execution_time )","title":"property_setter"},{"location":"property_setter/#src.property_setter.AdditionalSetter","text":"Bases: PropertySetterBase Additional setter class. Set additional parameters completely at random. Source code in src\\property_setter\\additional_setter.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class AdditionalSetter ( PropertySetterBase ): \"\"\"Additional setter class. Set additional parameters completely at random. \"\"\" def __init__ ( self , config : Config ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. \"\"\" super () . __init__ ( config ) def _validate_config ( self , config : Config ) -> None : pass def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Completely random set additional properties. Parameters ---------- dag : nx.DiGraph DAG \"\"\" if node_properties := self . _config . node_properties : for param_name , option in node_properties . items (): for node_i in dag . nodes : dag . nodes [ node_i ][ param_name ] = Util . random_choice ( option ) if edge_properties := self . _config . edge_properties : for param_name , option in edge_properties . items (): for src_i , tgt_i in dag . edges : dag . edges [ src_i , tgt_i ][ param_name ] = Util . random_choice ( option )","title":"AdditionalSetter"},{"location":"property_setter/#src.property_setter.additional_setter.AdditionalSetter.__init__","text":"Constructor. Parameters: Name Type Description Default config Config Config. required Source code in src\\property_setter\\additional_setter.py 15 16 17 18 19 20 21 22 23 24 def __init__ ( self , config : Config ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. \"\"\" super () . __init__ ( config )","title":"__init__()"},{"location":"property_setter/#src.property_setter.additional_setter.AdditionalSetter.set","text":"Completely random set additional properties. Parameters: Name Type Description Default dag nx . DiGraph DAG required Source code in src\\property_setter\\additional_setter.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Completely random set additional properties. Parameters ---------- dag : nx.DiGraph DAG \"\"\" if node_properties := self . _config . node_properties : for param_name , option in node_properties . items (): for node_i in dag . nodes : dag . nodes [ node_i ][ param_name ] = Util . random_choice ( option ) if edge_properties := self . _config . edge_properties : for param_name , option in edge_properties . items (): for src_i , tgt_i in dag . edges : dag . edges [ src_i , tgt_i ][ param_name ] = Util . random_choice ( option )","title":"set()"},{"location":"property_setter/#src.property_setter.CCRSetter","text":"Bases: PropertySetterBase CCR setter class. Source code in src\\property_setter\\ccr_setter.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class CCRSetter ( PropertySetterBase ): \"\"\"CCR setter class.\"\"\" def __init__ ( self , config : Config ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. \"\"\" super () . __init__ ( config ) def _validate_config ( self , config : Config ) -> None : execution_time = config . execution_time communication_time = config . communication_time if execution_time and communication_time : logger . warning ( \"Both 'Execution time' and 'Communication time' are specified, \" \"but 'Communication time' is determined based on 'Execution time' and 'CCR'. \" \"So, the range of 'Communication time' entered is ignored.\" ) def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Set CCR. Parameters ---------- dag : nx.DiGraph DAG. Notes ----- If both 'Execution time' and 'Communication time' are specified, 'Execution time' is given priority and 'Communication time' is calculated based on 'Execution time' and 'CCR' (i.e., the range of 'Communication time' specified is ignored). \"\"\" ccr = Util . random_choice ( self . _config . ccr ) if self . _config . execution_time : self . _set_by_exec ( dag , ccr ) else : self . _set_by_comm ( dag , ccr ) def _set_by_exec ( self , dag : nx . DiGraph , ccr : float ) -> None : # Set execution time sum_exec = 0 for node_i in dag . nodes (): exec = Util . random_choice ( self . _config . execution_time ) dag . nodes [ node_i ][ \"execution_time\" ] = exec sum_exec += exec # Calculate sum_comm sum_comm = int ( ccr * sum_exec ) # Set communication time comm_grouping = self . _grouping ( sum_comm , dag . number_of_edges ()) if not comm_grouping : self . _output_round_up_warning ( \"Communication time\" , \"CCR\" ) comm_grouping = [ 1 for _ in range ( dag . number_of_edges ())] for edge , comm in zip ( dag . edges (), comm_grouping ): dag . edges [ edge [ 0 ], edge [ 1 ]][ \"communication_time\" ] = comm def _set_by_comm ( self , dag : nx . DiGraph , ccr : float ) -> None : # Set communication time sum_comm = 0 for src_i , tgt_i in dag . edges (): comm = Util . random_choice ( self . _config . communication_time ) dag . edges [ src_i , tgt_i ][ \"communication_time\" ] = comm sum_comm += comm # Calculate sum_exec sum_exec = int ( sum_comm / ccr ) # Set communication time exec_grouping = self . _grouping ( sum_exec , dag . number_of_nodes ()) if not exec_grouping : self . _output_round_up_warning ( \"Execution time\" , \"CCR\" ) exec_grouping = [ 1 for _ in range ( dag . number_of_nodes ())] for node_i , exec in zip ( dag . nodes (), exec_grouping ): dag . nodes [ node_i ][ \"execution_time\" ] = exec","title":"CCRSetter"},{"location":"property_setter/#src.property_setter.ccr_setter.CCRSetter.__init__","text":"Constructor. Parameters: Name Type Description Default config Config Config. required Source code in src\\property_setter\\ccr_setter.py 15 16 17 18 19 20 21 22 23 24 def __init__ ( self , config : Config ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. \"\"\" super () . __init__ ( config )","title":"__init__()"},{"location":"property_setter/#src.property_setter.ccr_setter.CCRSetter.set","text":"Set CCR. Parameters: Name Type Description Default dag nx . DiGraph DAG. required","title":"set()"},{"location":"property_setter/#src.property_setter.ccr_setter.CCRSetter.set--notes","text":"If both 'Execution time' and 'Communication time' are specified, 'Execution time' is given priority and 'Communication time' is calculated based on 'Execution time' and 'CCR' (i.e., the range of 'Communication time' specified is ignored). Source code in src\\property_setter\\ccr_setter.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Set CCR. Parameters ---------- dag : nx.DiGraph DAG. Notes ----- If both 'Execution time' and 'Communication time' are specified, 'Execution time' is given priority and 'Communication time' is calculated based on 'Execution time' and 'CCR' (i.e., the range of 'Communication time' specified is ignored). \"\"\" ccr = Util . random_choice ( self . _config . ccr ) if self . _config . execution_time : self . _set_by_exec ( dag , ccr ) else : self . _set_by_comm ( dag , ccr )","title":"Notes"},{"location":"property_setter/#src.property_setter.DeadlineSetter","text":"Bases: PropertySetterBase Deadline setter class. Source code in src\\property_setter\\deadline_setter.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class DeadlineSetter ( PropertySetterBase ): \"\"\"Deadline setter class.\"\"\" def __init__ ( self , config : Config ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. \"\"\" super () . __init__ ( config ) def _validate_config ( self , config : Config ) -> None : pass def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Set end-to-end deadline based on critical path length. Parameters ---------- dag : nx.DiGraph DAG. \"\"\" for exit_i in Util . get_exit_nodes ( dag ): max_cp_len = 0 for entry_i in Util . get_entry_nodes ( dag ): cp_len = self . _get_cp_len ( dag , entry_i , exit_i ) if cp_len > max_cp_len : max_cp_len = cp_len dag . nodes [ exit_i ][ \"end_to_end_deadline\" ] = int ( max_cp_len * Util . random_choice ( self . _config . ratio_of_deadline_to_critical_path ) ) @staticmethod def _get_cp_len ( dag : nx . DiGraph , source : int , exit : int ) -> int : \"\"\"Get critical path length. Parameters ---------- dag : nx.DiGraph DAG. source : int Index of path source. exit : int Index of path exit. Returns ------- int Critical path length. Notes ----- If the edge has 'Communication time', 'Communication time' is also included in critical path length. \"\"\" cp_len = 0 for path in nx . all_simple_paths ( dag , source = source , target = exit ): path_len = 0 for i in range ( len ( path )): path_len += dag . nodes [ path [ i ]][ \"execution_time\" ] if i != len ( path ) - 1 and dag . edges [ path [ i ], path [ i + 1 ]] . get ( \"communication_time\" ): path_len += dag . edges [ path [ i ], path [ i + 1 ]][ \"communication_time\" ] if path_len > cp_len : cp_len = path_len return cp_len","title":"DeadlineSetter"},{"location":"property_setter/#src.property_setter.deadline_setter.DeadlineSetter.__init__","text":"Constructor. Parameters: Name Type Description Default config Config Config. required Source code in src\\property_setter\\deadline_setter.py 11 12 13 14 15 16 17 18 19 20 def __init__ ( self , config : Config ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. \"\"\" super () . __init__ ( config )","title":"__init__()"},{"location":"property_setter/#src.property_setter.deadline_setter.DeadlineSetter.set","text":"Set end-to-end deadline based on critical path length. Parameters: Name Type Description Default dag nx . DiGraph DAG. required Source code in src\\property_setter\\deadline_setter.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Set end-to-end deadline based on critical path length. Parameters ---------- dag : nx.DiGraph DAG. \"\"\" for exit_i in Util . get_exit_nodes ( dag ): max_cp_len = 0 for entry_i in Util . get_entry_nodes ( dag ): cp_len = self . _get_cp_len ( dag , entry_i , exit_i ) if cp_len > max_cp_len : max_cp_len = cp_len dag . nodes [ exit_i ][ \"end_to_end_deadline\" ] = int ( max_cp_len * Util . random_choice ( self . _config . ratio_of_deadline_to_critical_path ) )","title":"set()"},{"location":"property_setter/#src.property_setter.PropertySetterFactory","text":"Property setter factory class. Source code in src\\property_setter\\property_setter_factory.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class PropertySetterFactory : \"\"\"Property setter factory class.\"\"\" @staticmethod def create_utilization_setter ( config : Config ) -> UtilizationSetter : \"\"\"Create utilization setter. Parameters ---------- config : Config Config. Returns ------- UtilizationSetter Utilization setter. \"\"\" return UtilizationSetter ( config ) @staticmethod def create_ccr_setter ( config : Config ) -> CCRSetter : \"\"\"Create CCR setter. Parameters ---------- config : Config Config. Returns ------- CCRSetter CCR setter. \"\"\" return CCRSetter ( config ) @staticmethod def create_deadline_setter ( config : Config ) -> DeadlineSetter : \"\"\"Create deadline setter. Parameters ---------- config : Config Config. Returns ------- DeadlineSetter Deadline setter. \"\"\" return DeadlineSetter ( config ) @staticmethod def create_random_setter ( config : Config , parameter_name : str , target : str ) -> RandomSetter : \"\"\"Create random setter. Parameters ---------- config : Config Config parameter_name : str Parameter name target : str \"node\" or \"edge\" Returns ------- RandomSetter Random setter. \"\"\" return RandomSetter ( config , parameter_name , target ) @staticmethod def create_additional_setter ( config : Config ) -> AdditionalSetter : \"\"\"Create additional setter. Parameters ---------- config : Config Config. Returns ------- AdditionalSetter Additional setter. \"\"\" return AdditionalSetter ( config )","title":"PropertySetterFactory"},{"location":"property_setter/#src.property_setter.property_setter_factory.PropertySetterFactory.create_additional_setter","text":"Create additional setter. Parameters: Name Type Description Default config Config Config. required Returns: Type Description AdditionalSetter Additional setter. Source code in src\\property_setter\\property_setter_factory.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @staticmethod def create_additional_setter ( config : Config ) -> AdditionalSetter : \"\"\"Create additional setter. Parameters ---------- config : Config Config. Returns ------- AdditionalSetter Additional setter. \"\"\" return AdditionalSetter ( config )","title":"create_additional_setter()"},{"location":"property_setter/#src.property_setter.property_setter_factory.PropertySetterFactory.create_ccr_setter","text":"Create CCR setter. Parameters: Name Type Description Default config Config Config. required Returns: Type Description CCRSetter CCR setter. Source code in src\\property_setter\\property_setter_factory.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @staticmethod def create_ccr_setter ( config : Config ) -> CCRSetter : \"\"\"Create CCR setter. Parameters ---------- config : Config Config. Returns ------- CCRSetter CCR setter. \"\"\" return CCRSetter ( config )","title":"create_ccr_setter()"},{"location":"property_setter/#src.property_setter.property_setter_factory.PropertySetterFactory.create_deadline_setter","text":"Create deadline setter. Parameters: Name Type Description Default config Config Config. required Returns: Type Description DeadlineSetter Deadline setter. Source code in src\\property_setter\\property_setter_factory.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @staticmethod def create_deadline_setter ( config : Config ) -> DeadlineSetter : \"\"\"Create deadline setter. Parameters ---------- config : Config Config. Returns ------- DeadlineSetter Deadline setter. \"\"\" return DeadlineSetter ( config )","title":"create_deadline_setter()"},{"location":"property_setter/#src.property_setter.property_setter_factory.PropertySetterFactory.create_random_setter","text":"Create random setter. Parameters: Name Type Description Default config Config Config required parameter_name str Parameter name required target str \"node\" or \"edge\" required Returns: Type Description RandomSetter Random setter. Source code in src\\property_setter\\property_setter_factory.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 @staticmethod def create_random_setter ( config : Config , parameter_name : str , target : str ) -> RandomSetter : \"\"\"Create random setter. Parameters ---------- config : Config Config parameter_name : str Parameter name target : str \"node\" or \"edge\" Returns ------- RandomSetter Random setter. \"\"\" return RandomSetter ( config , parameter_name , target )","title":"create_random_setter()"},{"location":"property_setter/#src.property_setter.property_setter_factory.PropertySetterFactory.create_utilization_setter","text":"Create utilization setter. Parameters: Name Type Description Default config Config Config. required Returns: Type Description UtilizationSetter Utilization setter. Source code in src\\property_setter\\property_setter_factory.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @staticmethod def create_utilization_setter ( config : Config ) -> UtilizationSetter : \"\"\"Create utilization setter. Parameters ---------- config : Config Config. Returns ------- UtilizationSetter Utilization setter. \"\"\" return UtilizationSetter ( config )","title":"create_utilization_setter()"},{"location":"property_setter/#src.property_setter.RandomSetter","text":"Bases: PropertySetterBase Random setter class. Set the specified parameters completely at random. Source code in src\\property_setter\\random_setter.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class RandomSetter ( PropertySetterBase ): \"\"\"Random setter class. Set the specified parameters completely at random. \"\"\" def __init__ ( self , config : Config , parameter_name : str , target : str ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. parameter_name : str Parameter name. target : str Target to be set. \"node\" or \"edge\". \"\"\" super () . __init__ ( config ) self . _param_name = parameter_name self . _target = target def _validate_config ( self , config : Config ) -> None : pass def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Completely random set. Parameters ---------- dag : nx.DiGraph DAG \"\"\" property_name = Util . convert_to_property ( self . _param_name ) option = getattr ( self . _config , property_name ) if self . _target == \"node\" : for node_i in dag . nodes (): dag . nodes [ node_i ][ property_name ] = Util . random_choice ( option ) else : for src_i , tgt_i in dag . edges (): dag . edges [ src_i , tgt_i ][ property_name ] = Util . random_choice ( option )","title":"RandomSetter"},{"location":"property_setter/#src.property_setter.random_setter.RandomSetter.__init__","text":"Constructor. Parameters: Name Type Description Default config Config Config. required parameter_name str Parameter name. required target str Target to be set. \"node\" or \"edge\". required Source code in src\\property_setter\\random_setter.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def __init__ ( self , config : Config , parameter_name : str , target : str ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. parameter_name : str Parameter name. target : str Target to be set. \"node\" or \"edge\". \"\"\" super () . __init__ ( config ) self . _param_name = parameter_name self . _target = target","title":"__init__()"},{"location":"property_setter/#src.property_setter.random_setter.RandomSetter.set","text":"Completely random set. Parameters: Name Type Description Default dag nx . DiGraph DAG required Source code in src\\property_setter\\random_setter.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Completely random set. Parameters ---------- dag : nx.DiGraph DAG \"\"\" property_name = Util . convert_to_property ( self . _param_name ) option = getattr ( self . _config , property_name ) if self . _target == \"node\" : for node_i in dag . nodes (): dag . nodes [ node_i ][ property_name ] = Util . random_choice ( option ) else : for src_i , tgt_i in dag . edges (): dag . edges [ src_i , tgt_i ][ property_name ] = Util . random_choice ( option )","title":"set()"},{"location":"property_setter/#src.property_setter.UtilizationSetter","text":"Bases: PropertySetterBase Utilization setter class.","title":"UtilizationSetter"},{"location":"property_setter/#src.property_setter.UtilizationSetter--notes","text":"If both 'Period' and 'Execution time' are specified, 'Execution time' is determined based on utilization and period (i.e., the range of 'Execution time' specified is ignored). The minimum value of 'Execution time' is 1 and never 0. Source code in src\\property_setter\\utilization_setter.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 class UtilizationSetter ( PropertySetterBase ): \"\"\"Utilization setter class. Notes ----- If both 'Period' and 'Execution time' are specified, 'Execution time' is determined based on utilization and period (i.e., the range of 'Execution time' specified is ignored). The minimum value of 'Execution time' is 1 and never 0. \"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) def _validate_config ( self , config : Config ) -> None : period = config . period execution_time = config . execution_time if period and execution_time : logger . warning ( \"Both 'Period' and 'Execution time' are specified, \" \"but 'Execution time' is determined based on utilization and period. \" \"So, the range of 'Execution time' entered is ignored.\" ) def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Set period and execution time based on utilization. Parameters ---------- dag : nx.DiGraph DAG. Notes ----- If a chain-based DAG is entered 'Periodic type' is 'Chain', the chain utilization is used (see https://par.nsf.gov/servlets/purl/10276465). \"\"\" total_utilization = self . _config . total_utilization is_chain_case = isinstance ( dag , ChainBasedDAG ) and Util . ambiguous_equals ( self . _config . periodic_type , \"chain\" ) if is_chain_case : if total_utilization : self . _set_by_total_utilization_chain ( dag ) else : self . _set_by_only_max_utilization_chain ( dag ) else : if total_utilization : self . _set_by_total_utilization ( dag ) else : self . _set_by_only_max_utilization ( dag ) # Set remain execution times for node_i in dag . nodes : if not dag . nodes [ node_i ] . get ( \"execution_time\" ): dag . nodes [ node_i ][ \"execution_time\" ] = Util . random_choice ( self . _config . execution_time ) def _set_by_total_utilization ( self , dag : nx . DiGraph ) -> None : \"\"\"Set period and execution time based on total utilization. Parameters ---------- dag : nx.DiGraph DAG. \"\"\" timer_driven_nodes = self . _get_timer_driven_nodes ( dag ) utilizations = self . _UUniFast ( Util . random_choice ( self . _config . total_utilization ), len ( timer_driven_nodes ), self . _config . maximum_utilization , ) for timer_i , utilization in zip ( timer_driven_nodes , utilizations ): selected_period = self . _choice_period ( dag , timer_i ) dag . nodes [ timer_i ][ \"period\" ] = selected_period exec = int ( utilization * selected_period ) if exec == 0 : self . _output_round_up_warning ( \"Execution time\" , \"Utilization\" ) exec = 1 dag . nodes [ timer_i ][ \"execution_time\" ] = exec def _set_by_total_utilization_chain ( self , chain_based_dag : ChainBasedDAG ) -> None : timer_driven_nodes = self . _get_timer_driven_nodes ( chain_based_dag ) utilizations = self . _UUniFast ( Util . random_choice ( self . _config . total_utilization ), len ( timer_driven_nodes ), self . _config . maximum_utilization , ) for chain in chain_based_dag . chains : selected_period = self . _choice_period ( chain_based_dag , chain . head ) chain_based_dag . nodes [ chain . head ][ \"period\" ] = selected_period utilization = utilizations [ timer_driven_nodes . index ( chain . head )] sum_exec = int ( utilization * selected_period ) exec_grouping = self . _grouping ( sum_exec , chain . number_of_nodes ()) # type: ignore if not exec_grouping : self . _output_round_up_warning ( \"Execution time\" , \"Utilization\" ) exec_grouping = [ 1 for _ in range ( chain . number_of_nodes ())] for node_i , exec in zip ( chain . nodes , exec_grouping ): chain_based_dag . nodes [ node_i ][ \"execution_time\" ] = exec def _set_by_only_max_utilization ( self , dag : nx . DiGraph ) -> None : \"\"\"Set period and execution time randomly by only maximum utilization. Parameters ---------- dag : nx.DiGraph DAG. Notes ----- If 'Maximum utilization' is not specified, 'Maximum utilization' is set to 1.0. \"\"\" max_u = self . _config . maximum_utilization or 1.0 for node_i in self . _get_timer_driven_nodes ( dag ): selected_period = self . _choice_period ( dag , node_i ) dag . nodes [ node_i ][ \"period\" ] = selected_period min_u = 1 / selected_period # Ensure 'Execution time' is at least 1. if min_u > max_u : self . _output_round_up_warning ( \"Execution time\" , \"Utilization\" ) exec = 1 else : utilization = random . uniform ( min_u , max_u ) exec = int ( utilization * selected_period ) dag . nodes [ node_i ][ \"execution_time\" ] = exec def _set_by_only_max_utilization_chain ( self , chain_based_dag : ChainBasedDAG ) -> None : \"\"\"Set period and execution time randomly by only maximum utilization. Parameters ---------- chain_based_dag: ChainBasedDAG Chain-based DAG. Notes ----- If 'Maximum utilization' is not specified, 'Maximum utilization' is set to 1.0. \"\"\" max_u = self . _config . maximum_utilization or 1.0 for chain in chain_based_dag . chains : selected_period = self . _choice_period ( chain_based_dag , chain . head ) chain_based_dag . nodes [ chain . head ][ \"period\" ] = selected_period min_u = ( chain . number_of_nodes () / selected_period ) # Ensure 'Execution time' is at least 1. if min_u > max_u : self . _output_round_up_warning ( \"Execution time\" , \"Utilization\" ) exec_grouping = [ 1 for _ in range ( chain . number_of_nodes ())] else : utilization = random . uniform ( min_u , max_u ) sum_exec = int ( utilization * selected_period ) exec_grouping = self . _grouping ( sum_exec , chain . number_of_nodes ()) # type: ignore if not exec_grouping : self . _output_round_up_warning ( \"Execution time\" , \"Utilization\" ) exec_grouping = [ 1 for _ in range ( chain . number_of_nodes ())] for node_i , exec in zip ( chain . nodes , exec_grouping ): chain_based_dag . nodes [ node_i ][ \"execution_time\" ] = exec @staticmethod def _UUniFast ( total_u : float , n : int , max_u : Optional [ float ] = None ) -> List [ float ]: \"\"\"Determine utilization based on UUniFast method. For detail, see https://idp.springer.com/authorize/casa?redirect_uri=https://link.springer.com/content/pdf/10.1007/s11241-005-0507-9.pdf&casa_token=ILaVXw6_1aUAAAAA:KEgQ8Iv70JXyNHj7hs11YvW2KRIPm89ab_1bILtRZFI5sBU1A7QGYaNDMshx4up16pA4W2gDohyAQmJqWyc. Parameters ---------- total_u : float Total utilization. n : int Number of elements to distribute utilization. max_u : float Maximum utilization, by default None. Returns ------- List[float] List of utilizations. Notes ----- - If both 'Total utilization' and 'Maximum utilization' cannot be met, ignore 'Total utilization' and set each utilization to 'Maximum utilization'. - If $'total_u' / 'n' \\simeq 'max_u'$, it takes an enormous amount of time to distribute them. Therefore, if the number of attempts exceeds the threshold, the utilization is distributed equally. \"\"\" if max_u : if ( total_u / n ) >= max_u : logger . warning ( \"Only either 'Total utilization' or 'Maximum utilization' can be satisfied.\" \"Therefore, 'Total utilization' is ignored \" \"and each utilization is set to 'Maximum utilization'.\" \"To prevent this, it is recommended to reduce 'Total utilization', \" \"increase 'Maximum utilization', or increase the number of nodes.\" ) utilizations = [ max_u for _ in range ( n )] else : utilizations = UtilizationSetter . _UUniFast_with_max_u ( total_u , n , max_u ) else : # Original UUniFast method remain_u = total_u utilizations : List [ float ] = [] # type: ignore for i in range ( n - 1 ): next_u = - sys . maxsize next_u = remain_u * ( random . uniform ( 0 , 1 ) ** ( 1 / ( n - i ))) utilizations . append ( remain_u - next_u ) remain_u = next_u utilizations . append ( remain_u ) return utilizations @staticmethod def _UUniFast_with_max_u ( total_u : float , n : int , max_u : float ) -> List [ float ]: \"\"\"Determine utilization based on UUniFast method not to exceed 'max_u'. Parameters ---------- total_u : float Total utilization. n : int Number of elements to distribute utilization. max_u : float Maximum utilization. Returns ------- List[float] List of utilizations. Notes ----- If $'total_u' / 'n' \\simeq 'max_u'$, it takes an enormous amount of time to distribute them. Therefore, if the number of attempts exceeds the threshold, the utilization is distributed equally. \"\"\" max_try = 100 # HACK for try_i in range ( 1 , max_try + 1 ): remain_u = total_u utilizations : List [ float ] = [] for i in range ( n - 1 ): next_u = - sys . maxsize while remain_u - next_u >= max_u : next_u = remain_u * ( random . uniform ( 0 , 1 ) ** ( 1 / ( n - i ))) utilizations . append ( remain_u - next_u ) remain_u = next_u if remain_u < max_u : utilizations . append ( remain_u ) break if try_i == max_try : # HACK: Distribute equally. utilizations = [ total_u / n for _ in range ( n )] return utilizations def _choice_period ( self , dag : nx . DiGraph , node_i : int ) -> int : if self . _config . entry_node_period and node_i in Util . get_entry_nodes ( dag ): return Util . random_choice ( self . _config . entry_node_period ) if self . _config . exit_node_period and node_i in Util . get_exit_nodes ( dag ): return Util . random_choice ( self . _config . exit_node_period ) return Util . random_choice ( self . _config . period ) def _get_timer_driven_nodes ( self , dag : nx . DiGraph ) -> List [ int ]: \"\"\"Get indices of timer-driven nodes according to 'Periodic type'. Parameters ---------- dag : nx.DiGraph DAG. Returns ------- List[int] List of indexes of timer-driven nodes. \"\"\" periodic_type = self . _config . periodic_type timer_driven_nodes : List [ int ] if Util . ambiguous_equals ( periodic_type , \"All\" ): timer_driven_nodes = list ( dag . nodes ()) elif Util . ambiguous_equals ( periodic_type , \"IO\" ): timer_driven_nodes = list ( set ( Util . get_entry_nodes ( dag ) + Util . get_exit_nodes ( dag ))) elif Util . ambiguous_equals ( periodic_type , \"Entry\" ): timer_driven_nodes = Util . get_entry_nodes ( dag ) elif isinstance ( dag , ChainBasedDAG ) and Util . ambiguous_equals ( periodic_type , \"Chain\" ): timer_driven_nodes = dag . chain_heads return timer_driven_nodes","title":"Notes"},{"location":"property_setter/#src.property_setter.utilization_setter.UtilizationSetter.set","text":"Set period and execution time based on utilization. Parameters: Name Type Description Default dag nx . DiGraph DAG. required","title":"set()"},{"location":"property_setter/#src.property_setter.utilization_setter.UtilizationSetter.set--notes","text":"If a chain-based DAG is entered 'Periodic type' is 'Chain', the chain utilization is used (see https://par.nsf.gov/servlets/purl/10276465). Source code in src\\property_setter\\utilization_setter.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def set ( self , dag : nx . DiGraph ) -> None : \"\"\"Set period and execution time based on utilization. Parameters ---------- dag : nx.DiGraph DAG. Notes ----- If a chain-based DAG is entered 'Periodic type' is 'Chain', the chain utilization is used (see https://par.nsf.gov/servlets/purl/10276465). \"\"\" total_utilization = self . _config . total_utilization is_chain_case = isinstance ( dag , ChainBasedDAG ) and Util . ambiguous_equals ( self . _config . periodic_type , \"chain\" ) if is_chain_case : if total_utilization : self . _set_by_total_utilization_chain ( dag ) else : self . _set_by_only_max_utilization_chain ( dag ) else : if total_utilization : self . _set_by_total_utilization ( dag ) else : self . _set_by_only_max_utilization ( dag ) # Set remain execution times for node_i in dag . nodes : if not dag . nodes [ node_i ] . get ( \"execution_time\" ): dag . nodes [ node_i ][ \"execution_time\" ] = Util . random_choice ( self . _config . execution_time )","title":"Notes"}]}
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RD-Gen # Packages # config common dag_builder exceptions","title":"HOME"},{"location":"#rd-gen","text":"","title":"RD-Gen"},{"location":"#packages","text":"config common dag_builder exceptions","title":"Packages"},{"location":"common/","text":"","title":"common"},{"location":"config/","text":"ComboGenerator # ComboGenerator class. Source code in src/config/combo_generator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class ComboGenerator : \"\"\"ComboGenerator class.\"\"\" def __init__ ( self , config_raw : dict ) -> None : self . _combo_params : List [ str ] = [] self . _combo_values : List [ Union [ List [ int ], List [ float ]]] = [] self . _search_combo_and_format_tuple ( config_raw [ \"Graph structure\" ]) self . _search_combo_and_format_tuple ( config_raw [ \"Properties\" ]) self . _config = Config ( config_raw ) def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos def get_combo_iter ( self ) -> Generator : \"\"\"Get iterator for combinations. Yields ------ Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v setattr ( combo_config , Util . convert_to_property ( k ), { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config ) def _create_combo_dir_name ( self , combo : Tuple [ Union [ int , float ]], index : int , ) -> str : combo_dir_name : str = \"\" naming = self . _config . naming_of_combination_directory if Util . ambiguous_equals ( naming , \"Full spell\" ): for param , value in zip ( self . _combo_params , combo ): param_str_list = param . split ( \" \" ) param_str_list = [ s . capitalize () for s in param_str_list ] if combo_dir_name : combo_dir_name += f '_ { \"\" . join ( param_str_list ) } _ { value } ' else : combo_dir_name = f ' { \"\" . join ( param_str_list ) } _ { value } ' elif Util . ambiguous_equals ( naming , \"Abbreviation\" ): for param , value in zip ( self . _combo_params , combo ): try : param = TO_ABB [ param . lower ()] except KeyError : # Additional parameter param = param if combo_dir_name : combo_dir_name += f \"_ { param } _ { value } \" else : combo_dir_name = f \" { param } _ { value } \" elif Util . ambiguous_equals ( naming , \"Index of combination\" ): combo_dir_name = f \"Combination_ { index + 1 } \" else : raise NotImplementedError return combo_dir_name @staticmethod def _convert_tuple_to_list ( tuple_str : str ) -> Union [ List [ int ], List [ float ]]: tuple_str = tuple_str . replace ( \"(\" , \"\" ) tuple_str = tuple_str . replace ( \")\" , \"\" ) tuple_str = tuple_str . replace ( \" \" , \"\" ) args : Dict [ str , float ] = {} for i , arg in enumerate ( tuple_str . split ( \",\" )): if i == 0 or \"start\" in arg : args [ \"start\" ] = float ( arg . replace ( \"start=\" , \"\" )) elif i == 1 or \"stop\" in arg : args [ \"stop\" ] = float ( arg . replace ( \"stop=\" , \"\" )) elif i == 2 or \"step\" in arg : args [ \"step\" ] = float ( arg . replace ( \"step=\" , \"\" )) if args [ \"start\" ] . is_integer () and args [ \"stop\" ] . is_integer () and args [ \"step\" ] . is_integer (): # int case converted = list ( range ( int ( args [ \"start\" ]), int ( args [ \"stop\" ]), int ( args [ \"step\" ]))) if ( args [ \"stop\" ] - args [ \"start\" ]) % args [ \"step\" ] == 0 : converted . append ( int ( args [ \"stop\" ])) else : # float case def get_num_decimal_places ( n : float ) -> int : ctx = decimal . Context () d = ctx . create_decimal ( repr ( n )) return len ( format ( d , \"f\" ) . split ( \".\" )[ 1 ]) m = max ( get_num_decimal_places ( args [ \"start\" ]), get_num_decimal_places ( args [ \"stop\" ]), get_num_decimal_places ( args [ \"step\" ]), ) converted = [ round ( n , m ) for n in np . arange ( ** args )] # type: ignore if (( args [ \"stop\" ] * ( 10 ** m )) - ( args [ \"start\" ]) * ( 10 ** m )) % ( args [ \"step\" ] * ( 10 ** m ) ) < 10 **- 10 : converted . append ( args [ \"stop\" ]) # type: ignore return converted def _search_combo_and_format_tuple ( self , param_dict : dict ) -> None : for k , v in param_dict . items (): if \"Combination\" in v . keys (): self . _combo_params . append ( k ) if isinstance ( v [ \"Combination\" ], str ): v [ \"Combination\" ] = self . _convert_tuple_to_list ( v [ \"Combination\" ]) # format self . _combo_values . append ( v [ \"Combination\" ]) else : self . _search_combo_and_format_tuple ( v ) get_combo_iter () # Get iterator for combinations. Yields: Type Description Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. Source code in src/config/combo_generator.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def get_combo_iter ( self ) -> Generator : \"\"\"Get iterator for combinations. Yields ------ Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v setattr ( combo_config , Util . convert_to_property ( k ), { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config ) get_num_combos () # Get number of combinations. Returns: Type Description int Number of combinations. Source code in src/config/combo_generator.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos Config # Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. To obtain the value of 'Additional properties', it is necessary to call a function, not a property. Notes # If the structure of the configuration file changes, this class must be reprogrammed. Source code in src/config/config.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 class Config : \"\"\"Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. To obtain the value of 'Additional properties', it is necessary to call a function, not a property. Notes ----- If the structure of the configuration file changes, this class must be reprogrammed. \"\"\" def __init__ ( self , config_raw : dict ) -> None : self . _seed = config_raw [ \"Seed\" ] self . _number_of_dags = config_raw [ \"Number of DAGs\" ] self . _graph_structure = config_raw [ \"Graph structure\" ] self . _properties = config_raw [ \"Properties\" ] self . _additional_properties : Optional [ AdditionalProperties ] if config_raw [ \"Properties\" ] . get ( \"Additional properties\" ): self . _additional_properties = AdditionalProperties ( config_raw [ \"Properties\" ][ \"Additional properties\" ] ) del config_raw [ \"Properties\" ][ \"Additional properties\" ] else : self . _additional_properties = None self . _output_formats = config_raw [ \"Output formats\" ] # def is_additional(self, param_name: str) -> bool: # if self._additional_properties is None: # return False # additional_property_names = self._additional_properties.get_property_names() # if param_name in additional_property_names: # return True # else: # return False # def get_additional_property(self, property_name: str): # return self._additional_properties.get_value(property_name) # def set_additional_property(self, property_name: str, value) -> None: # self._additional_properties.set_value(property_name, value) def set_random_seed ( self ) -> None : random . seed ( self . seed ) def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . _graph_structure ) self . _remove_random_fixed ( self . _properties ) if self . _additional_properties : self . _additional_properties = AdditionalProperties ( self . _properties [ \"Additional properties\" ] ) @staticmethod def _remove_random_fixed ( param_dict : dict ) -> None : for k , v in param_dict . items (): if set ( v . keys ()) <= { \"Random\" , \"Fixed\" }: # Remove value = list ( v . values ()) assert len ( value ) == 1 param_dict [ k ] = value [ 0 ] break else : Config . _remove_random_fixed ( v ) @property def seed ( self ) -> int : return self . _seed @property def number_of_dags ( self ) -> int : return self . _number_of_dags # ----- Graph Structure ----- @property def generation_method ( self ): return self . _graph_structure . get ( \"Generation method\" ) @property def number_of_nodes ( self ): return self . _graph_structure . get ( \"Number of nodes\" ) @number_of_nodes . setter def number_of_nodes ( self , value ): self . _graph_structure [ \"Number of nodes\" ] = value @property def ensure_weakly_connected ( self ): return self . _graph_structure . get ( \"Ensure weakly connected\" ) @property def out_degree ( self ): return self . _graph_structure . get ( \"Out-degree\" ) @out_degree . setter def out_degree ( self , value ): self . _graph_structure [ \"Out-degree\" ] = value @property def in_degree ( self ): return self . _graph_structure . get ( \"In-degree\" ) @in_degree . setter def in_degree ( self , value ): self . _graph_structure [ \"In-degree\" ] = value @property def probability_of_edge ( self ): return self . _graph_structure . get ( \"Probability of edge\" ) @probability_of_edge . setter def probability_of_edge ( self , value ): self . _graph_structure [ \"Probability of edge\" ] = value @property def number_of_chains ( self ): return self . _graph_structure . get ( \"Number of chains\" ) @number_of_chains . setter def number_of_chains ( self , value ): self . _graph_structure [ \"Number of chains\" ] = value @property def main_sequence_length ( self ): return self . _graph_structure . get ( \"Main sequence length\" ) @main_sequence_length . setter def main_sequence_length ( self , value ): self . _graph_structure [ \"Main sequence length\" ] = value @property def number_of_sub_sequences ( self ): return self . _graph_structure . get ( \"Number of sub sequences\" ) @number_of_sub_sequences . setter def number_of_sub_sequences ( self , value ): self . _graph_structure [ \"Number of sub sequences\" ] = value @property def vertically_link_chains ( self ): return self . _graph_structure . get ( \"Vertically link chains\" ) @property def main_sequence_tail ( self ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Main sequence tail\" ) @main_sequence_tail . setter def main_sequence_tail ( self , value ): self . _graph_structure [ \"Vertically link chains\" ][ \"Main sequence tail\" ] = value @property def sub_sequence_tail ( self ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Sub sequence tail\" ) @sub_sequence_tail . setter def sub_sequence_tail ( self , value ): self . _graph_structure [ \"Vertically link chains\" ][ \"Sub sequence tail\" ] = value @property def number_of_entry_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Number of entry nodes\" ) else : return self . _graph_structure . get ( \"Number of entry nodes\" ) @number_of_entry_nodes . setter def number_of_entry_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . _graph_structure [ \"Vertically link chains\" ][ \"Number of entry nodes\" ] = value else : self . _graph_structure [ \"Number of entry nodes\" ] = value @property def merge_chains ( self ): return self . _graph_structure . get ( \"Merge chains\" ) @property def middle_of_chain ( self ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Middle of chain\" ) @middle_of_chain . setter def middle_of_chain ( self , value ): self . _graph_structure [ \"Merge chains\" ][ \"Middle of chain\" ] = value @property def exit_node ( self ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Exit node\" ) @exit_node . setter def exit_node ( self , value ): self . _graph_structure [ \"Merge chains\" ][ \"Exit node\" ] = value @property def number_of_exit_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Number of exit nodes\" ) else : return self . _graph_structure . get ( \"Number of exit nodes\" ) @number_of_exit_nodes . setter def number_of_exit_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . _graph_structure [ \"Merge chains\" ][ \"Number of exit nodes\" ] = value else : self . _graph_structure [ \"Number of exit nodes\" ] = value # ----- Properties ----- @property def execution_time ( self ): return self . _properties . get ( \"Execution time\" ) @execution_time . setter def execution_time ( self , value ): self . _properties [ \"Execution time\" ] = value @property def communication_time ( self ): return self . _properties . get ( \"Communication time\" ) @communication_time . setter def communication_time ( self , value ): self . _properties [ \"Communication time\" ] = value @property def ccr ( self ): return self . _properties . get ( \"CCR\" ) @ccr . setter def ccr ( self , value ): self . _properties [ \"CCR\" ] = value @property def end_to_end_deadline ( self ): return self . _properties . get ( \"End-to-end deadline\" ) @property def ratio_of_deadline_to_critical_path ( self ): return self . _properties [ \"End-to-end deadline\" ] . get ( \"Ratio of deadline to critical path\" ) @ratio_of_deadline_to_critical_path . setter def ratio_of_deadline_to_critical_path ( self , value ): self . _properties [ \"End-to-end deadline\" ][ \"Ratio of deadline to critical path\" ] = value @property def multi_rate ( self ): return self . _properties . get ( \"Multi-rate\" ) @property def periodic_type ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Periodic type\" ) @periodic_type . setter def periodic_type ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Periodic type\" ] = value @property def period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Period\" ) @period . setter def period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Period\" ] = value @property def entry_node_period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Entry node period\" ) @entry_node_period . setter def entry_node_period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Entry node period\" ] = value @property def exit_node_period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Exit node period\" ) @exit_node_period . setter def exit_node_period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Exit node period\" ] = value @property def offset ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Offset\" ) @offset . setter def offset ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Offset\" ] = value @property def total_utilization ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Total utilization\" ) @total_utilization . setter def total_utilization ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Total utilization\" ] = value @property def maximum_utilization ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Maximum utilization\" ) @maximum_utilization . setter def maximum_utilization ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Maximum utilization\" ] = value # ----- Output formats ----- @property def naming_of_combination_directory ( self ): return self . _output_formats . get ( \"Naming of combination directory\" ) @property def yaml ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"YAML\" ) @property def json ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"JSON\" ) @property def xml ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"XML\" ) @property def dot ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"DOT\" ) @property def draw_legend ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"Draw legend\" ) @property def png ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"PNG\" ) @property def svg ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"SVG\" ) @property def eps ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"EPS\" ) @property def pdf ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"PDF\" ) optimize () # Remove 'Random' and 'Fixed' Source code in src/config/config.py 76 77 78 79 80 81 82 83 def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . _graph_structure ) self . _remove_random_fixed ( self . _properties ) if self . _additional_properties : self . _additional_properties = AdditionalProperties ( self . _properties [ \"Additional properties\" ] ) combo_generator # ComboGenerator # ComboGenerator class. Source code in src/config/combo_generator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class ComboGenerator : \"\"\"ComboGenerator class.\"\"\" def __init__ ( self , config_raw : dict ) -> None : self . _combo_params : List [ str ] = [] self . _combo_values : List [ Union [ List [ int ], List [ float ]]] = [] self . _search_combo_and_format_tuple ( config_raw [ \"Graph structure\" ]) self . _search_combo_and_format_tuple ( config_raw [ \"Properties\" ]) self . _config = Config ( config_raw ) def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos def get_combo_iter ( self ) -> Generator : \"\"\"Get iterator for combinations. Yields ------ Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v setattr ( combo_config , Util . convert_to_property ( k ), { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config ) def _create_combo_dir_name ( self , combo : Tuple [ Union [ int , float ]], index : int , ) -> str : combo_dir_name : str = \"\" naming = self . _config . naming_of_combination_directory if Util . ambiguous_equals ( naming , \"Full spell\" ): for param , value in zip ( self . _combo_params , combo ): param_str_list = param . split ( \" \" ) param_str_list = [ s . capitalize () for s in param_str_list ] if combo_dir_name : combo_dir_name += f '_ { \"\" . join ( param_str_list ) } _ { value } ' else : combo_dir_name = f ' { \"\" . join ( param_str_list ) } _ { value } ' elif Util . ambiguous_equals ( naming , \"Abbreviation\" ): for param , value in zip ( self . _combo_params , combo ): try : param = TO_ABB [ param . lower ()] except KeyError : # Additional parameter param = param if combo_dir_name : combo_dir_name += f \"_ { param } _ { value } \" else : combo_dir_name = f \" { param } _ { value } \" elif Util . ambiguous_equals ( naming , \"Index of combination\" ): combo_dir_name = f \"Combination_ { index + 1 } \" else : raise NotImplementedError return combo_dir_name @staticmethod def _convert_tuple_to_list ( tuple_str : str ) -> Union [ List [ int ], List [ float ]]: tuple_str = tuple_str . replace ( \"(\" , \"\" ) tuple_str = tuple_str . replace ( \")\" , \"\" ) tuple_str = tuple_str . replace ( \" \" , \"\" ) args : Dict [ str , float ] = {} for i , arg in enumerate ( tuple_str . split ( \",\" )): if i == 0 or \"start\" in arg : args [ \"start\" ] = float ( arg . replace ( \"start=\" , \"\" )) elif i == 1 or \"stop\" in arg : args [ \"stop\" ] = float ( arg . replace ( \"stop=\" , \"\" )) elif i == 2 or \"step\" in arg : args [ \"step\" ] = float ( arg . replace ( \"step=\" , \"\" )) if args [ \"start\" ] . is_integer () and args [ \"stop\" ] . is_integer () and args [ \"step\" ] . is_integer (): # int case converted = list ( range ( int ( args [ \"start\" ]), int ( args [ \"stop\" ]), int ( args [ \"step\" ]))) if ( args [ \"stop\" ] - args [ \"start\" ]) % args [ \"step\" ] == 0 : converted . append ( int ( args [ \"stop\" ])) else : # float case def get_num_decimal_places ( n : float ) -> int : ctx = decimal . Context () d = ctx . create_decimal ( repr ( n )) return len ( format ( d , \"f\" ) . split ( \".\" )[ 1 ]) m = max ( get_num_decimal_places ( args [ \"start\" ]), get_num_decimal_places ( args [ \"stop\" ]), get_num_decimal_places ( args [ \"step\" ]), ) converted = [ round ( n , m ) for n in np . arange ( ** args )] # type: ignore if (( args [ \"stop\" ] * ( 10 ** m )) - ( args [ \"start\" ]) * ( 10 ** m )) % ( args [ \"step\" ] * ( 10 ** m ) ) < 10 **- 10 : converted . append ( args [ \"stop\" ]) # type: ignore return converted def _search_combo_and_format_tuple ( self , param_dict : dict ) -> None : for k , v in param_dict . items (): if \"Combination\" in v . keys (): self . _combo_params . append ( k ) if isinstance ( v [ \"Combination\" ], str ): v [ \"Combination\" ] = self . _convert_tuple_to_list ( v [ \"Combination\" ]) # format self . _combo_values . append ( v [ \"Combination\" ]) else : self . _search_combo_and_format_tuple ( v ) get_combo_iter () # Get iterator for combinations. Yields: Type Description Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. Source code in src/config/combo_generator.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def get_combo_iter ( self ) -> Generator : \"\"\"Get iterator for combinations. Yields ------ Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v setattr ( combo_config , Util . convert_to_property ( k ), { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config ) get_num_combos () # Get number of combinations. Returns: Type Description int Number of combinations. Source code in src/config/combo_generator.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos config # Config # Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. To obtain the value of 'Additional properties', it is necessary to call a function, not a property. Notes # If the structure of the configuration file changes, this class must be reprogrammed. Source code in src/config/config.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 class Config : \"\"\"Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. To obtain the value of 'Additional properties', it is necessary to call a function, not a property. Notes ----- If the structure of the configuration file changes, this class must be reprogrammed. \"\"\" def __init__ ( self , config_raw : dict ) -> None : self . _seed = config_raw [ \"Seed\" ] self . _number_of_dags = config_raw [ \"Number of DAGs\" ] self . _graph_structure = config_raw [ \"Graph structure\" ] self . _properties = config_raw [ \"Properties\" ] self . _additional_properties : Optional [ AdditionalProperties ] if config_raw [ \"Properties\" ] . get ( \"Additional properties\" ): self . _additional_properties = AdditionalProperties ( config_raw [ \"Properties\" ][ \"Additional properties\" ] ) del config_raw [ \"Properties\" ][ \"Additional properties\" ] else : self . _additional_properties = None self . _output_formats = config_raw [ \"Output formats\" ] # def is_additional(self, param_name: str) -> bool: # if self._additional_properties is None: # return False # additional_property_names = self._additional_properties.get_property_names() # if param_name in additional_property_names: # return True # else: # return False # def get_additional_property(self, property_name: str): # return self._additional_properties.get_value(property_name) # def set_additional_property(self, property_name: str, value) -> None: # self._additional_properties.set_value(property_name, value) def set_random_seed ( self ) -> None : random . seed ( self . seed ) def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . _graph_structure ) self . _remove_random_fixed ( self . _properties ) if self . _additional_properties : self . _additional_properties = AdditionalProperties ( self . _properties [ \"Additional properties\" ] ) @staticmethod def _remove_random_fixed ( param_dict : dict ) -> None : for k , v in param_dict . items (): if set ( v . keys ()) <= { \"Random\" , \"Fixed\" }: # Remove value = list ( v . values ()) assert len ( value ) == 1 param_dict [ k ] = value [ 0 ] break else : Config . _remove_random_fixed ( v ) @property def seed ( self ) -> int : return self . _seed @property def number_of_dags ( self ) -> int : return self . _number_of_dags # ----- Graph Structure ----- @property def generation_method ( self ): return self . _graph_structure . get ( \"Generation method\" ) @property def number_of_nodes ( self ): return self . _graph_structure . get ( \"Number of nodes\" ) @number_of_nodes . setter def number_of_nodes ( self , value ): self . _graph_structure [ \"Number of nodes\" ] = value @property def ensure_weakly_connected ( self ): return self . _graph_structure . get ( \"Ensure weakly connected\" ) @property def out_degree ( self ): return self . _graph_structure . get ( \"Out-degree\" ) @out_degree . setter def out_degree ( self , value ): self . _graph_structure [ \"Out-degree\" ] = value @property def in_degree ( self ): return self . _graph_structure . get ( \"In-degree\" ) @in_degree . setter def in_degree ( self , value ): self . _graph_structure [ \"In-degree\" ] = value @property def probability_of_edge ( self ): return self . _graph_structure . get ( \"Probability of edge\" ) @probability_of_edge . setter def probability_of_edge ( self , value ): self . _graph_structure [ \"Probability of edge\" ] = value @property def number_of_chains ( self ): return self . _graph_structure . get ( \"Number of chains\" ) @number_of_chains . setter def number_of_chains ( self , value ): self . _graph_structure [ \"Number of chains\" ] = value @property def main_sequence_length ( self ): return self . _graph_structure . get ( \"Main sequence length\" ) @main_sequence_length . setter def main_sequence_length ( self , value ): self . _graph_structure [ \"Main sequence length\" ] = value @property def number_of_sub_sequences ( self ): return self . _graph_structure . get ( \"Number of sub sequences\" ) @number_of_sub_sequences . setter def number_of_sub_sequences ( self , value ): self . _graph_structure [ \"Number of sub sequences\" ] = value @property def vertically_link_chains ( self ): return self . _graph_structure . get ( \"Vertically link chains\" ) @property def main_sequence_tail ( self ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Main sequence tail\" ) @main_sequence_tail . setter def main_sequence_tail ( self , value ): self . _graph_structure [ \"Vertically link chains\" ][ \"Main sequence tail\" ] = value @property def sub_sequence_tail ( self ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Sub sequence tail\" ) @sub_sequence_tail . setter def sub_sequence_tail ( self , value ): self . _graph_structure [ \"Vertically link chains\" ][ \"Sub sequence tail\" ] = value @property def number_of_entry_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Number of entry nodes\" ) else : return self . _graph_structure . get ( \"Number of entry nodes\" ) @number_of_entry_nodes . setter def number_of_entry_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . _graph_structure [ \"Vertically link chains\" ][ \"Number of entry nodes\" ] = value else : self . _graph_structure [ \"Number of entry nodes\" ] = value @property def merge_chains ( self ): return self . _graph_structure . get ( \"Merge chains\" ) @property def middle_of_chain ( self ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Middle of chain\" ) @middle_of_chain . setter def middle_of_chain ( self , value ): self . _graph_structure [ \"Merge chains\" ][ \"Middle of chain\" ] = value @property def exit_node ( self ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Exit node\" ) @exit_node . setter def exit_node ( self , value ): self . _graph_structure [ \"Merge chains\" ][ \"Exit node\" ] = value @property def number_of_exit_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Number of exit nodes\" ) else : return self . _graph_structure . get ( \"Number of exit nodes\" ) @number_of_exit_nodes . setter def number_of_exit_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . _graph_structure [ \"Merge chains\" ][ \"Number of exit nodes\" ] = value else : self . _graph_structure [ \"Number of exit nodes\" ] = value # ----- Properties ----- @property def execution_time ( self ): return self . _properties . get ( \"Execution time\" ) @execution_time . setter def execution_time ( self , value ): self . _properties [ \"Execution time\" ] = value @property def communication_time ( self ): return self . _properties . get ( \"Communication time\" ) @communication_time . setter def communication_time ( self , value ): self . _properties [ \"Communication time\" ] = value @property def ccr ( self ): return self . _properties . get ( \"CCR\" ) @ccr . setter def ccr ( self , value ): self . _properties [ \"CCR\" ] = value @property def end_to_end_deadline ( self ): return self . _properties . get ( \"End-to-end deadline\" ) @property def ratio_of_deadline_to_critical_path ( self ): return self . _properties [ \"End-to-end deadline\" ] . get ( \"Ratio of deadline to critical path\" ) @ratio_of_deadline_to_critical_path . setter def ratio_of_deadline_to_critical_path ( self , value ): self . _properties [ \"End-to-end deadline\" ][ \"Ratio of deadline to critical path\" ] = value @property def multi_rate ( self ): return self . _properties . get ( \"Multi-rate\" ) @property def periodic_type ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Periodic type\" ) @periodic_type . setter def periodic_type ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Periodic type\" ] = value @property def period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Period\" ) @period . setter def period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Period\" ] = value @property def entry_node_period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Entry node period\" ) @entry_node_period . setter def entry_node_period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Entry node period\" ] = value @property def exit_node_period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Exit node period\" ) @exit_node_period . setter def exit_node_period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Exit node period\" ] = value @property def offset ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Offset\" ) @offset . setter def offset ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Offset\" ] = value @property def total_utilization ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Total utilization\" ) @total_utilization . setter def total_utilization ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Total utilization\" ] = value @property def maximum_utilization ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Maximum utilization\" ) @maximum_utilization . setter def maximum_utilization ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Maximum utilization\" ] = value # ----- Output formats ----- @property def naming_of_combination_directory ( self ): return self . _output_formats . get ( \"Naming of combination directory\" ) @property def yaml ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"YAML\" ) @property def json ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"JSON\" ) @property def xml ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"XML\" ) @property def dot ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"DOT\" ) @property def draw_legend ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"Draw legend\" ) @property def png ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"PNG\" ) @property def svg ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"SVG\" ) @property def eps ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"EPS\" ) @property def pdf ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"PDF\" ) optimize () # Remove 'Random' and 'Fixed' Source code in src/config/config.py 76 77 78 79 80 81 82 83 def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . _graph_structure ) self . _remove_random_fixed ( self . _properties ) if self . _additional_properties : self . _additional_properties = AdditionalProperties ( self . _properties [ \"Additional properties\" ] )","title":"config"},{"location":"config/#src.config.ComboGenerator","text":"ComboGenerator class. Source code in src/config/combo_generator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class ComboGenerator : \"\"\"ComboGenerator class.\"\"\" def __init__ ( self , config_raw : dict ) -> None : self . _combo_params : List [ str ] = [] self . _combo_values : List [ Union [ List [ int ], List [ float ]]] = [] self . _search_combo_and_format_tuple ( config_raw [ \"Graph structure\" ]) self . _search_combo_and_format_tuple ( config_raw [ \"Properties\" ]) self . _config = Config ( config_raw ) def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos def get_combo_iter ( self ) -> Generator : \"\"\"Get iterator for combinations. Yields ------ Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v setattr ( combo_config , Util . convert_to_property ( k ), { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config ) def _create_combo_dir_name ( self , combo : Tuple [ Union [ int , float ]], index : int , ) -> str : combo_dir_name : str = \"\" naming = self . _config . naming_of_combination_directory if Util . ambiguous_equals ( naming , \"Full spell\" ): for param , value in zip ( self . _combo_params , combo ): param_str_list = param . split ( \" \" ) param_str_list = [ s . capitalize () for s in param_str_list ] if combo_dir_name : combo_dir_name += f '_ { \"\" . join ( param_str_list ) } _ { value } ' else : combo_dir_name = f ' { \"\" . join ( param_str_list ) } _ { value } ' elif Util . ambiguous_equals ( naming , \"Abbreviation\" ): for param , value in zip ( self . _combo_params , combo ): try : param = TO_ABB [ param . lower ()] except KeyError : # Additional parameter param = param if combo_dir_name : combo_dir_name += f \"_ { param } _ { value } \" else : combo_dir_name = f \" { param } _ { value } \" elif Util . ambiguous_equals ( naming , \"Index of combination\" ): combo_dir_name = f \"Combination_ { index + 1 } \" else : raise NotImplementedError return combo_dir_name @staticmethod def _convert_tuple_to_list ( tuple_str : str ) -> Union [ List [ int ], List [ float ]]: tuple_str = tuple_str . replace ( \"(\" , \"\" ) tuple_str = tuple_str . replace ( \")\" , \"\" ) tuple_str = tuple_str . replace ( \" \" , \"\" ) args : Dict [ str , float ] = {} for i , arg in enumerate ( tuple_str . split ( \",\" )): if i == 0 or \"start\" in arg : args [ \"start\" ] = float ( arg . replace ( \"start=\" , \"\" )) elif i == 1 or \"stop\" in arg : args [ \"stop\" ] = float ( arg . replace ( \"stop=\" , \"\" )) elif i == 2 or \"step\" in arg : args [ \"step\" ] = float ( arg . replace ( \"step=\" , \"\" )) if args [ \"start\" ] . is_integer () and args [ \"stop\" ] . is_integer () and args [ \"step\" ] . is_integer (): # int case converted = list ( range ( int ( args [ \"start\" ]), int ( args [ \"stop\" ]), int ( args [ \"step\" ]))) if ( args [ \"stop\" ] - args [ \"start\" ]) % args [ \"step\" ] == 0 : converted . append ( int ( args [ \"stop\" ])) else : # float case def get_num_decimal_places ( n : float ) -> int : ctx = decimal . Context () d = ctx . create_decimal ( repr ( n )) return len ( format ( d , \"f\" ) . split ( \".\" )[ 1 ]) m = max ( get_num_decimal_places ( args [ \"start\" ]), get_num_decimal_places ( args [ \"stop\" ]), get_num_decimal_places ( args [ \"step\" ]), ) converted = [ round ( n , m ) for n in np . arange ( ** args )] # type: ignore if (( args [ \"stop\" ] * ( 10 ** m )) - ( args [ \"start\" ]) * ( 10 ** m )) % ( args [ \"step\" ] * ( 10 ** m ) ) < 10 **- 10 : converted . append ( args [ \"stop\" ]) # type: ignore return converted def _search_combo_and_format_tuple ( self , param_dict : dict ) -> None : for k , v in param_dict . items (): if \"Combination\" in v . keys (): self . _combo_params . append ( k ) if isinstance ( v [ \"Combination\" ], str ): v [ \"Combination\" ] = self . _convert_tuple_to_list ( v [ \"Combination\" ]) # format self . _combo_values . append ( v [ \"Combination\" ]) else : self . _search_combo_and_format_tuple ( v )","title":"ComboGenerator"},{"location":"config/#src.config.combo_generator.ComboGenerator.get_combo_iter","text":"Get iterator for combinations. Yields: Type Description Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. Source code in src/config/combo_generator.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def get_combo_iter ( self ) -> Generator : \"\"\"Get iterator for combinations. Yields ------ Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v setattr ( combo_config , Util . convert_to_property ( k ), { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config )","title":"get_combo_iter()"},{"location":"config/#src.config.combo_generator.ComboGenerator.get_num_combos","text":"Get number of combinations. Returns: Type Description int Number of combinations. Source code in src/config/combo_generator.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos","title":"get_num_combos()"},{"location":"config/#src.config.Config","text":"Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. To obtain the value of 'Additional properties', it is necessary to call a function, not a property.","title":"Config"},{"location":"config/#src.config.Config--notes","text":"If the structure of the configuration file changes, this class must be reprogrammed. Source code in src/config/config.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 class Config : \"\"\"Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. To obtain the value of 'Additional properties', it is necessary to call a function, not a property. Notes ----- If the structure of the configuration file changes, this class must be reprogrammed. \"\"\" def __init__ ( self , config_raw : dict ) -> None : self . _seed = config_raw [ \"Seed\" ] self . _number_of_dags = config_raw [ \"Number of DAGs\" ] self . _graph_structure = config_raw [ \"Graph structure\" ] self . _properties = config_raw [ \"Properties\" ] self . _additional_properties : Optional [ AdditionalProperties ] if config_raw [ \"Properties\" ] . get ( \"Additional properties\" ): self . _additional_properties = AdditionalProperties ( config_raw [ \"Properties\" ][ \"Additional properties\" ] ) del config_raw [ \"Properties\" ][ \"Additional properties\" ] else : self . _additional_properties = None self . _output_formats = config_raw [ \"Output formats\" ] # def is_additional(self, param_name: str) -> bool: # if self._additional_properties is None: # return False # additional_property_names = self._additional_properties.get_property_names() # if param_name in additional_property_names: # return True # else: # return False # def get_additional_property(self, property_name: str): # return self._additional_properties.get_value(property_name) # def set_additional_property(self, property_name: str, value) -> None: # self._additional_properties.set_value(property_name, value) def set_random_seed ( self ) -> None : random . seed ( self . seed ) def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . _graph_structure ) self . _remove_random_fixed ( self . _properties ) if self . _additional_properties : self . _additional_properties = AdditionalProperties ( self . _properties [ \"Additional properties\" ] ) @staticmethod def _remove_random_fixed ( param_dict : dict ) -> None : for k , v in param_dict . items (): if set ( v . keys ()) <= { \"Random\" , \"Fixed\" }: # Remove value = list ( v . values ()) assert len ( value ) == 1 param_dict [ k ] = value [ 0 ] break else : Config . _remove_random_fixed ( v ) @property def seed ( self ) -> int : return self . _seed @property def number_of_dags ( self ) -> int : return self . _number_of_dags # ----- Graph Structure ----- @property def generation_method ( self ): return self . _graph_structure . get ( \"Generation method\" ) @property def number_of_nodes ( self ): return self . _graph_structure . get ( \"Number of nodes\" ) @number_of_nodes . setter def number_of_nodes ( self , value ): self . _graph_structure [ \"Number of nodes\" ] = value @property def ensure_weakly_connected ( self ): return self . _graph_structure . get ( \"Ensure weakly connected\" ) @property def out_degree ( self ): return self . _graph_structure . get ( \"Out-degree\" ) @out_degree . setter def out_degree ( self , value ): self . _graph_structure [ \"Out-degree\" ] = value @property def in_degree ( self ): return self . _graph_structure . get ( \"In-degree\" ) @in_degree . setter def in_degree ( self , value ): self . _graph_structure [ \"In-degree\" ] = value @property def probability_of_edge ( self ): return self . _graph_structure . get ( \"Probability of edge\" ) @probability_of_edge . setter def probability_of_edge ( self , value ): self . _graph_structure [ \"Probability of edge\" ] = value @property def number_of_chains ( self ): return self . _graph_structure . get ( \"Number of chains\" ) @number_of_chains . setter def number_of_chains ( self , value ): self . _graph_structure [ \"Number of chains\" ] = value @property def main_sequence_length ( self ): return self . _graph_structure . get ( \"Main sequence length\" ) @main_sequence_length . setter def main_sequence_length ( self , value ): self . _graph_structure [ \"Main sequence length\" ] = value @property def number_of_sub_sequences ( self ): return self . _graph_structure . get ( \"Number of sub sequences\" ) @number_of_sub_sequences . setter def number_of_sub_sequences ( self , value ): self . _graph_structure [ \"Number of sub sequences\" ] = value @property def vertically_link_chains ( self ): return self . _graph_structure . get ( \"Vertically link chains\" ) @property def main_sequence_tail ( self ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Main sequence tail\" ) @main_sequence_tail . setter def main_sequence_tail ( self , value ): self . _graph_structure [ \"Vertically link chains\" ][ \"Main sequence tail\" ] = value @property def sub_sequence_tail ( self ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Sub sequence tail\" ) @sub_sequence_tail . setter def sub_sequence_tail ( self , value ): self . _graph_structure [ \"Vertically link chains\" ][ \"Sub sequence tail\" ] = value @property def number_of_entry_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Number of entry nodes\" ) else : return self . _graph_structure . get ( \"Number of entry nodes\" ) @number_of_entry_nodes . setter def number_of_entry_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . _graph_structure [ \"Vertically link chains\" ][ \"Number of entry nodes\" ] = value else : self . _graph_structure [ \"Number of entry nodes\" ] = value @property def merge_chains ( self ): return self . _graph_structure . get ( \"Merge chains\" ) @property def middle_of_chain ( self ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Middle of chain\" ) @middle_of_chain . setter def middle_of_chain ( self , value ): self . _graph_structure [ \"Merge chains\" ][ \"Middle of chain\" ] = value @property def exit_node ( self ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Exit node\" ) @exit_node . setter def exit_node ( self , value ): self . _graph_structure [ \"Merge chains\" ][ \"Exit node\" ] = value @property def number_of_exit_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Number of exit nodes\" ) else : return self . _graph_structure . get ( \"Number of exit nodes\" ) @number_of_exit_nodes . setter def number_of_exit_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . _graph_structure [ \"Merge chains\" ][ \"Number of exit nodes\" ] = value else : self . _graph_structure [ \"Number of exit nodes\" ] = value # ----- Properties ----- @property def execution_time ( self ): return self . _properties . get ( \"Execution time\" ) @execution_time . setter def execution_time ( self , value ): self . _properties [ \"Execution time\" ] = value @property def communication_time ( self ): return self . _properties . get ( \"Communication time\" ) @communication_time . setter def communication_time ( self , value ): self . _properties [ \"Communication time\" ] = value @property def ccr ( self ): return self . _properties . get ( \"CCR\" ) @ccr . setter def ccr ( self , value ): self . _properties [ \"CCR\" ] = value @property def end_to_end_deadline ( self ): return self . _properties . get ( \"End-to-end deadline\" ) @property def ratio_of_deadline_to_critical_path ( self ): return self . _properties [ \"End-to-end deadline\" ] . get ( \"Ratio of deadline to critical path\" ) @ratio_of_deadline_to_critical_path . setter def ratio_of_deadline_to_critical_path ( self , value ): self . _properties [ \"End-to-end deadline\" ][ \"Ratio of deadline to critical path\" ] = value @property def multi_rate ( self ): return self . _properties . get ( \"Multi-rate\" ) @property def periodic_type ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Periodic type\" ) @periodic_type . setter def periodic_type ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Periodic type\" ] = value @property def period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Period\" ) @period . setter def period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Period\" ] = value @property def entry_node_period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Entry node period\" ) @entry_node_period . setter def entry_node_period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Entry node period\" ] = value @property def exit_node_period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Exit node period\" ) @exit_node_period . setter def exit_node_period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Exit node period\" ] = value @property def offset ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Offset\" ) @offset . setter def offset ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Offset\" ] = value @property def total_utilization ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Total utilization\" ) @total_utilization . setter def total_utilization ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Total utilization\" ] = value @property def maximum_utilization ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Maximum utilization\" ) @maximum_utilization . setter def maximum_utilization ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Maximum utilization\" ] = value # ----- Output formats ----- @property def naming_of_combination_directory ( self ): return self . _output_formats . get ( \"Naming of combination directory\" ) @property def yaml ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"YAML\" ) @property def json ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"JSON\" ) @property def xml ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"XML\" ) @property def dot ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"DOT\" ) @property def draw_legend ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"Draw legend\" ) @property def png ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"PNG\" ) @property def svg ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"SVG\" ) @property def eps ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"EPS\" ) @property def pdf ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"PDF\" )","title":"Notes"},{"location":"config/#src.config.config.Config.optimize","text":"Remove 'Random' and 'Fixed' Source code in src/config/config.py 76 77 78 79 80 81 82 83 def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . _graph_structure ) self . _remove_random_fixed ( self . _properties ) if self . _additional_properties : self . _additional_properties = AdditionalProperties ( self . _properties [ \"Additional properties\" ] )","title":"optimize()"},{"location":"config/#src.config.combo_generator","text":"","title":"combo_generator"},{"location":"config/#src.config.combo_generator.ComboGenerator","text":"ComboGenerator class. Source code in src/config/combo_generator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class ComboGenerator : \"\"\"ComboGenerator class.\"\"\" def __init__ ( self , config_raw : dict ) -> None : self . _combo_params : List [ str ] = [] self . _combo_values : List [ Union [ List [ int ], List [ float ]]] = [] self . _search_combo_and_format_tuple ( config_raw [ \"Graph structure\" ]) self . _search_combo_and_format_tuple ( config_raw [ \"Properties\" ]) self . _config = Config ( config_raw ) def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos def get_combo_iter ( self ) -> Generator : \"\"\"Get iterator for combinations. Yields ------ Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v setattr ( combo_config , Util . convert_to_property ( k ), { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config ) def _create_combo_dir_name ( self , combo : Tuple [ Union [ int , float ]], index : int , ) -> str : combo_dir_name : str = \"\" naming = self . _config . naming_of_combination_directory if Util . ambiguous_equals ( naming , \"Full spell\" ): for param , value in zip ( self . _combo_params , combo ): param_str_list = param . split ( \" \" ) param_str_list = [ s . capitalize () for s in param_str_list ] if combo_dir_name : combo_dir_name += f '_ { \"\" . join ( param_str_list ) } _ { value } ' else : combo_dir_name = f ' { \"\" . join ( param_str_list ) } _ { value } ' elif Util . ambiguous_equals ( naming , \"Abbreviation\" ): for param , value in zip ( self . _combo_params , combo ): try : param = TO_ABB [ param . lower ()] except KeyError : # Additional parameter param = param if combo_dir_name : combo_dir_name += f \"_ { param } _ { value } \" else : combo_dir_name = f \" { param } _ { value } \" elif Util . ambiguous_equals ( naming , \"Index of combination\" ): combo_dir_name = f \"Combination_ { index + 1 } \" else : raise NotImplementedError return combo_dir_name @staticmethod def _convert_tuple_to_list ( tuple_str : str ) -> Union [ List [ int ], List [ float ]]: tuple_str = tuple_str . replace ( \"(\" , \"\" ) tuple_str = tuple_str . replace ( \")\" , \"\" ) tuple_str = tuple_str . replace ( \" \" , \"\" ) args : Dict [ str , float ] = {} for i , arg in enumerate ( tuple_str . split ( \",\" )): if i == 0 or \"start\" in arg : args [ \"start\" ] = float ( arg . replace ( \"start=\" , \"\" )) elif i == 1 or \"stop\" in arg : args [ \"stop\" ] = float ( arg . replace ( \"stop=\" , \"\" )) elif i == 2 or \"step\" in arg : args [ \"step\" ] = float ( arg . replace ( \"step=\" , \"\" )) if args [ \"start\" ] . is_integer () and args [ \"stop\" ] . is_integer () and args [ \"step\" ] . is_integer (): # int case converted = list ( range ( int ( args [ \"start\" ]), int ( args [ \"stop\" ]), int ( args [ \"step\" ]))) if ( args [ \"stop\" ] - args [ \"start\" ]) % args [ \"step\" ] == 0 : converted . append ( int ( args [ \"stop\" ])) else : # float case def get_num_decimal_places ( n : float ) -> int : ctx = decimal . Context () d = ctx . create_decimal ( repr ( n )) return len ( format ( d , \"f\" ) . split ( \".\" )[ 1 ]) m = max ( get_num_decimal_places ( args [ \"start\" ]), get_num_decimal_places ( args [ \"stop\" ]), get_num_decimal_places ( args [ \"step\" ]), ) converted = [ round ( n , m ) for n in np . arange ( ** args )] # type: ignore if (( args [ \"stop\" ] * ( 10 ** m )) - ( args [ \"start\" ]) * ( 10 ** m )) % ( args [ \"step\" ] * ( 10 ** m ) ) < 10 **- 10 : converted . append ( args [ \"stop\" ]) # type: ignore return converted def _search_combo_and_format_tuple ( self , param_dict : dict ) -> None : for k , v in param_dict . items (): if \"Combination\" in v . keys (): self . _combo_params . append ( k ) if isinstance ( v [ \"Combination\" ], str ): v [ \"Combination\" ] = self . _convert_tuple_to_list ( v [ \"Combination\" ]) # format self . _combo_values . append ( v [ \"Combination\" ]) else : self . _search_combo_and_format_tuple ( v )","title":"ComboGenerator"},{"location":"config/#src.config.combo_generator.ComboGenerator.get_combo_iter","text":"Get iterator for combinations. Yields: Type Description Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. Source code in src/config/combo_generator.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def get_combo_iter ( self ) -> Generator : \"\"\"Get iterator for combinations. Yields ------ Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v setattr ( combo_config , Util . convert_to_property ( k ), { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config )","title":"get_combo_iter()"},{"location":"config/#src.config.combo_generator.ComboGenerator.get_num_combos","text":"Get number of combinations. Returns: Type Description int Number of combinations. Source code in src/config/combo_generator.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos","title":"get_num_combos()"},{"location":"config/#src.config.config","text":"","title":"config"},{"location":"config/#src.config.config.Config","text":"Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. To obtain the value of 'Additional properties', it is necessary to call a function, not a property.","title":"Config"},{"location":"config/#src.config.config.Config--notes","text":"If the structure of the configuration file changes, this class must be reprogrammed. Source code in src/config/config.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 class Config : \"\"\"Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. To obtain the value of 'Additional properties', it is necessary to call a function, not a property. Notes ----- If the structure of the configuration file changes, this class must be reprogrammed. \"\"\" def __init__ ( self , config_raw : dict ) -> None : self . _seed = config_raw [ \"Seed\" ] self . _number_of_dags = config_raw [ \"Number of DAGs\" ] self . _graph_structure = config_raw [ \"Graph structure\" ] self . _properties = config_raw [ \"Properties\" ] self . _additional_properties : Optional [ AdditionalProperties ] if config_raw [ \"Properties\" ] . get ( \"Additional properties\" ): self . _additional_properties = AdditionalProperties ( config_raw [ \"Properties\" ][ \"Additional properties\" ] ) del config_raw [ \"Properties\" ][ \"Additional properties\" ] else : self . _additional_properties = None self . _output_formats = config_raw [ \"Output formats\" ] # def is_additional(self, param_name: str) -> bool: # if self._additional_properties is None: # return False # additional_property_names = self._additional_properties.get_property_names() # if param_name in additional_property_names: # return True # else: # return False # def get_additional_property(self, property_name: str): # return self._additional_properties.get_value(property_name) # def set_additional_property(self, property_name: str, value) -> None: # self._additional_properties.set_value(property_name, value) def set_random_seed ( self ) -> None : random . seed ( self . seed ) def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . _graph_structure ) self . _remove_random_fixed ( self . _properties ) if self . _additional_properties : self . _additional_properties = AdditionalProperties ( self . _properties [ \"Additional properties\" ] ) @staticmethod def _remove_random_fixed ( param_dict : dict ) -> None : for k , v in param_dict . items (): if set ( v . keys ()) <= { \"Random\" , \"Fixed\" }: # Remove value = list ( v . values ()) assert len ( value ) == 1 param_dict [ k ] = value [ 0 ] break else : Config . _remove_random_fixed ( v ) @property def seed ( self ) -> int : return self . _seed @property def number_of_dags ( self ) -> int : return self . _number_of_dags # ----- Graph Structure ----- @property def generation_method ( self ): return self . _graph_structure . get ( \"Generation method\" ) @property def number_of_nodes ( self ): return self . _graph_structure . get ( \"Number of nodes\" ) @number_of_nodes . setter def number_of_nodes ( self , value ): self . _graph_structure [ \"Number of nodes\" ] = value @property def ensure_weakly_connected ( self ): return self . _graph_structure . get ( \"Ensure weakly connected\" ) @property def out_degree ( self ): return self . _graph_structure . get ( \"Out-degree\" ) @out_degree . setter def out_degree ( self , value ): self . _graph_structure [ \"Out-degree\" ] = value @property def in_degree ( self ): return self . _graph_structure . get ( \"In-degree\" ) @in_degree . setter def in_degree ( self , value ): self . _graph_structure [ \"In-degree\" ] = value @property def probability_of_edge ( self ): return self . _graph_structure . get ( \"Probability of edge\" ) @probability_of_edge . setter def probability_of_edge ( self , value ): self . _graph_structure [ \"Probability of edge\" ] = value @property def number_of_chains ( self ): return self . _graph_structure . get ( \"Number of chains\" ) @number_of_chains . setter def number_of_chains ( self , value ): self . _graph_structure [ \"Number of chains\" ] = value @property def main_sequence_length ( self ): return self . _graph_structure . get ( \"Main sequence length\" ) @main_sequence_length . setter def main_sequence_length ( self , value ): self . _graph_structure [ \"Main sequence length\" ] = value @property def number_of_sub_sequences ( self ): return self . _graph_structure . get ( \"Number of sub sequences\" ) @number_of_sub_sequences . setter def number_of_sub_sequences ( self , value ): self . _graph_structure [ \"Number of sub sequences\" ] = value @property def vertically_link_chains ( self ): return self . _graph_structure . get ( \"Vertically link chains\" ) @property def main_sequence_tail ( self ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Main sequence tail\" ) @main_sequence_tail . setter def main_sequence_tail ( self , value ): self . _graph_structure [ \"Vertically link chains\" ][ \"Main sequence tail\" ] = value @property def sub_sequence_tail ( self ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Sub sequence tail\" ) @sub_sequence_tail . setter def sub_sequence_tail ( self , value ): self . _graph_structure [ \"Vertically link chains\" ][ \"Sub sequence tail\" ] = value @property def number_of_entry_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Number of entry nodes\" ) else : return self . _graph_structure . get ( \"Number of entry nodes\" ) @number_of_entry_nodes . setter def number_of_entry_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . _graph_structure [ \"Vertically link chains\" ][ \"Number of entry nodes\" ] = value else : self . _graph_structure [ \"Number of entry nodes\" ] = value @property def merge_chains ( self ): return self . _graph_structure . get ( \"Merge chains\" ) @property def middle_of_chain ( self ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Middle of chain\" ) @middle_of_chain . setter def middle_of_chain ( self , value ): self . _graph_structure [ \"Merge chains\" ][ \"Middle of chain\" ] = value @property def exit_node ( self ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Exit node\" ) @exit_node . setter def exit_node ( self , value ): self . _graph_structure [ \"Merge chains\" ][ \"Exit node\" ] = value @property def number_of_exit_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Number of exit nodes\" ) else : return self . _graph_structure . get ( \"Number of exit nodes\" ) @number_of_exit_nodes . setter def number_of_exit_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . _graph_structure [ \"Merge chains\" ][ \"Number of exit nodes\" ] = value else : self . _graph_structure [ \"Number of exit nodes\" ] = value # ----- Properties ----- @property def execution_time ( self ): return self . _properties . get ( \"Execution time\" ) @execution_time . setter def execution_time ( self , value ): self . _properties [ \"Execution time\" ] = value @property def communication_time ( self ): return self . _properties . get ( \"Communication time\" ) @communication_time . setter def communication_time ( self , value ): self . _properties [ \"Communication time\" ] = value @property def ccr ( self ): return self . _properties . get ( \"CCR\" ) @ccr . setter def ccr ( self , value ): self . _properties [ \"CCR\" ] = value @property def end_to_end_deadline ( self ): return self . _properties . get ( \"End-to-end deadline\" ) @property def ratio_of_deadline_to_critical_path ( self ): return self . _properties [ \"End-to-end deadline\" ] . get ( \"Ratio of deadline to critical path\" ) @ratio_of_deadline_to_critical_path . setter def ratio_of_deadline_to_critical_path ( self , value ): self . _properties [ \"End-to-end deadline\" ][ \"Ratio of deadline to critical path\" ] = value @property def multi_rate ( self ): return self . _properties . get ( \"Multi-rate\" ) @property def periodic_type ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Periodic type\" ) @periodic_type . setter def periodic_type ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Periodic type\" ] = value @property def period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Period\" ) @period . setter def period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Period\" ] = value @property def entry_node_period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Entry node period\" ) @entry_node_period . setter def entry_node_period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Entry node period\" ] = value @property def exit_node_period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Exit node period\" ) @exit_node_period . setter def exit_node_period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Exit node period\" ] = value @property def offset ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Offset\" ) @offset . setter def offset ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Offset\" ] = value @property def total_utilization ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Total utilization\" ) @total_utilization . setter def total_utilization ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Total utilization\" ] = value @property def maximum_utilization ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Maximum utilization\" ) @maximum_utilization . setter def maximum_utilization ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Maximum utilization\" ] = value # ----- Output formats ----- @property def naming_of_combination_directory ( self ): return self . _output_formats . get ( \"Naming of combination directory\" ) @property def yaml ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"YAML\" ) @property def json ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"JSON\" ) @property def xml ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"XML\" ) @property def dot ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"DOT\" ) @property def draw_legend ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"Draw legend\" ) @property def png ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"PNG\" ) @property def svg ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"SVG\" ) @property def eps ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"EPS\" ) @property def pdf ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"PDF\" )","title":"Notes"},{"location":"config/#src.config.config.Config.optimize","text":"Remove 'Random' and 'Fixed' Source code in src/config/config.py 76 77 78 79 80 81 82 83 def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . _graph_structure ) self . _remove_random_fixed ( self . _properties ) if self . _additional_properties : self . _additional_properties = AdditionalProperties ( self . _properties [ \"Additional properties\" ] )","title":"optimize()"},{"location":"dag_builder/","text":"DAGBuilderFactory # DAG builder factory class. Source code in src/dag_builder/dag_builder_factory.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class DAGBuilderFactory : \"\"\"DAG builder factory class.\"\"\" @staticmethod def create_instance ( config : Config ) -> DAGBuilderBase : generation_method = config . generation_method if Util . ambiguous_equals ( generation_method , \"fan-in/fan-out\" ): return FanInFanOut ( config ) elif Util . ambiguous_equals ( generation_method , \"g(n, p)\" ): return GNP ( config ) elif Util . ambiguous_equals ( generation_method , \"chain-based\" ): return ChainBased ( config ) else : raise NotImplementedError dag_builder_base # DAGBuilderBase # DAG builder base class. Source code in src/dag_builder/dag_builder_base.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class DAGBuilderBase ( metaclass = ABCMeta ): \"\"\"DAG builder base class.\"\"\" def __init__ ( self , config : Config , max_try : int = 100 ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. max_try : int, optional Maximum number of DAG build attempts with the same parameters, by default 100 \"\"\" self . validate_config ( config ) self . _config = config self . _max_try = max_try @abstractmethod def build ( self ) -> Generator [ nx . DiGraph , None , None ]: raise NotImplementedError @abstractmethod def validate_config ( self , config : Config ): raise NotImplementedError @staticmethod def _add_minimum_edges ( src_layer : List [ int ], tgt_layer : List [ int ], G : nx . DiGraph ) -> None : \"\"\"Add minimum edges Connects the source and target layers with a minimum number of edges. The function terminates when the out-degree of the source layer is greater than or equal to 1 and the in-degree of the target layer is greater than or equal to 1. Parameters ---------- src_layer : List[int] Indices of nodes that are the source of the edge. tgt_layer : List[int] Indices of nodes that are the target of the edge. G : nx.DiGraph DAG. \"\"\" def is_finish () -> bool : for src_node_i in src_layer : if G . out_degree ( src_node_i ) == 0 : return False for tgt_node_i in tgt_layer : if G . in_degree ( tgt_node_i ) == 0 : return False return True while not is_finish (): min_out_src_i = Util . get_min_out_node ( G , src_layer ) min_in_tgt_i = Util . get_min_in_node ( G , tgt_layer ) G . add_edge ( min_out_src_i , min_in_tgt_i ) @staticmethod def _ensure_weakly_connected ( G : nx . DiGraph ) -> None : \"\"\"Ensure weakly connected. Connect the separated DAGs into one, without changing the number of entry and exit nodes. Parameters ---------- G : nx.DiGraph DAG. \"\"\" comps = list ( nx . weakly_connected_components ( G )) if len ( comps ) == 1 : return None comps . sort ( key = lambda x : len ( x )) tgt_comp = comps . pop ( - 1 ) # Most big component entry_nodes = set ( Util . get_entry_nodes ( G )) exit_nodes = set ( Util . get_exit_nodes ( G )) for src_comp in comps : src_option = src_comp - exit_nodes tgt_option = tgt_comp - entry_nodes src_i = Util . get_min_out_node ( G , src_option ) tgt_i = Util . get_min_in_node ( G , tgt_option ) G . add_edge ( src_i , tgt_i ) __init__ ( config , max_try = 100 ) # Constructor. Parameters: Name Type Description Default config Config Config. required max_try int , optional Maximum number of DAG build attempts with the same parameters, by default 100 100 Source code in src/dag_builder/dag_builder_base.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def __init__ ( self , config : Config , max_try : int = 100 ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. max_try : int, optional Maximum number of DAG build attempts with the same parameters, by default 100 \"\"\" self . validate_config ( config ) self . _config = config self . _max_try = max_try dag_builder_factory # DAGBuilderFactory # DAG builder factory class. Source code in src/dag_builder/dag_builder_factory.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class DAGBuilderFactory : \"\"\"DAG builder factory class.\"\"\" @staticmethod def create_instance ( config : Config ) -> DAGBuilderBase : generation_method = config . generation_method if Util . ambiguous_equals ( generation_method , \"fan-in/fan-out\" ): return FanInFanOut ( config ) elif Util . ambiguous_equals ( generation_method , \"g(n, p)\" ): return GNP ( config ) elif Util . ambiguous_equals ( generation_method , \"chain-based\" ): return ChainBased ( config ) else : raise NotImplementedError fan_in_fan_out # FanInFanOut # Bases: DAGBuilderBase Fan-in/fan-out class. Source code in src/dag_builder/fan_in_fan_out.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class FanInFanOut ( DAGBuilderBase ): \"\"\"Fan-in/fan-out class.\"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) self . _max_out = ( max ( self . _config . out_degree ) if isinstance ( self . _config . out_degree , list ) else self . _config . out_degree ) self . _max_in = ( max ( self . _config . in_degree ) if isinstance ( self . _config . in_degree , list ) else self . _config . in_degree ) def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = config . number_of_entry_nodes number_of_exit_nodes = config . number_of_exit_nodes or 0 number_of_nodes = config . number_of_nodes if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" ) def build ( self ) -> Generator : \"\"\"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): num_build_fail = 0 # Determine number_of_nodes (Loop finish condition) num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize dag num_entry = Util . random_choice ( self . _config . number_of_entry_nodes ) G = self . _init_dag ( num_entry ) while G . number_of_nodes () != num_nodes : if Util . true_or_false (): # Fan-out max_diff_node_i , diff = self . _search_max_diff_node ( G ) num_add = random . randint ( 1 , diff ) add_node_i_list = [ G . number_of_nodes () + i for i in range ( num_add )] nx . add_star ( G , [ max_diff_node_i ] + add_node_i_list ) else : # Fan-in num_sources = random . randint ( 1 , self . _max_in ) nodes = list ( G . nodes ()) random . shuffle ( nodes ) sources = [] for node_i in nodes : if G . out_degree ( node_i ) < self . _max_out : sources . append ( node_i ) if len ( sources ) == num_sources : break add_node_i = G . number_of_nodes () G . add_node ( add_node_i ) for source_node_i in sources : G . add_edge ( source_node_i , add_node_i ) # Check build fail if G . number_of_nodes () > num_nodes : num_build_fail += 1 if num_build_fail == self . _max_try : msg = ( \"A DAG satisfying 'Number of nodes' could not be built \" f \"in { self . _max_try } tries.\" ) raise BuildFailedError ( msg ) else : G = self . _init_dag ( num_entry ) # reset # Add exit nodes (Optional) if num_exit : original_exits = Util . get_exit_nodes ( G ) new_exits = [ G . number_of_nodes () + i for i in range ( num_exit )] G . add_nodes_from ( new_exits ) self . _add_minimum_edges ( original_exits , new_exits , G ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : self . _ensure_weakly_connected ( G ) yield G def _search_max_diff_node ( self , G : nx . DiGraph ) -> Tuple [ int , int ]: \"\"\"Search max difference node. Find the node with the biggest difference between its out-degree and max value of 'out-degree' parameter. Returns ------- Tuple[int, int] - Index of node with the biggest difference - Difference size \"\"\" min_out_i = Util . get_min_out_node ( G , G . nodes ) max_diff = self . _max_out - G . out_degree ( min_out_i ) return min_out_i , max_diff def _init_dag ( self , num_entry : int ) -> nx . DiGraph : G = nx . DiGraph () for _ in range ( num_entry ): G . add_node ( G . number_of_nodes ()) return G build () # Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields: Type Description Generator DAG generator. Raises: Type Description BuildFailedError The number of build failures exceeded the maximum number of attempts. Source code in src/dag_builder/fan_in_fan_out.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def build ( self ) -> Generator : \"\"\"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): num_build_fail = 0 # Determine number_of_nodes (Loop finish condition) num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize dag num_entry = Util . random_choice ( self . _config . number_of_entry_nodes ) G = self . _init_dag ( num_entry ) while G . number_of_nodes () != num_nodes : if Util . true_or_false (): # Fan-out max_diff_node_i , diff = self . _search_max_diff_node ( G ) num_add = random . randint ( 1 , diff ) add_node_i_list = [ G . number_of_nodes () + i for i in range ( num_add )] nx . add_star ( G , [ max_diff_node_i ] + add_node_i_list ) else : # Fan-in num_sources = random . randint ( 1 , self . _max_in ) nodes = list ( G . nodes ()) random . shuffle ( nodes ) sources = [] for node_i in nodes : if G . out_degree ( node_i ) < self . _max_out : sources . append ( node_i ) if len ( sources ) == num_sources : break add_node_i = G . number_of_nodes () G . add_node ( add_node_i ) for source_node_i in sources : G . add_edge ( source_node_i , add_node_i ) # Check build fail if G . number_of_nodes () > num_nodes : num_build_fail += 1 if num_build_fail == self . _max_try : msg = ( \"A DAG satisfying 'Number of nodes' could not be built \" f \"in { self . _max_try } tries.\" ) raise BuildFailedError ( msg ) else : G = self . _init_dag ( num_entry ) # reset # Add exit nodes (Optional) if num_exit : original_exits = Util . get_exit_nodes ( G ) new_exits = [ G . number_of_nodes () + i for i in range ( num_exit )] G . add_nodes_from ( new_exits ) self . _add_minimum_edges ( original_exits , new_exits , G ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : self . _ensure_weakly_connected ( G ) yield G validate_config ( config ) # Validate config. Parameters: Name Type Description Default config Config Inputted config. required Raises: Type Description InfeasibleConfigError An infeasible parameter was entered. Source code in src/dag_builder/fan_in_fan_out.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = config . number_of_entry_nodes number_of_exit_nodes = config . number_of_exit_nodes or 0 number_of_nodes = config . number_of_nodes if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" )","title":"dag_builder"},{"location":"dag_builder/#src.dag_builder.DAGBuilderFactory","text":"DAG builder factory class. Source code in src/dag_builder/dag_builder_factory.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class DAGBuilderFactory : \"\"\"DAG builder factory class.\"\"\" @staticmethod def create_instance ( config : Config ) -> DAGBuilderBase : generation_method = config . generation_method if Util . ambiguous_equals ( generation_method , \"fan-in/fan-out\" ): return FanInFanOut ( config ) elif Util . ambiguous_equals ( generation_method , \"g(n, p)\" ): return GNP ( config ) elif Util . ambiguous_equals ( generation_method , \"chain-based\" ): return ChainBased ( config ) else : raise NotImplementedError","title":"DAGBuilderFactory"},{"location":"dag_builder/#src.dag_builder.dag_builder_base","text":"","title":"dag_builder_base"},{"location":"dag_builder/#src.dag_builder.dag_builder_base.DAGBuilderBase","text":"DAG builder base class. Source code in src/dag_builder/dag_builder_base.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class DAGBuilderBase ( metaclass = ABCMeta ): \"\"\"DAG builder base class.\"\"\" def __init__ ( self , config : Config , max_try : int = 100 ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. max_try : int, optional Maximum number of DAG build attempts with the same parameters, by default 100 \"\"\" self . validate_config ( config ) self . _config = config self . _max_try = max_try @abstractmethod def build ( self ) -> Generator [ nx . DiGraph , None , None ]: raise NotImplementedError @abstractmethod def validate_config ( self , config : Config ): raise NotImplementedError @staticmethod def _add_minimum_edges ( src_layer : List [ int ], tgt_layer : List [ int ], G : nx . DiGraph ) -> None : \"\"\"Add minimum edges Connects the source and target layers with a minimum number of edges. The function terminates when the out-degree of the source layer is greater than or equal to 1 and the in-degree of the target layer is greater than or equal to 1. Parameters ---------- src_layer : List[int] Indices of nodes that are the source of the edge. tgt_layer : List[int] Indices of nodes that are the target of the edge. G : nx.DiGraph DAG. \"\"\" def is_finish () -> bool : for src_node_i in src_layer : if G . out_degree ( src_node_i ) == 0 : return False for tgt_node_i in tgt_layer : if G . in_degree ( tgt_node_i ) == 0 : return False return True while not is_finish (): min_out_src_i = Util . get_min_out_node ( G , src_layer ) min_in_tgt_i = Util . get_min_in_node ( G , tgt_layer ) G . add_edge ( min_out_src_i , min_in_tgt_i ) @staticmethod def _ensure_weakly_connected ( G : nx . DiGraph ) -> None : \"\"\"Ensure weakly connected. Connect the separated DAGs into one, without changing the number of entry and exit nodes. Parameters ---------- G : nx.DiGraph DAG. \"\"\" comps = list ( nx . weakly_connected_components ( G )) if len ( comps ) == 1 : return None comps . sort ( key = lambda x : len ( x )) tgt_comp = comps . pop ( - 1 ) # Most big component entry_nodes = set ( Util . get_entry_nodes ( G )) exit_nodes = set ( Util . get_exit_nodes ( G )) for src_comp in comps : src_option = src_comp - exit_nodes tgt_option = tgt_comp - entry_nodes src_i = Util . get_min_out_node ( G , src_option ) tgt_i = Util . get_min_in_node ( G , tgt_option ) G . add_edge ( src_i , tgt_i )","title":"DAGBuilderBase"},{"location":"dag_builder/#src.dag_builder.dag_builder_base.DAGBuilderBase.__init__","text":"Constructor. Parameters: Name Type Description Default config Config Config. required max_try int , optional Maximum number of DAG build attempts with the same parameters, by default 100 100 Source code in src/dag_builder/dag_builder_base.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def __init__ ( self , config : Config , max_try : int = 100 ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. max_try : int, optional Maximum number of DAG build attempts with the same parameters, by default 100 \"\"\" self . validate_config ( config ) self . _config = config self . _max_try = max_try","title":"__init__()"},{"location":"dag_builder/#src.dag_builder.dag_builder_factory","text":"","title":"dag_builder_factory"},{"location":"dag_builder/#src.dag_builder.dag_builder_factory.DAGBuilderFactory","text":"DAG builder factory class. Source code in src/dag_builder/dag_builder_factory.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class DAGBuilderFactory : \"\"\"DAG builder factory class.\"\"\" @staticmethod def create_instance ( config : Config ) -> DAGBuilderBase : generation_method = config . generation_method if Util . ambiguous_equals ( generation_method , \"fan-in/fan-out\" ): return FanInFanOut ( config ) elif Util . ambiguous_equals ( generation_method , \"g(n, p)\" ): return GNP ( config ) elif Util . ambiguous_equals ( generation_method , \"chain-based\" ): return ChainBased ( config ) else : raise NotImplementedError","title":"DAGBuilderFactory"},{"location":"dag_builder/#src.dag_builder.fan_in_fan_out","text":"","title":"fan_in_fan_out"},{"location":"dag_builder/#src.dag_builder.fan_in_fan_out.FanInFanOut","text":"Bases: DAGBuilderBase Fan-in/fan-out class. Source code in src/dag_builder/fan_in_fan_out.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class FanInFanOut ( DAGBuilderBase ): \"\"\"Fan-in/fan-out class.\"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) self . _max_out = ( max ( self . _config . out_degree ) if isinstance ( self . _config . out_degree , list ) else self . _config . out_degree ) self . _max_in = ( max ( self . _config . in_degree ) if isinstance ( self . _config . in_degree , list ) else self . _config . in_degree ) def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = config . number_of_entry_nodes number_of_exit_nodes = config . number_of_exit_nodes or 0 number_of_nodes = config . number_of_nodes if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" ) def build ( self ) -> Generator : \"\"\"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): num_build_fail = 0 # Determine number_of_nodes (Loop finish condition) num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize dag num_entry = Util . random_choice ( self . _config . number_of_entry_nodes ) G = self . _init_dag ( num_entry ) while G . number_of_nodes () != num_nodes : if Util . true_or_false (): # Fan-out max_diff_node_i , diff = self . _search_max_diff_node ( G ) num_add = random . randint ( 1 , diff ) add_node_i_list = [ G . number_of_nodes () + i for i in range ( num_add )] nx . add_star ( G , [ max_diff_node_i ] + add_node_i_list ) else : # Fan-in num_sources = random . randint ( 1 , self . _max_in ) nodes = list ( G . nodes ()) random . shuffle ( nodes ) sources = [] for node_i in nodes : if G . out_degree ( node_i ) < self . _max_out : sources . append ( node_i ) if len ( sources ) == num_sources : break add_node_i = G . number_of_nodes () G . add_node ( add_node_i ) for source_node_i in sources : G . add_edge ( source_node_i , add_node_i ) # Check build fail if G . number_of_nodes () > num_nodes : num_build_fail += 1 if num_build_fail == self . _max_try : msg = ( \"A DAG satisfying 'Number of nodes' could not be built \" f \"in { self . _max_try } tries.\" ) raise BuildFailedError ( msg ) else : G = self . _init_dag ( num_entry ) # reset # Add exit nodes (Optional) if num_exit : original_exits = Util . get_exit_nodes ( G ) new_exits = [ G . number_of_nodes () + i for i in range ( num_exit )] G . add_nodes_from ( new_exits ) self . _add_minimum_edges ( original_exits , new_exits , G ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : self . _ensure_weakly_connected ( G ) yield G def _search_max_diff_node ( self , G : nx . DiGraph ) -> Tuple [ int , int ]: \"\"\"Search max difference node. Find the node with the biggest difference between its out-degree and max value of 'out-degree' parameter. Returns ------- Tuple[int, int] - Index of node with the biggest difference - Difference size \"\"\" min_out_i = Util . get_min_out_node ( G , G . nodes ) max_diff = self . _max_out - G . out_degree ( min_out_i ) return min_out_i , max_diff def _init_dag ( self , num_entry : int ) -> nx . DiGraph : G = nx . DiGraph () for _ in range ( num_entry ): G . add_node ( G . number_of_nodes ()) return G","title":"FanInFanOut"},{"location":"dag_builder/#src.dag_builder.fan_in_fan_out.FanInFanOut.build","text":"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields: Type Description Generator DAG generator. Raises: Type Description BuildFailedError The number of build failures exceeded the maximum number of attempts. Source code in src/dag_builder/fan_in_fan_out.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def build ( self ) -> Generator : \"\"\"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): num_build_fail = 0 # Determine number_of_nodes (Loop finish condition) num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize dag num_entry = Util . random_choice ( self . _config . number_of_entry_nodes ) G = self . _init_dag ( num_entry ) while G . number_of_nodes () != num_nodes : if Util . true_or_false (): # Fan-out max_diff_node_i , diff = self . _search_max_diff_node ( G ) num_add = random . randint ( 1 , diff ) add_node_i_list = [ G . number_of_nodes () + i for i in range ( num_add )] nx . add_star ( G , [ max_diff_node_i ] + add_node_i_list ) else : # Fan-in num_sources = random . randint ( 1 , self . _max_in ) nodes = list ( G . nodes ()) random . shuffle ( nodes ) sources = [] for node_i in nodes : if G . out_degree ( node_i ) < self . _max_out : sources . append ( node_i ) if len ( sources ) == num_sources : break add_node_i = G . number_of_nodes () G . add_node ( add_node_i ) for source_node_i in sources : G . add_edge ( source_node_i , add_node_i ) # Check build fail if G . number_of_nodes () > num_nodes : num_build_fail += 1 if num_build_fail == self . _max_try : msg = ( \"A DAG satisfying 'Number of nodes' could not be built \" f \"in { self . _max_try } tries.\" ) raise BuildFailedError ( msg ) else : G = self . _init_dag ( num_entry ) # reset # Add exit nodes (Optional) if num_exit : original_exits = Util . get_exit_nodes ( G ) new_exits = [ G . number_of_nodes () + i for i in range ( num_exit )] G . add_nodes_from ( new_exits ) self . _add_minimum_edges ( original_exits , new_exits , G ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : self . _ensure_weakly_connected ( G ) yield G","title":"build()"},{"location":"dag_builder/#src.dag_builder.fan_in_fan_out.FanInFanOut.validate_config","text":"Validate config. Parameters: Name Type Description Default config Config Inputted config. required Raises: Type Description InfeasibleConfigError An infeasible parameter was entered. Source code in src/dag_builder/fan_in_fan_out.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = config . number_of_entry_nodes number_of_exit_nodes = config . number_of_exit_nodes or 0 number_of_nodes = config . number_of_nodes if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" )","title":"validate_config()"},{"location":"exceptions/","text":"BuildFailedError # Bases: Error Failed to build. Source code in src/exceptions.py 12 13 14 15 16 class BuildFailedError ( Error ): \"\"\"Failed to build.\"\"\" def __init__ ( self , message : str ) -> None : self . message = message Error # Bases: Exception Base class for exception. Source code in src/exceptions.py 1 2 class Error ( Exception ): \"\"\"Base class for exception.\"\"\" InfeasibleConfigError # Bases: Error Infeasible parameters entered. Source code in src/exceptions.py 5 6 7 8 9 class InfeasibleConfigError ( Error ): \"\"\"Infeasible parameters entered.\"\"\" def __init__ ( self , message : str ) -> None : self . message = message","title":"exceptions"},{"location":"exceptions/#src.exceptions.BuildFailedError","text":"Bases: Error Failed to build. Source code in src/exceptions.py 12 13 14 15 16 class BuildFailedError ( Error ): \"\"\"Failed to build.\"\"\" def __init__ ( self , message : str ) -> None : self . message = message","title":"BuildFailedError"},{"location":"exceptions/#src.exceptions.Error","text":"Bases: Exception Base class for exception. Source code in src/exceptions.py 1 2 class Error ( Exception ): \"\"\"Base class for exception.\"\"\"","title":"Error"},{"location":"exceptions/#src.exceptions.InfeasibleConfigError","text":"Bases: Error Infeasible parameters entered. Source code in src/exceptions.py 5 6 7 8 9 class InfeasibleConfigError ( Error ): \"\"\"Infeasible parameters entered.\"\"\" def __init__ ( self , message : str ) -> None : self . message = message","title":"InfeasibleConfigError"}]}
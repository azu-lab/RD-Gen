{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RD-Gen # Packages # config common dag_builder exceptions","title":"HOME"},{"location":"#rd-gen","text":"","title":"RD-Gen"},{"location":"#packages","text":"config common dag_builder exceptions","title":"Packages"},{"location":"common/","text":"Util # Utilization class. Source code in src\\common\\util.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Util : \"\"\"Utilization class.\"\"\" @staticmethod def ambiguous_equals ( s : str , comparison : str ) -> bool : return s . lower () . replace ( \" \" , \"\" ) == comparison . lower () . replace ( \" \" , \"\" ) @staticmethod def convert_to_property ( param_name : str ) -> str : return param_name . lower () . replace ( \" \" , \"_\" ) @staticmethod def random_choice ( target : Union [ Any , list ]): if isinstance ( target , list ): return random . choice ( target ) else : return target @staticmethod def true_or_false () -> bool : if random . choice ([ 0 , 1 ]) == 1 : return True else : return False @staticmethod def get_entry_nodes ( dag : nx . DiGraph ) -> List [ int ]: return [ v for v , d in dag . in_degree () if d == 0 ] @staticmethod def get_exit_nodes ( dag : nx . DiGraph ) -> List [ int ]: return [ v for v , d in dag . out_degree () if d == 0 ] @staticmethod def get_min_in_node ( dag : nx . DiGraph , option : Collection [ int ]) -> int : min_in_node_i : int min_in = sys . maxsize for node_i in option : if ( in_degree := dag . in_degree ( node_i )) < min_in : min_in_node_i = node_i min_in = in_degree if min_in == 0 : break return min_in_node_i @staticmethod def get_min_out_node ( dag : nx . DiGraph , option : Collection [ int ]) -> int : min_out_node_i : int min_out = sys . maxsize for node_i in option : if ( out_degree := dag . out_degree ( node_i )) < min_out : min_out_node_i = node_i min_out = out_degree if min_out == 0 : break return min_out_node_i","title":"common"},{"location":"common/#src.common.Util","text":"Utilization class. Source code in src\\common\\util.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Util : \"\"\"Utilization class.\"\"\" @staticmethod def ambiguous_equals ( s : str , comparison : str ) -> bool : return s . lower () . replace ( \" \" , \"\" ) == comparison . lower () . replace ( \" \" , \"\" ) @staticmethod def convert_to_property ( param_name : str ) -> str : return param_name . lower () . replace ( \" \" , \"_\" ) @staticmethod def random_choice ( target : Union [ Any , list ]): if isinstance ( target , list ): return random . choice ( target ) else : return target @staticmethod def true_or_false () -> bool : if random . choice ([ 0 , 1 ]) == 1 : return True else : return False @staticmethod def get_entry_nodes ( dag : nx . DiGraph ) -> List [ int ]: return [ v for v , d in dag . in_degree () if d == 0 ] @staticmethod def get_exit_nodes ( dag : nx . DiGraph ) -> List [ int ]: return [ v for v , d in dag . out_degree () if d == 0 ] @staticmethod def get_min_in_node ( dag : nx . DiGraph , option : Collection [ int ]) -> int : min_in_node_i : int min_in = sys . maxsize for node_i in option : if ( in_degree := dag . in_degree ( node_i )) < min_in : min_in_node_i = node_i min_in = in_degree if min_in == 0 : break return min_in_node_i @staticmethod def get_min_out_node ( dag : nx . DiGraph , option : Collection [ int ]) -> int : min_out_node_i : int min_out = sys . maxsize for node_i in option : if ( out_degree := dag . out_degree ( node_i )) < min_out : min_out_node_i = node_i min_out = out_degree if min_out == 0 : break return min_out_node_i","title":"Util"},{"location":"config/","text":"ComboGenerator # ComboGenerator class. Source code in src\\config\\combo_generator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class ComboGenerator : \"\"\"ComboGenerator class.\"\"\" def __init__ ( self , config_raw : dict ) -> None : self . _combo_params : List [ str ] = [] self . _combo_values : List [ Union [ List [ int ], List [ float ]]] = [] self . _search_combo_and_format_tuple ( config_raw [ \"Graph structure\" ]) self . _search_combo_and_format_tuple ( config_raw [ \"Properties\" ]) self . _config = Config ( config_raw ) def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos def get_combo_iter ( self ) -> Generator : \"\"\"Get iterator for combinations. Yields ------ Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v setattr ( combo_config , Util . convert_to_property ( k ), { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config ) def _create_combo_dir_name ( self , combo : Tuple [ Union [ int , float ]], index : int , ) -> str : combo_dir_name : str = \"\" naming = self . _config . naming_of_combination_directory if Util . ambiguous_equals ( naming , \"Full spell\" ): for param , value in zip ( self . _combo_params , combo ): param_str_list = param . split ( \" \" ) param_str_list = [ s . capitalize () for s in param_str_list ] if combo_dir_name : combo_dir_name += f '_ { \"\" . join ( param_str_list ) } _ { value } ' else : combo_dir_name = f ' { \"\" . join ( param_str_list ) } _ { value } ' elif Util . ambiguous_equals ( naming , \"Abbreviation\" ): for param , value in zip ( self . _combo_params , combo ): try : param = TO_ABB [ param . lower ()] except KeyError : # Additional parameter param = param if combo_dir_name : combo_dir_name += f \"_ { param } _ { value } \" else : combo_dir_name = f \" { param } _ { value } \" elif Util . ambiguous_equals ( naming , \"Index of combination\" ): combo_dir_name = f \"Combination_ { index + 1 } \" else : raise NotImplementedError return combo_dir_name @staticmethod def _convert_tuple_to_list ( tuple_str : str ) -> Union [ List [ int ], List [ float ]]: tuple_str = tuple_str . replace ( \"(\" , \"\" ) tuple_str = tuple_str . replace ( \")\" , \"\" ) tuple_str = tuple_str . replace ( \" \" , \"\" ) args : Dict [ str , float ] = {} for i , arg in enumerate ( tuple_str . split ( \",\" )): if i == 0 or \"start\" in arg : args [ \"start\" ] = float ( arg . replace ( \"start=\" , \"\" )) elif i == 1 or \"stop\" in arg : args [ \"stop\" ] = float ( arg . replace ( \"stop=\" , \"\" )) elif i == 2 or \"step\" in arg : args [ \"step\" ] = float ( arg . replace ( \"step=\" , \"\" )) if args [ \"start\" ] . is_integer () and args [ \"stop\" ] . is_integer () and args [ \"step\" ] . is_integer (): # int case converted = list ( range ( int ( args [ \"start\" ]), int ( args [ \"stop\" ]), int ( args [ \"step\" ]))) if ( args [ \"stop\" ] - args [ \"start\" ]) % args [ \"step\" ] == 0 : converted . append ( int ( args [ \"stop\" ])) else : # float case def get_num_decimal_places ( n : float ) -> int : ctx = decimal . Context () d = ctx . create_decimal ( repr ( n )) return len ( format ( d , \"f\" ) . split ( \".\" )[ 1 ]) m = max ( get_num_decimal_places ( args [ \"start\" ]), get_num_decimal_places ( args [ \"stop\" ]), get_num_decimal_places ( args [ \"step\" ]), ) converted = [ round ( n , m ) for n in np . arange ( ** args )] # type: ignore if (( args [ \"stop\" ] * ( 10 ** m )) - ( args [ \"start\" ]) * ( 10 ** m )) % ( args [ \"step\" ] * ( 10 ** m ) ) < 10 **- 10 : converted . append ( args [ \"stop\" ]) # type: ignore return converted def _search_combo_and_format_tuple ( self , param_dict : dict ) -> None : for k , v in param_dict . items (): if \"Combination\" in v . keys (): self . _combo_params . append ( k ) if isinstance ( v [ \"Combination\" ], str ): v [ \"Combination\" ] = self . _convert_tuple_to_list ( v [ \"Combination\" ]) # format self . _combo_values . append ( v [ \"Combination\" ]) else : self . _search_combo_and_format_tuple ( v ) get_combo_iter () # Get iterator for combinations. Yields: Type Description Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. Source code in src\\config\\combo_generator.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def get_combo_iter ( self ) -> Generator : \"\"\"Get iterator for combinations. Yields ------ Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v setattr ( combo_config , Util . convert_to_property ( k ), { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config ) get_num_combos () # Get number of combinations. Returns: Type Description int Number of combinations. Source code in src\\config\\combo_generator.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos Config # Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. To obtain the value of 'Additional properties', it is necessary to call a function, not a property. Notes # If the structure of the configuration file changes, this class must be reprogrammed. Source code in src\\config\\config.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 class Config : \"\"\"Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. To obtain the value of 'Additional properties', it is necessary to call a function, not a property. Notes ----- If the structure of the configuration file changes, this class must be reprogrammed. \"\"\" def __init__ ( self , config_raw : dict ) -> None : self . _seed = config_raw [ \"Seed\" ] self . _number_of_dags = config_raw [ \"Number of DAGs\" ] self . _graph_structure = config_raw [ \"Graph structure\" ] self . _properties = config_raw [ \"Properties\" ] self . _additional_properties : Optional [ AdditionalProperties ] if config_raw [ \"Properties\" ] . get ( \"Additional properties\" ): self . _additional_properties = AdditionalProperties ( config_raw [ \"Properties\" ][ \"Additional properties\" ] ) del config_raw [ \"Properties\" ][ \"Additional properties\" ] else : self . _additional_properties = None self . _output_formats = config_raw [ \"Output formats\" ] # def is_additional(self, param_name: str) -> bool: # if self._additional_properties is None: # return False # additional_property_names = self._additional_properties.get_property_names() # if param_name in additional_property_names: # return True # else: # return False # def get_additional_property(self, property_name: str): # return self._additional_properties.get_value(property_name) # def set_additional_property(self, property_name: str, value) -> None: # self._additional_properties.set_value(property_name, value) def set_random_seed ( self ) -> None : random . seed ( self . seed ) def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . _graph_structure ) self . _remove_random_fixed ( self . _properties ) if self . _additional_properties : self . _additional_properties = AdditionalProperties ( self . _properties [ \"Additional properties\" ] ) @staticmethod def _remove_random_fixed ( param_dict : dict ) -> None : for k , v in param_dict . items (): if set ( v . keys ()) <= { \"Random\" , \"Fixed\" }: # Remove value = list ( v . values ()) assert len ( value ) == 1 param_dict [ k ] = value [ 0 ] break else : Config . _remove_random_fixed ( v ) @property def seed ( self ) -> int : return self . _seed @property def number_of_dags ( self ) -> int : return self . _number_of_dags # ----- Graph Structure ----- @property def generation_method ( self ): return self . _graph_structure . get ( \"Generation method\" ) @property def number_of_nodes ( self ): return self . _graph_structure . get ( \"Number of nodes\" ) @number_of_nodes . setter def number_of_nodes ( self , value ): self . _graph_structure [ \"Number of nodes\" ] = value @property def ensure_weakly_connected ( self ): return self . _graph_structure . get ( \"Ensure weakly connected\" ) @property def out_degree ( self ): return self . _graph_structure . get ( \"Out-degree\" ) @out_degree . setter def out_degree ( self , value ): self . _graph_structure [ \"Out-degree\" ] = value @property def in_degree ( self ): return self . _graph_structure . get ( \"In-degree\" ) @in_degree . setter def in_degree ( self , value ): self . _graph_structure [ \"In-degree\" ] = value @property def probability_of_edge ( self ): return self . _graph_structure . get ( \"Probability of edge\" ) @probability_of_edge . setter def probability_of_edge ( self , value ): self . _graph_structure [ \"Probability of edge\" ] = value @property def number_of_chains ( self ): return self . _graph_structure . get ( \"Number of chains\" ) @number_of_chains . setter def number_of_chains ( self , value ): self . _graph_structure [ \"Number of chains\" ] = value @property def main_sequence_length ( self ): return self . _graph_structure . get ( \"Main sequence length\" ) @main_sequence_length . setter def main_sequence_length ( self , value ): self . _graph_structure [ \"Main sequence length\" ] = value @property def number_of_sub_sequences ( self ): return self . _graph_structure . get ( \"Number of sub sequences\" ) @number_of_sub_sequences . setter def number_of_sub_sequences ( self , value ): self . _graph_structure [ \"Number of sub sequences\" ] = value @property def vertically_link_chains ( self ): return self . _graph_structure . get ( \"Vertically link chains\" ) @property def main_sequence_tail ( self ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Main sequence tail\" ) @main_sequence_tail . setter def main_sequence_tail ( self , value ): self . _graph_structure [ \"Vertically link chains\" ][ \"Main sequence tail\" ] = value @property def sub_sequence_tail ( self ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Sub sequence tail\" ) @sub_sequence_tail . setter def sub_sequence_tail ( self , value ): self . _graph_structure [ \"Vertically link chains\" ][ \"Sub sequence tail\" ] = value @property def number_of_entry_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Number of entry nodes\" ) else : return self . _graph_structure . get ( \"Number of entry nodes\" ) @number_of_entry_nodes . setter def number_of_entry_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . _graph_structure [ \"Vertically link chains\" ][ \"Number of entry nodes\" ] = value else : self . _graph_structure [ \"Number of entry nodes\" ] = value @property def merge_chains ( self ): return self . _graph_structure . get ( \"Merge chains\" ) @property def middle_of_chain ( self ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Middle of chain\" ) @middle_of_chain . setter def middle_of_chain ( self , value ): self . _graph_structure [ \"Merge chains\" ][ \"Middle of chain\" ] = value @property def exit_node ( self ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Exit node\" ) @exit_node . setter def exit_node ( self , value ): self . _graph_structure [ \"Merge chains\" ][ \"Exit node\" ] = value @property def number_of_exit_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Number of exit nodes\" ) else : return self . _graph_structure . get ( \"Number of exit nodes\" ) @number_of_exit_nodes . setter def number_of_exit_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . _graph_structure [ \"Merge chains\" ][ \"Number of exit nodes\" ] = value else : self . _graph_structure [ \"Number of exit nodes\" ] = value # ----- Properties ----- @property def execution_time ( self ): return self . _properties . get ( \"Execution time\" ) @execution_time . setter def execution_time ( self , value ): self . _properties [ \"Execution time\" ] = value @property def communication_time ( self ): return self . _properties . get ( \"Communication time\" ) @communication_time . setter def communication_time ( self , value ): self . _properties [ \"Communication time\" ] = value @property def ccr ( self ): return self . _properties . get ( \"CCR\" ) @ccr . setter def ccr ( self , value ): self . _properties [ \"CCR\" ] = value @property def end_to_end_deadline ( self ): return self . _properties . get ( \"End-to-end deadline\" ) @property def ratio_of_deadline_to_critical_path ( self ): return self . _properties [ \"End-to-end deadline\" ] . get ( \"Ratio of deadline to critical path\" ) @ratio_of_deadline_to_critical_path . setter def ratio_of_deadline_to_critical_path ( self , value ): self . _properties [ \"End-to-end deadline\" ][ \"Ratio of deadline to critical path\" ] = value @property def multi_rate ( self ): return self . _properties . get ( \"Multi-rate\" ) @property def periodic_type ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Periodic type\" ) @periodic_type . setter def periodic_type ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Periodic type\" ] = value @property def period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Period\" ) @period . setter def period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Period\" ] = value @property def entry_node_period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Entry node period\" ) @entry_node_period . setter def entry_node_period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Entry node period\" ] = value @property def exit_node_period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Exit node period\" ) @exit_node_period . setter def exit_node_period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Exit node period\" ] = value @property def offset ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Offset\" ) @offset . setter def offset ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Offset\" ] = value @property def total_utilization ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Total utilization\" ) @total_utilization . setter def total_utilization ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Total utilization\" ] = value @property def maximum_utilization ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Maximum utilization\" ) @maximum_utilization . setter def maximum_utilization ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Maximum utilization\" ] = value # ----- Output formats ----- @property def naming_of_combination_directory ( self ): return self . _output_formats . get ( \"Naming of combination directory\" ) @property def yaml ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"YAML\" ) @property def json ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"JSON\" ) @property def xml ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"XML\" ) @property def dot ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"DOT\" ) @property def draw_legend ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"Draw legend\" ) @property def png ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"PNG\" ) @property def svg ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"SVG\" ) @property def eps ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"EPS\" ) @property def pdf ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"PDF\" ) optimize () # Remove 'Random' and 'Fixed' Source code in src\\config\\config.py 76 77 78 79 80 81 82 83 def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . _graph_structure ) self . _remove_random_fixed ( self . _properties ) if self . _additional_properties : self . _additional_properties = AdditionalProperties ( self . _properties [ \"Additional properties\" ] ) ConfigValidator # Config validator class. Source code in src\\config\\config_validator.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 class ConfigValidator : \"\"\"Config validator class.\"\"\" base_schema = Schema ( { Regex ( \"Seed\" , flags = re . I ): int , Regex ( \"Number of DAGs\" , flags = re . I ): int , Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Generation method\" , flags = re . I ): Or ( Regex ( \"Fan-in/Fan-out\" , flags = re . I ), Regex ( r \"G\\(n,[ ]*p\\)\" , flags = re . I ), Regex ( \"Chain-based\" , flags = re . I ), ), Optional ( Regex ( \"Number of nodes\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), }, Regex ( \"Properties\" , flags = re . I ): { Optional ( Regex ( \"Execution time\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Communication time\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"CCR\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ), Optional ( Regex ( \"End-to-end deadline\" , flags = re . I )): { Regex ( \"Ratio of deadline to critical path\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ) }, Optional ( Regex ( \"Multi-rate\" , flags = re . I )): { Regex ( \"Periodic type\" , flags = re . I ): Or ( Regex ( \"All\" , flags = re . I ), Regex ( \"IO\" , flags = re . I ), Regex ( \"Entry\" , flags = re . I ), Regex ( \"Chain\" , flags = re . I ), ), Regex ( \"Period\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Entry node period\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Exit node period\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Offset\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Total utilization\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ), Optional ( Regex ( \"Maximum utilization\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ), }, Optional ( Regex ( \"Additional properties\" , flags = re . I )): { Optional ( Regex ( \"Node properties\" , flags = re . I )): { str : Or ( { Regex ( \"Fixed\" , flags = re . I ): Or ( float , int )}, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], [ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], [ int ], str )}, ) }, Optional ( Regex ( \"Edge properties\" , flags = re . I )): { str : Or ( { Regex ( \"Fixed\" , flags = re . I ): Or ( float , int )}, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], [ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], [ int ], str )}, ) }, }, }, Regex ( \"Output formats\" , flags = re . I ): { Regex ( \"Naming of combination directory\" , flags = re . I ): Or ( Regex ( \"Abbreviation\" , flags = re . I ), Regex ( \"Full spell\" , flags = re . I ), Regex ( \"Index of combination\" , flags = re . I ), ), Regex ( \"DAG\" , flags = re . I ): { Optional ( Regex ( \"YAML\" , flags = re . I )): bool , Optional ( Regex ( \"JSON\" , flags = re . I )): bool , Optional ( Regex ( \"XML\" , flags = re . I )): bool , Optional ( Regex ( \"DOT\" , flags = re . I )): bool , }, Regex ( \"Figure\" , flags = re . I ): { Optional ( Regex ( \"Draw legend\" , flags = re . I )): bool , Optional ( Regex ( \"PNG\" , flags = re . I )): bool , Optional ( Regex ( \"SVG\" , flags = re . I )): bool , Optional ( Regex ( \"EPS\" , flags = re . I )): bool , Optional ( Regex ( \"PDF\" , flags = re . I )): bool , }, }, }, ignore_extra_keys = True , ) fifo_gnp_common_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Number of entry nodes\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Number of exit nodes\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Ensure weakly connected\" , flags = re . I )): bool , } }, ignore_extra_keys = True , ) fan_in_fan_out_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"In-degree\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Out-degree\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), } }, ignore_extra_keys = True , ) g_n_p_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Probability of edge\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ) } }, ignore_extra_keys = True , ) chain_based_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Number of chains\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Main sequence length\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Number of sub sequences\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Vertically link chains\" , re . I )): { Regex ( \"Number of entry nodes\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Main sequence tail\" , re . I ): bool , Regex ( \"Sub sequence tail\" , re . I ): bool , }, Optional ( Regex ( \"Merge chains\" , re . I )): { Regex ( \"Number of exit nodes\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Middle of chain\" , re . I ): bool , Regex ( \"Exit node\" , re . I ): bool , }, } }, ignore_extra_keys = True , ) def __init__ ( self , config_raw : dict ) -> None : self . _config_raw = config_raw def validate ( self ) -> None : \"\"\"Validate config. Check the entered configurations according to the schema. For detail, see https://www.andrewvillazon.com/validate-yaml-python-schema/. \"\"\" self . base_schema . validate ( self . _config_raw ) gm = self . _config_raw [ \"Graph structure\" ][ \"Generation method\" ] if Util . ambiguous_equals ( gm , \"fan-in/fan-out\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . fan_in_fan_out_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"g(n, p)\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . g_n_p_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"chain-based\" ): self . chain_based_schema . validate ( self . _config_raw ) validate () # Validate config. Check the entered configurations according to the schema. For detail, see https://www.andrewvillazon.com/validate-yaml-python-schema/. Source code in src\\config\\config_validator.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 def validate ( self ) -> None : \"\"\"Validate config. Check the entered configurations according to the schema. For detail, see https://www.andrewvillazon.com/validate-yaml-python-schema/. \"\"\" self . base_schema . validate ( self . _config_raw ) gm = self . _config_raw [ \"Graph structure\" ][ \"Generation method\" ] if Util . ambiguous_equals ( gm , \"fan-in/fan-out\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . fan_in_fan_out_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"g(n, p)\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . g_n_p_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"chain-based\" ): self . chain_based_schema . validate ( self . _config_raw )","title":"config"},{"location":"config/#src.config.ComboGenerator","text":"ComboGenerator class. Source code in src\\config\\combo_generator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class ComboGenerator : \"\"\"ComboGenerator class.\"\"\" def __init__ ( self , config_raw : dict ) -> None : self . _combo_params : List [ str ] = [] self . _combo_values : List [ Union [ List [ int ], List [ float ]]] = [] self . _search_combo_and_format_tuple ( config_raw [ \"Graph structure\" ]) self . _search_combo_and_format_tuple ( config_raw [ \"Properties\" ]) self . _config = Config ( config_raw ) def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos def get_combo_iter ( self ) -> Generator : \"\"\"Get iterator for combinations. Yields ------ Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v setattr ( combo_config , Util . convert_to_property ( k ), { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config ) def _create_combo_dir_name ( self , combo : Tuple [ Union [ int , float ]], index : int , ) -> str : combo_dir_name : str = \"\" naming = self . _config . naming_of_combination_directory if Util . ambiguous_equals ( naming , \"Full spell\" ): for param , value in zip ( self . _combo_params , combo ): param_str_list = param . split ( \" \" ) param_str_list = [ s . capitalize () for s in param_str_list ] if combo_dir_name : combo_dir_name += f '_ { \"\" . join ( param_str_list ) } _ { value } ' else : combo_dir_name = f ' { \"\" . join ( param_str_list ) } _ { value } ' elif Util . ambiguous_equals ( naming , \"Abbreviation\" ): for param , value in zip ( self . _combo_params , combo ): try : param = TO_ABB [ param . lower ()] except KeyError : # Additional parameter param = param if combo_dir_name : combo_dir_name += f \"_ { param } _ { value } \" else : combo_dir_name = f \" { param } _ { value } \" elif Util . ambiguous_equals ( naming , \"Index of combination\" ): combo_dir_name = f \"Combination_ { index + 1 } \" else : raise NotImplementedError return combo_dir_name @staticmethod def _convert_tuple_to_list ( tuple_str : str ) -> Union [ List [ int ], List [ float ]]: tuple_str = tuple_str . replace ( \"(\" , \"\" ) tuple_str = tuple_str . replace ( \")\" , \"\" ) tuple_str = tuple_str . replace ( \" \" , \"\" ) args : Dict [ str , float ] = {} for i , arg in enumerate ( tuple_str . split ( \",\" )): if i == 0 or \"start\" in arg : args [ \"start\" ] = float ( arg . replace ( \"start=\" , \"\" )) elif i == 1 or \"stop\" in arg : args [ \"stop\" ] = float ( arg . replace ( \"stop=\" , \"\" )) elif i == 2 or \"step\" in arg : args [ \"step\" ] = float ( arg . replace ( \"step=\" , \"\" )) if args [ \"start\" ] . is_integer () and args [ \"stop\" ] . is_integer () and args [ \"step\" ] . is_integer (): # int case converted = list ( range ( int ( args [ \"start\" ]), int ( args [ \"stop\" ]), int ( args [ \"step\" ]))) if ( args [ \"stop\" ] - args [ \"start\" ]) % args [ \"step\" ] == 0 : converted . append ( int ( args [ \"stop\" ])) else : # float case def get_num_decimal_places ( n : float ) -> int : ctx = decimal . Context () d = ctx . create_decimal ( repr ( n )) return len ( format ( d , \"f\" ) . split ( \".\" )[ 1 ]) m = max ( get_num_decimal_places ( args [ \"start\" ]), get_num_decimal_places ( args [ \"stop\" ]), get_num_decimal_places ( args [ \"step\" ]), ) converted = [ round ( n , m ) for n in np . arange ( ** args )] # type: ignore if (( args [ \"stop\" ] * ( 10 ** m )) - ( args [ \"start\" ]) * ( 10 ** m )) % ( args [ \"step\" ] * ( 10 ** m ) ) < 10 **- 10 : converted . append ( args [ \"stop\" ]) # type: ignore return converted def _search_combo_and_format_tuple ( self , param_dict : dict ) -> None : for k , v in param_dict . items (): if \"Combination\" in v . keys (): self . _combo_params . append ( k ) if isinstance ( v [ \"Combination\" ], str ): v [ \"Combination\" ] = self . _convert_tuple_to_list ( v [ \"Combination\" ]) # format self . _combo_values . append ( v [ \"Combination\" ]) else : self . _search_combo_and_format_tuple ( v )","title":"ComboGenerator"},{"location":"config/#src.config.combo_generator.ComboGenerator.get_combo_iter","text":"Get iterator for combinations. Yields: Type Description Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. Source code in src\\config\\combo_generator.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def get_combo_iter ( self ) -> Generator : \"\"\"Get iterator for combinations. Yields ------ Generator (combo_dir_name, combo_log, combo_config) - combo_dir_name: Directory name where the generated DAG set is stored. - combo_log: Dictionary containing parameter names and chosen values for which 'Combination' is specified. - combo_config: Configuration in which the chosen value is stored for the parameter specified as 'Combination'. \"\"\" for i , combo in enumerate ( itertools . product ( * self . _combo_values )): combo_dir_name = self . _create_combo_dir_name ( combo , i ) # type: ignore combo_log = {} combo_config = copy . deepcopy ( self . _config ) for k , v in zip ( self . _combo_params , combo ): combo_log [ k ] = v setattr ( combo_config , Util . convert_to_property ( k ), { \"Fixed\" : v }) combo_config . optimize () combo_config . set_random_seed () yield ( combo_dir_name , combo_log , combo_config )","title":"get_combo_iter()"},{"location":"config/#src.config.combo_generator.ComboGenerator.get_num_combos","text":"Get number of combinations. Returns: Type Description int Number of combinations. Source code in src\\config\\combo_generator.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def get_num_combos ( self ) -> int : \"\"\"Get number of combinations. Returns ------- int Number of combinations. \"\"\" num_combos = len ( self . _combo_values [ 0 ]) if len ( self . _combo_values ) == 1 : return num_combos for v in self . _combo_values [ 1 :]: num_combos *= len ( v ) return num_combos","title":"get_num_combos()"},{"location":"config/#src.config.Config","text":"Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. To obtain the value of 'Additional properties', it is necessary to call a function, not a property.","title":"Config"},{"location":"config/#src.config.Config--notes","text":"If the structure of the configuration file changes, this class must be reprogrammed. Source code in src\\config\\config.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 class Config : \"\"\"Config class This class provides the value of the config entered by the property. The property names of this class correspond to all parameter names at any level. To obtain the value of 'Additional properties', it is necessary to call a function, not a property. Notes ----- If the structure of the configuration file changes, this class must be reprogrammed. \"\"\" def __init__ ( self , config_raw : dict ) -> None : self . _seed = config_raw [ \"Seed\" ] self . _number_of_dags = config_raw [ \"Number of DAGs\" ] self . _graph_structure = config_raw [ \"Graph structure\" ] self . _properties = config_raw [ \"Properties\" ] self . _additional_properties : Optional [ AdditionalProperties ] if config_raw [ \"Properties\" ] . get ( \"Additional properties\" ): self . _additional_properties = AdditionalProperties ( config_raw [ \"Properties\" ][ \"Additional properties\" ] ) del config_raw [ \"Properties\" ][ \"Additional properties\" ] else : self . _additional_properties = None self . _output_formats = config_raw [ \"Output formats\" ] # def is_additional(self, param_name: str) -> bool: # if self._additional_properties is None: # return False # additional_property_names = self._additional_properties.get_property_names() # if param_name in additional_property_names: # return True # else: # return False # def get_additional_property(self, property_name: str): # return self._additional_properties.get_value(property_name) # def set_additional_property(self, property_name: str, value) -> None: # self._additional_properties.set_value(property_name, value) def set_random_seed ( self ) -> None : random . seed ( self . seed ) def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . _graph_structure ) self . _remove_random_fixed ( self . _properties ) if self . _additional_properties : self . _additional_properties = AdditionalProperties ( self . _properties [ \"Additional properties\" ] ) @staticmethod def _remove_random_fixed ( param_dict : dict ) -> None : for k , v in param_dict . items (): if set ( v . keys ()) <= { \"Random\" , \"Fixed\" }: # Remove value = list ( v . values ()) assert len ( value ) == 1 param_dict [ k ] = value [ 0 ] break else : Config . _remove_random_fixed ( v ) @property def seed ( self ) -> int : return self . _seed @property def number_of_dags ( self ) -> int : return self . _number_of_dags # ----- Graph Structure ----- @property def generation_method ( self ): return self . _graph_structure . get ( \"Generation method\" ) @property def number_of_nodes ( self ): return self . _graph_structure . get ( \"Number of nodes\" ) @number_of_nodes . setter def number_of_nodes ( self , value ): self . _graph_structure [ \"Number of nodes\" ] = value @property def ensure_weakly_connected ( self ): return self . _graph_structure . get ( \"Ensure weakly connected\" ) @property def out_degree ( self ): return self . _graph_structure . get ( \"Out-degree\" ) @out_degree . setter def out_degree ( self , value ): self . _graph_structure [ \"Out-degree\" ] = value @property def in_degree ( self ): return self . _graph_structure . get ( \"In-degree\" ) @in_degree . setter def in_degree ( self , value ): self . _graph_structure [ \"In-degree\" ] = value @property def probability_of_edge ( self ): return self . _graph_structure . get ( \"Probability of edge\" ) @probability_of_edge . setter def probability_of_edge ( self , value ): self . _graph_structure [ \"Probability of edge\" ] = value @property def number_of_chains ( self ): return self . _graph_structure . get ( \"Number of chains\" ) @number_of_chains . setter def number_of_chains ( self , value ): self . _graph_structure [ \"Number of chains\" ] = value @property def main_sequence_length ( self ): return self . _graph_structure . get ( \"Main sequence length\" ) @main_sequence_length . setter def main_sequence_length ( self , value ): self . _graph_structure [ \"Main sequence length\" ] = value @property def number_of_sub_sequences ( self ): return self . _graph_structure . get ( \"Number of sub sequences\" ) @number_of_sub_sequences . setter def number_of_sub_sequences ( self , value ): self . _graph_structure [ \"Number of sub sequences\" ] = value @property def vertically_link_chains ( self ): return self . _graph_structure . get ( \"Vertically link chains\" ) @property def main_sequence_tail ( self ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Main sequence tail\" ) @main_sequence_tail . setter def main_sequence_tail ( self , value ): self . _graph_structure [ \"Vertically link chains\" ][ \"Main sequence tail\" ] = value @property def sub_sequence_tail ( self ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Sub sequence tail\" ) @sub_sequence_tail . setter def sub_sequence_tail ( self , value ): self . _graph_structure [ \"Vertically link chains\" ][ \"Sub sequence tail\" ] = value @property def number_of_entry_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): return self . _graph_structure [ \"Vertically link chains\" ] . get ( \"Number of entry nodes\" ) else : return self . _graph_structure . get ( \"Number of entry nodes\" ) @number_of_entry_nodes . setter def number_of_entry_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . _graph_structure [ \"Vertically link chains\" ][ \"Number of entry nodes\" ] = value else : self . _graph_structure [ \"Number of entry nodes\" ] = value @property def merge_chains ( self ): return self . _graph_structure . get ( \"Merge chains\" ) @property def middle_of_chain ( self ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Middle of chain\" ) @middle_of_chain . setter def middle_of_chain ( self , value ): self . _graph_structure [ \"Merge chains\" ][ \"Middle of chain\" ] = value @property def exit_node ( self ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Exit node\" ) @exit_node . setter def exit_node ( self , value ): self . _graph_structure [ \"Merge chains\" ][ \"Exit node\" ] = value @property def number_of_exit_nodes ( self ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): return self . _graph_structure [ \"Merge chains\" ] . get ( \"Number of exit nodes\" ) else : return self . _graph_structure . get ( \"Number of exit nodes\" ) @number_of_exit_nodes . setter def number_of_exit_nodes ( self , value ): if Util . ambiguous_equals ( self . generation_method , \"chain-based\" ): self . _graph_structure [ \"Merge chains\" ][ \"Number of exit nodes\" ] = value else : self . _graph_structure [ \"Number of exit nodes\" ] = value # ----- Properties ----- @property def execution_time ( self ): return self . _properties . get ( \"Execution time\" ) @execution_time . setter def execution_time ( self , value ): self . _properties [ \"Execution time\" ] = value @property def communication_time ( self ): return self . _properties . get ( \"Communication time\" ) @communication_time . setter def communication_time ( self , value ): self . _properties [ \"Communication time\" ] = value @property def ccr ( self ): return self . _properties . get ( \"CCR\" ) @ccr . setter def ccr ( self , value ): self . _properties [ \"CCR\" ] = value @property def end_to_end_deadline ( self ): return self . _properties . get ( \"End-to-end deadline\" ) @property def ratio_of_deadline_to_critical_path ( self ): return self . _properties [ \"End-to-end deadline\" ] . get ( \"Ratio of deadline to critical path\" ) @ratio_of_deadline_to_critical_path . setter def ratio_of_deadline_to_critical_path ( self , value ): self . _properties [ \"End-to-end deadline\" ][ \"Ratio of deadline to critical path\" ] = value @property def multi_rate ( self ): return self . _properties . get ( \"Multi-rate\" ) @property def periodic_type ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Periodic type\" ) @periodic_type . setter def periodic_type ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Periodic type\" ] = value @property def period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Period\" ) @period . setter def period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Period\" ] = value @property def entry_node_period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Entry node period\" ) @entry_node_period . setter def entry_node_period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Entry node period\" ] = value @property def exit_node_period ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Exit node period\" ) @exit_node_period . setter def exit_node_period ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Exit node period\" ] = value @property def offset ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Offset\" ) @offset . setter def offset ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Offset\" ] = value @property def total_utilization ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Total utilization\" ) @total_utilization . setter def total_utilization ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Total utilization\" ] = value @property def maximum_utilization ( self ): return self . _properties [ \"Multi-rate\" ] . get ( \"Maximum utilization\" ) @maximum_utilization . setter def maximum_utilization ( self , value ): self . _properties [ \"Multi-rate\" ][ \"Maximum utilization\" ] = value # ----- Output formats ----- @property def naming_of_combination_directory ( self ): return self . _output_formats . get ( \"Naming of combination directory\" ) @property def yaml ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"YAML\" ) @property def json ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"JSON\" ) @property def xml ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"XML\" ) @property def dot ( self ): return self . _output_formats [ \"DAG\" ] . get ( \"DOT\" ) @property def draw_legend ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"Draw legend\" ) @property def png ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"PNG\" ) @property def svg ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"SVG\" ) @property def eps ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"EPS\" ) @property def pdf ( self ): return self . _output_formats [ \"Figure\" ] . get ( \"PDF\" )","title":"Notes"},{"location":"config/#src.config.config.Config.optimize","text":"Remove 'Random' and 'Fixed' Source code in src\\config\\config.py 76 77 78 79 80 81 82 83 def optimize ( self ) -> None : \"\"\"Remove 'Random' and 'Fixed'\"\"\" self . _remove_random_fixed ( self . _graph_structure ) self . _remove_random_fixed ( self . _properties ) if self . _additional_properties : self . _additional_properties = AdditionalProperties ( self . _properties [ \"Additional properties\" ] )","title":"optimize()"},{"location":"config/#src.config.ConfigValidator","text":"Config validator class. Source code in src\\config\\config_validator.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 class ConfigValidator : \"\"\"Config validator class.\"\"\" base_schema = Schema ( { Regex ( \"Seed\" , flags = re . I ): int , Regex ( \"Number of DAGs\" , flags = re . I ): int , Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Generation method\" , flags = re . I ): Or ( Regex ( \"Fan-in/Fan-out\" , flags = re . I ), Regex ( r \"G\\(n,[ ]*p\\)\" , flags = re . I ), Regex ( \"Chain-based\" , flags = re . I ), ), Optional ( Regex ( \"Number of nodes\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), }, Regex ( \"Properties\" , flags = re . I ): { Optional ( Regex ( \"Execution time\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Communication time\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"CCR\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ), Optional ( Regex ( \"End-to-end deadline\" , flags = re . I )): { Regex ( \"Ratio of deadline to critical path\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ) }, Optional ( Regex ( \"Multi-rate\" , flags = re . I )): { Regex ( \"Periodic type\" , flags = re . I ): Or ( Regex ( \"All\" , flags = re . I ), Regex ( \"IO\" , flags = re . I ), Regex ( \"Entry\" , flags = re . I ), Regex ( \"Chain\" , flags = re . I ), ), Regex ( \"Period\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Entry node period\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Exit node period\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Offset\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Total utilization\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ), Optional ( Regex ( \"Maximum utilization\" , flags = re . I )): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ), }, Optional ( Regex ( \"Additional properties\" , flags = re . I )): { Optional ( Regex ( \"Node properties\" , flags = re . I )): { str : Or ( { Regex ( \"Fixed\" , flags = re . I ): Or ( float , int )}, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], [ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], [ int ], str )}, ) }, Optional ( Regex ( \"Edge properties\" , flags = re . I )): { str : Or ( { Regex ( \"Fixed\" , flags = re . I ): Or ( float , int )}, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], [ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], [ int ], str )}, ) }, }, }, Regex ( \"Output formats\" , flags = re . I ): { Regex ( \"Naming of combination directory\" , flags = re . I ): Or ( Regex ( \"Abbreviation\" , flags = re . I ), Regex ( \"Full spell\" , flags = re . I ), Regex ( \"Index of combination\" , flags = re . I ), ), Regex ( \"DAG\" , flags = re . I ): { Optional ( Regex ( \"YAML\" , flags = re . I )): bool , Optional ( Regex ( \"JSON\" , flags = re . I )): bool , Optional ( Regex ( \"XML\" , flags = re . I )): bool , Optional ( Regex ( \"DOT\" , flags = re . I )): bool , }, Regex ( \"Figure\" , flags = re . I ): { Optional ( Regex ( \"Draw legend\" , flags = re . I )): bool , Optional ( Regex ( \"PNG\" , flags = re . I )): bool , Optional ( Regex ( \"SVG\" , flags = re . I )): bool , Optional ( Regex ( \"EPS\" , flags = re . I )): bool , Optional ( Regex ( \"PDF\" , flags = re . I )): bool , }, }, }, ignore_extra_keys = True , ) fifo_gnp_common_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Number of entry nodes\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Number of exit nodes\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Ensure weakly connected\" , flags = re . I )): bool , } }, ignore_extra_keys = True , ) fan_in_fan_out_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"In-degree\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Out-degree\" , flags = re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), } }, ignore_extra_keys = True , ) g_n_p_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Probability of edge\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): float }, { Regex ( \"Random\" , flags = re . I ): Or ([ float ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ float ], str )}, ) } }, ignore_extra_keys = True , ) chain_based_schema = Schema ( { Regex ( \"Graph structure\" , flags = re . I ): { Regex ( \"Number of chains\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Main sequence length\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Number of sub sequences\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Optional ( Regex ( \"Vertically link chains\" , re . I )): { Regex ( \"Number of entry nodes\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Main sequence tail\" , re . I ): bool , Regex ( \"Sub sequence tail\" , re . I ): bool , }, Optional ( Regex ( \"Merge chains\" , re . I )): { Regex ( \"Number of exit nodes\" , re . I ): Or ( { Regex ( \"Fixed\" , flags = re . I ): int }, { Regex ( \"Random\" , flags = re . I ): Or ([ int ], str )}, { Regex ( \"Combination\" , flags = re . I ): Or ([ int ], str )}, ), Regex ( \"Middle of chain\" , re . I ): bool , Regex ( \"Exit node\" , re . I ): bool , }, } }, ignore_extra_keys = True , ) def __init__ ( self , config_raw : dict ) -> None : self . _config_raw = config_raw def validate ( self ) -> None : \"\"\"Validate config. Check the entered configurations according to the schema. For detail, see https://www.andrewvillazon.com/validate-yaml-python-schema/. \"\"\" self . base_schema . validate ( self . _config_raw ) gm = self . _config_raw [ \"Graph structure\" ][ \"Generation method\" ] if Util . ambiguous_equals ( gm , \"fan-in/fan-out\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . fan_in_fan_out_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"g(n, p)\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . g_n_p_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"chain-based\" ): self . chain_based_schema . validate ( self . _config_raw )","title":"ConfigValidator"},{"location":"config/#src.config.config_validator.ConfigValidator.validate","text":"Validate config. Check the entered configurations according to the schema. For detail, see https://www.andrewvillazon.com/validate-yaml-python-schema/. Source code in src\\config\\config_validator.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 def validate ( self ) -> None : \"\"\"Validate config. Check the entered configurations according to the schema. For detail, see https://www.andrewvillazon.com/validate-yaml-python-schema/. \"\"\" self . base_schema . validate ( self . _config_raw ) gm = self . _config_raw [ \"Graph structure\" ][ \"Generation method\" ] if Util . ambiguous_equals ( gm , \"fan-in/fan-out\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . fan_in_fan_out_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"g(n, p)\" ): self . fifo_gnp_common_schema . validate ( self . _config_raw ) self . g_n_p_schema . validate ( self . _config_raw ) elif Util . ambiguous_equals ( gm , \"chain-based\" ): self . chain_based_schema . validate ( self . _config_raw )","title":"validate()"},{"location":"dag_builder/","text":"Chain # Bases: nx . DiGraph Chain class. Source code in src\\dag_builder\\chain_based.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Chain ( nx . DiGraph ): \"\"\"Chain class.\"\"\" def __init__ ( self , start_idx : int ) -> None : \"\"\"Constructor. Parameters ---------- start_idx : int Index of chain head. \"\"\" super () . __init__ () self . start_idx : int = start_idx self . end_idx : int self . main_tail : int @property def head ( self ) -> int : return self . start_idx @property def sub_sequence_tails ( self ) -> List [ int ]: tails = Util . get_exit_nodes ( self ) tails . remove ( self . main_tail ) return tails def build_chain ( self , main_sequence_length : int , number_of_sub_sequence : Optional [ int ] = None , ) -> None : \"\"\"Build chain. Build the chain so that the main sequence is the longest. Parameters ---------- main_sequence_length : int Main sequence length number_of_sub_sequence : Optional[int], optional Number of sub sequence, by default None \"\"\" def create_sequence ( start_idx : int , len_sequence : int ) -> None : self . add_node ( start_idx ) for i in range ( start_idx , start_idx + len_sequence - 1 ): self . add_edge ( i , i + 1 ) # Build main sequence main_seq_i = [ i for i in range ( self . start_idx , self . start_idx + main_sequence_length )] self . main_tail = self . end_idx = main_seq_i [ - 1 ] create_sequence ( self . start_idx , main_sequence_length ) # Build sub sequence (Optional) if number_of_sub_sequence : for _ in range ( number_of_sub_sequence ): src_i = random . choice ( main_seq_i [: - 1 ]) sub_seq_len = main_sequence_length - main_seq_i . index ( src_i ) - 1 sub_seq_start_idx = self . end_idx + 1 create_sequence ( sub_seq_start_idx , sub_seq_len ) self . add_edge ( src_i , sub_seq_start_idx ) self . end_idx = sub_seq_start_idx + sub_seq_len - 1 __init__ ( start_idx ) # Constructor. Parameters: Name Type Description Default start_idx int Index of chain head. required Source code in src\\dag_builder\\chain_based.py 15 16 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , start_idx : int ) -> None : \"\"\"Constructor. Parameters ---------- start_idx : int Index of chain head. \"\"\" super () . __init__ () self . start_idx : int = start_idx self . end_idx : int self . main_tail : int build_chain ( main_sequence_length , number_of_sub_sequence = None ) # Build chain. Build the chain so that the main sequence is the longest. Parameters: Name Type Description Default main_sequence_length int Main sequence length required number_of_sub_sequence Optional [ int ], optional Number of sub sequence, by default None None Source code in src\\dag_builder\\chain_based.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def build_chain ( self , main_sequence_length : int , number_of_sub_sequence : Optional [ int ] = None , ) -> None : \"\"\"Build chain. Build the chain so that the main sequence is the longest. Parameters ---------- main_sequence_length : int Main sequence length number_of_sub_sequence : Optional[int], optional Number of sub sequence, by default None \"\"\" def create_sequence ( start_idx : int , len_sequence : int ) -> None : self . add_node ( start_idx ) for i in range ( start_idx , start_idx + len_sequence - 1 ): self . add_edge ( i , i + 1 ) # Build main sequence main_seq_i = [ i for i in range ( self . start_idx , self . start_idx + main_sequence_length )] self . main_tail = self . end_idx = main_seq_i [ - 1 ] create_sequence ( self . start_idx , main_sequence_length ) # Build sub sequence (Optional) if number_of_sub_sequence : for _ in range ( number_of_sub_sequence ): src_i = random . choice ( main_seq_i [: - 1 ]) sub_seq_len = main_sequence_length - main_seq_i . index ( src_i ) - 1 sub_seq_start_idx = self . end_idx + 1 create_sequence ( sub_seq_start_idx , sub_seq_len ) self . add_edge ( src_i , sub_seq_start_idx ) self . end_idx = sub_seq_start_idx + sub_seq_len - 1 ChainBased # Bases: DAGBuilderBase Chain-based class. Source code in src\\dag_builder\\chain_based.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 class ChainBased ( DAGBuilderBase ): \"\"\"Chain-based class.\"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" main_sequence_length = config . main_sequence_length number_of_sub_sequences = config . number_of_sub_sequences if main_sequence_length == 1 and number_of_sub_sequences : raise InfeasibleConfigError ( \"Since the length of 'Main sequence length' is 1, \" \"the sub-sequence cannot be built.\" ) if config . vertically_link_chains : main_sequence_tail = config . main_sequence_tail sub_sequence_tail = config . sub_sequence_tail if main_sequence_tail is False and sub_sequence_tail is False : raise InfeasibleConfigError ( \"Either 'Main sequence tail' or 'Sub sequence tail' must be set to True.\" ) number_of_chains = config . number_of_chains number_of_entry_nodes = config . number_of_entry_nodes if number_of_chains < number_of_entry_nodes : raise InfeasibleConfigError ( \"'Number of chains' < 'Number of entry nodes.'\" ) if config . merge_chains : middle_of_chain = config . middle_of_chain exit_node = config . exit_node if middle_of_chain is False and exit_node is False : raise InfeasibleConfigError ( \"Either 'Middle of chain' or 'Exit node' must be set to True.\" ) number_of_chains = config . number_of_chains number_of_exit_nodes = config . number_of_exit_nodes if number_of_chains * number_of_sub_sequences < number_of_exit_nodes : raise InfeasibleConfigError ( \"'Number of chains' * 'Number of sub sequence' < 'Number of exit nodes.'\" ) def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using chain-based method. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Build each chain chains : List [ Chain ] = [] start_idx = 0 for _ in range ( self . _config . number_of_chains ): chain = Chain ( start_idx ) main_sequence_length = Util . random_choice ( self . _config . main_sequence_length ) number_of_sub_sequence = ( Util . random_choice ( self . _config . number_of_sub_sequences ) if self . _config . number_of_sub_sequences else None ) chain . build_chain ( main_sequence_length , number_of_sub_sequence ) chains . append ( chain ) start_idx = chain . end_idx + 1 # Create chain-based DAG chain_based_dag = ChainBasedDAG ( chains ) # Vertically link chains (optional) if self . _config . vertically_link_chains : chain_based_dag . vertically_link_chains ( Util . random_choice ( self . _config . number_of_entry_nodes ), self . _config . main_sequence_tail , self . _config . sub_sequence_tail , ) # Merge chains (optional) if self . _config . merge_chains : try : chain_based_dag . merge_chains ( Util . random_choice ( self . _config . number_of_exit_nodes ), self . _config . middle_of_chain , self . _config . exit_node , ) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield chain_based_dag build () # Build DAG using chain-based method. Yields: Type Description Generator DAG generator. Raises: Type Description BuildFailedError The number of build failures exceeded the maximum number of attempts. Source code in src\\dag_builder\\chain_based.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using chain-based method. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Build each chain chains : List [ Chain ] = [] start_idx = 0 for _ in range ( self . _config . number_of_chains ): chain = Chain ( start_idx ) main_sequence_length = Util . random_choice ( self . _config . main_sequence_length ) number_of_sub_sequence = ( Util . random_choice ( self . _config . number_of_sub_sequences ) if self . _config . number_of_sub_sequences else None ) chain . build_chain ( main_sequence_length , number_of_sub_sequence ) chains . append ( chain ) start_idx = chain . end_idx + 1 # Create chain-based DAG chain_based_dag = ChainBasedDAG ( chains ) # Vertically link chains (optional) if self . _config . vertically_link_chains : chain_based_dag . vertically_link_chains ( Util . random_choice ( self . _config . number_of_entry_nodes ), self . _config . main_sequence_tail , self . _config . sub_sequence_tail , ) # Merge chains (optional) if self . _config . merge_chains : try : chain_based_dag . merge_chains ( Util . random_choice ( self . _config . number_of_exit_nodes ), self . _config . middle_of_chain , self . _config . exit_node , ) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield chain_based_dag validate_config ( config ) # Validate config. Parameters: Name Type Description Default config Config Inputted config. required Raises: Type Description InfeasibleConfigError An infeasible parameter was entered. Source code in src\\dag_builder\\chain_based.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" main_sequence_length = config . main_sequence_length number_of_sub_sequences = config . number_of_sub_sequences if main_sequence_length == 1 and number_of_sub_sequences : raise InfeasibleConfigError ( \"Since the length of 'Main sequence length' is 1, \" \"the sub-sequence cannot be built.\" ) if config . vertically_link_chains : main_sequence_tail = config . main_sequence_tail sub_sequence_tail = config . sub_sequence_tail if main_sequence_tail is False and sub_sequence_tail is False : raise InfeasibleConfigError ( \"Either 'Main sequence tail' or 'Sub sequence tail' must be set to True.\" ) number_of_chains = config . number_of_chains number_of_entry_nodes = config . number_of_entry_nodes if number_of_chains < number_of_entry_nodes : raise InfeasibleConfigError ( \"'Number of chains' < 'Number of entry nodes.'\" ) if config . merge_chains : middle_of_chain = config . middle_of_chain exit_node = config . exit_node if middle_of_chain is False and exit_node is False : raise InfeasibleConfigError ( \"Either 'Middle of chain' or 'Exit node' must be set to True.\" ) number_of_chains = config . number_of_chains number_of_exit_nodes = config . number_of_exit_nodes if number_of_chains * number_of_sub_sequences < number_of_exit_nodes : raise InfeasibleConfigError ( \"'Number of chains' * 'Number of sub sequence' < 'Number of exit nodes.'\" ) ChainBasedDAG # Bases: nx . DiGraph Chain-based DAG class. Source code in src\\dag_builder\\chain_based.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 class ChainBasedDAG ( nx . DiGraph ): \"\"\"Chain-based DAG class.\"\"\" def __init__ ( self , chains : List [ Chain ]) -> None : super () . __init__ () self . _chains = chains for chain in self . _chains : self . add_nodes_from ( chain . nodes ) self . add_edges_from ( chain . edges ) def vertically_link_chains ( self , number_of_entry_nodes : int , link_main_tail : bool , link_sub_tail : bool ) -> None : \"\"\"Vertically link chains. Parameters ---------- number_of_entry_nodes : int Number of entry nodes. link_main_tail : bool Allow link in main sequence tails. link_sub_tail : bool Allow link in sub sequence tails. \"\"\" # Determine source option src_chains = set ( random . sample ( self . _chains , number_of_entry_nodes )) src_option = [] for chain in src_chains : if link_main_tail : src_option . append ( chain . main_tail ) if link_sub_tail : src_option += chain . sub_sequence_tails # Determine targets tgt_chains = set ( self . _chains ) - src_chains targets = [ chain . head for chain in tgt_chains ] # Add edges for tgt_i in targets : src_i = Util . get_min_out_node ( self , src_option ) self . add_edge ( src_i , tgt_i ) def merge_chains ( self , number_of_exit_nodes : int , merge_middle : bool , merge_exit : bool ) -> None : \"\"\"Merge chains. Parameters ---------- number_of_exit_nodes : int Number of exit nodes. merge_middle : bool Allow merge to middle nodes. merge_exit : bool Allow merge to exit nodes. Raises ------ BuildFailedError No merging is possible. \"\"\" selected_exits = set ( random . sample ( Util . get_exit_nodes ( self ), number_of_exit_nodes )) sources = set ( Util . get_exit_nodes ( self )) - set ( selected_exits ) # Determine target option tgt_option = set ( self . nodes ()) - set ( Util . get_entry_nodes ( self )) - sources if not merge_exit : tgt_option -= selected_exits if not merge_middle : tgt_option = selected_exits # Add edges for src_i in sources : _tgt_option = tgt_option - nx . ancestors ( self , src_i ) if not _tgt_option : raise BuildFailedError ( \"No merging is possible.\" ) tgt_i = Util . get_min_in_node ( self , _tgt_option ) self . add_edge ( src_i , tgt_i ) merge_chains ( number_of_exit_nodes , merge_middle , merge_exit ) # Merge chains. Parameters: Name Type Description Default number_of_exit_nodes int Number of exit nodes. required merge_middle bool Allow merge to middle nodes. required merge_exit bool Allow merge to exit nodes. required Raises: Type Description BuildFailedError No merging is possible. Source code in src\\dag_builder\\chain_based.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def merge_chains ( self , number_of_exit_nodes : int , merge_middle : bool , merge_exit : bool ) -> None : \"\"\"Merge chains. Parameters ---------- number_of_exit_nodes : int Number of exit nodes. merge_middle : bool Allow merge to middle nodes. merge_exit : bool Allow merge to exit nodes. Raises ------ BuildFailedError No merging is possible. \"\"\" selected_exits = set ( random . sample ( Util . get_exit_nodes ( self ), number_of_exit_nodes )) sources = set ( Util . get_exit_nodes ( self )) - set ( selected_exits ) # Determine target option tgt_option = set ( self . nodes ()) - set ( Util . get_entry_nodes ( self )) - sources if not merge_exit : tgt_option -= selected_exits if not merge_middle : tgt_option = selected_exits # Add edges for src_i in sources : _tgt_option = tgt_option - nx . ancestors ( self , src_i ) if not _tgt_option : raise BuildFailedError ( \"No merging is possible.\" ) tgt_i = Util . get_min_in_node ( self , _tgt_option ) self . add_edge ( src_i , tgt_i ) vertically_link_chains ( number_of_entry_nodes , link_main_tail , link_sub_tail ) # Vertically link chains. Parameters: Name Type Description Default number_of_entry_nodes int Number of entry nodes. required link_main_tail bool Allow link in main sequence tails. required link_sub_tail bool Allow link in sub sequence tails. required Source code in src\\dag_builder\\chain_based.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def vertically_link_chains ( self , number_of_entry_nodes : int , link_main_tail : bool , link_sub_tail : bool ) -> None : \"\"\"Vertically link chains. Parameters ---------- number_of_entry_nodes : int Number of entry nodes. link_main_tail : bool Allow link in main sequence tails. link_sub_tail : bool Allow link in sub sequence tails. \"\"\" # Determine source option src_chains = set ( random . sample ( self . _chains , number_of_entry_nodes )) src_option = [] for chain in src_chains : if link_main_tail : src_option . append ( chain . main_tail ) if link_sub_tail : src_option += chain . sub_sequence_tails # Determine targets tgt_chains = set ( self . _chains ) - src_chains targets = [ chain . head for chain in tgt_chains ] # Add edges for tgt_i in targets : src_i = Util . get_min_out_node ( self , src_option ) self . add_edge ( src_i , tgt_i ) DAGBuilderBase # DAG builder base class. Source code in src\\dag_builder\\dag_builder_base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class DAGBuilderBase ( metaclass = ABCMeta ): \"\"\"DAG builder base class.\"\"\" def __init__ ( self , config : Config , max_try : int = 100 ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. max_try : int, optional Maximum number of build attempts for a single DAG, by default 100 \"\"\" self . validate_config ( config ) self . _config = config self . _max_try = max_try @abstractmethod def build ( self ) -> Generator [ nx . DiGraph , None , None ]: raise NotImplementedError @abstractmethod def validate_config ( self , config : Config ): raise NotImplementedError @staticmethod def _force_create_entry_nodes ( G : nx . DiGraph , number_of_entry_nodes : int ) -> None : \"\"\"Create an entry node forcibly. Add 'number_of_entry_nodes' number of new nodes to the DAG and make them entry nodes. All original entry nodes are connected to the newly added node. Parameters ---------- G : nx.DiGraph DAG. number_of_entry_nodes : int Number of entry nodes. \"\"\" original_entries = Util . get_entry_nodes ( G ) new_entries = [ G . number_of_nodes () + i for i in range ( number_of_entry_nodes )] G . add_nodes_from ( new_entries ) DAGBuilderBase . _add_minimum_edges ( new_entries , original_entries , G ) @staticmethod def _force_create_exit_nodes ( G : nx . DiGraph , number_of_exit_nodes : int ) -> None : \"\"\"Create an exit node forcibly. Add 'number_of_exit_nodes' number of new nodes to the DAG and make them exit nodes. All original exit nodes are connected to the newly added node. Parameters ---------- G : nx.DiGraph DAG. number_of_exit_nodes : int Number of exit nodes. \"\"\" original_exits = Util . get_exit_nodes ( G ) new_exits = [ G . number_of_nodes () + i for i in range ( number_of_exit_nodes )] G . add_nodes_from ( new_exits ) DAGBuilderBase . _add_minimum_edges ( original_exits , new_exits , G ) @staticmethod def _add_minimum_edges ( src_layer : List [ int ], tgt_layer : List [ int ], G : nx . DiGraph ) -> None : \"\"\"Add minimum edges Connects the source and target layers with a minimum number of edges. The function terminates when the out-degree of the source layer is greater than or equal to 1 and the in-degree of the target layer is greater than or equal to 1. Parameters ---------- src_layer : List[int] Indices of nodes that are the source of the edge. tgt_layer : List[int] Indices of nodes that are the target of the edge. G : nx.DiGraph DAG. \"\"\" def is_finish () -> bool : for src_node_i in src_layer : if G . out_degree ( src_node_i ) == 0 : return False for tgt_node_i in tgt_layer : if G . in_degree ( tgt_node_i ) == 0 : return False return True while not is_finish (): min_out_src_i = Util . get_min_out_node ( G , src_layer ) min_in_tgt_i = Util . get_min_in_node ( G , tgt_layer ) G . add_edge ( min_out_src_i , min_in_tgt_i ) @staticmethod def _ensure_weakly_connected ( G : nx . DiGraph , keep_num_entry : bool , keep_num_exit : bool ) -> None : \"\"\"Ensure weakly connected. Parameters ---------- G : nx.DiGraph DAG. keep_num_entry : bool Keep the number of entry nodes. keep_num_exit : bool Keep the number of exit nodes. Raises ------ BuildFailedError The number of entry nodes and the number of exit nodes cannot be kept because of the size 1 component. \"\"\" comps = list ( nx . weakly_connected_components ( G )) if len ( comps ) == 1 : return None comps . sort ( key = lambda x : len ( x )) tgt_comp = comps . pop ( - 1 ) # Most big component entry_nodes = set ( Util . get_entry_nodes ( G )) exit_nodes = set ( Util . get_exit_nodes ( G )) if keep_num_entry and keep_num_exit and ( entry_nodes & exit_nodes ): raise BuildFailedError ( \"The number of entry nodes and the number of exit nodes\" \"cannot be maintained because of the size 1 component.\" ) for src_comp in comps : src_option = src_comp - exit_nodes if keep_num_exit else src_comp tgt_option = tgt_comp - entry_nodes if keep_num_entry else tgt_comp src_i = Util . get_min_out_node ( G , src_option ) tgt_i = Util . get_min_in_node ( G , tgt_option ) G . add_edge ( src_i , tgt_i ) __init__ ( config , max_try = 100 ) # Constructor. Parameters: Name Type Description Default config Config Config. required max_try int , optional Maximum number of build attempts for a single DAG, by default 100 100 Source code in src\\dag_builder\\dag_builder_base.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , config : Config , max_try : int = 100 ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. max_try : int, optional Maximum number of build attempts for a single DAG, by default 100 \"\"\" self . validate_config ( config ) self . _config = config self . _max_try = max_try DAGBuilderFactory # DAG builder factory class. Source code in src\\dag_builder\\dag_builder_factory.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class DAGBuilderFactory : \"\"\"DAG builder factory class.\"\"\" @staticmethod def create_instance ( config : Config ) -> DAGBuilderBase : \"\"\"Create DAG builder instance. Currently supported generation methods: - Fan-in/fan-out method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - G(n, p) method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - Chain-based method Parameters ---------- config : Config Config. Returns ------- DAGBuilderBase DAG builder. Raises ------ NotImplementedError Not implement. \"\"\" generation_method = config . generation_method if Util . ambiguous_equals ( generation_method , \"fan-in/fan-out\" ): return FanInFanOut ( config ) elif Util . ambiguous_equals ( generation_method , \"g(n, p)\" ): return GNP ( config ) elif Util . ambiguous_equals ( generation_method , \"chain-based\" ): return ChainBased ( config ) else : raise NotImplementedError create_instance ( config ) staticmethod # Create DAG builder instance. Currently supported generation methods: - Fan-in/fan-out method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - G(n, p) method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - Chain-based method Parameters: Name Type Description Default config Config Config. required Returns: Type Description DAGBuilderBase DAG builder. Raises: Type Description NotImplementedError Not implement. Source code in src\\dag_builder\\dag_builder_factory.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @staticmethod def create_instance ( config : Config ) -> DAGBuilderBase : \"\"\"Create DAG builder instance. Currently supported generation methods: - Fan-in/fan-out method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - G(n, p) method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - Chain-based method Parameters ---------- config : Config Config. Returns ------- DAGBuilderBase DAG builder. Raises ------ NotImplementedError Not implement. \"\"\" generation_method = config . generation_method if Util . ambiguous_equals ( generation_method , \"fan-in/fan-out\" ): return FanInFanOut ( config ) elif Util . ambiguous_equals ( generation_method , \"g(n, p)\" ): return GNP ( config ) elif Util . ambiguous_equals ( generation_method , \"chain-based\" ): return ChainBased ( config ) else : raise NotImplementedError FanInFanOut # Bases: DAGBuilderBase Fan-in/fan-out class. Source code in src\\dag_builder\\fan_in_fan_out.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class FanInFanOut ( DAGBuilderBase ): \"\"\"Fan-in/fan-out class.\"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) self . _max_out = ( max ( self . _config . out_degree ) if isinstance ( self . _config . out_degree , list ) else self . _config . out_degree ) self . _max_in = ( max ( self . _config . in_degree ) if isinstance ( self . _config . in_degree , list ) else self . _config . in_degree ) def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = config . number_of_entry_nodes number_of_exit_nodes = config . number_of_exit_nodes or 0 number_of_nodes = config . number_of_nodes if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" ) def build ( self ) -> Generator : \"\"\"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): num_build_fail = 0 # Determine number_of_nodes (Loop finish condition) num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize dag num_entry = Util . random_choice ( self . _config . number_of_entry_nodes ) G = self . _init_dag ( num_entry ) while G . number_of_nodes () != num_nodes : if Util . true_or_false (): # Fan-out max_diff_node_i , diff = self . _search_max_diff_node ( G ) num_add = random . randint ( 1 , diff ) add_node_i_list = [ G . number_of_nodes () + i for i in range ( num_add )] nx . add_star ( G , [ max_diff_node_i ] + add_node_i_list ) else : # Fan-in num_sources = random . randint ( 1 , self . _max_in ) nodes = list ( G . nodes ()) random . shuffle ( nodes ) sources = [] for node_i in nodes : if G . out_degree ( node_i ) < self . _max_out : sources . append ( node_i ) if len ( sources ) == num_sources : break add_node_i = G . number_of_nodes () G . add_node ( add_node_i ) for source_node_i in sources : G . add_edge ( source_node_i , add_node_i ) # Check build fail if G . number_of_nodes () > num_nodes : num_build_fail += 1 if num_build_fail == self . _max_try : msg = ( \"A DAG satisfying 'Number of nodes' could not be built \" f \"in { self . _max_try } tries.\" ) raise BuildFailedError ( msg ) else : G = self . _init_dag ( num_entry ) # reset # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : self . _ensure_weakly_connected ( G , True , bool ( num_exit )) yield G def _search_max_diff_node ( self , G : nx . DiGraph ) -> Tuple [ int , int ]: \"\"\"Search max difference node. Find the node with the biggest difference between its out-degree and max value of 'out-degree' parameter. Returns ------- Tuple[int, int] - Index of node with the biggest difference - Difference size \"\"\" min_out_i = Util . get_min_out_node ( G , G . nodes ) max_diff = self . _max_out - G . out_degree ( min_out_i ) return min_out_i , max_diff def _init_dag ( self , num_entry : int ) -> nx . DiGraph : G = nx . DiGraph () for _ in range ( num_entry ): G . add_node ( G . number_of_nodes ()) return G build () # Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields: Type Description Generator DAG generator. Raises: Type Description BuildFailedError The number of build failures exceeded the maximum number of attempts. Source code in src\\dag_builder\\fan_in_fan_out.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def build ( self ) -> Generator : \"\"\"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): num_build_fail = 0 # Determine number_of_nodes (Loop finish condition) num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize dag num_entry = Util . random_choice ( self . _config . number_of_entry_nodes ) G = self . _init_dag ( num_entry ) while G . number_of_nodes () != num_nodes : if Util . true_or_false (): # Fan-out max_diff_node_i , diff = self . _search_max_diff_node ( G ) num_add = random . randint ( 1 , diff ) add_node_i_list = [ G . number_of_nodes () + i for i in range ( num_add )] nx . add_star ( G , [ max_diff_node_i ] + add_node_i_list ) else : # Fan-in num_sources = random . randint ( 1 , self . _max_in ) nodes = list ( G . nodes ()) random . shuffle ( nodes ) sources = [] for node_i in nodes : if G . out_degree ( node_i ) < self . _max_out : sources . append ( node_i ) if len ( sources ) == num_sources : break add_node_i = G . number_of_nodes () G . add_node ( add_node_i ) for source_node_i in sources : G . add_edge ( source_node_i , add_node_i ) # Check build fail if G . number_of_nodes () > num_nodes : num_build_fail += 1 if num_build_fail == self . _max_try : msg = ( \"A DAG satisfying 'Number of nodes' could not be built \" f \"in { self . _max_try } tries.\" ) raise BuildFailedError ( msg ) else : G = self . _init_dag ( num_entry ) # reset # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : self . _ensure_weakly_connected ( G , True , bool ( num_exit )) yield G validate_config ( config ) # Validate config. Parameters: Name Type Description Default config Config Inputted config. required Raises: Type Description InfeasibleConfigError An infeasible parameter was entered. Source code in src\\dag_builder\\fan_in_fan_out.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = config . number_of_entry_nodes number_of_exit_nodes = config . number_of_exit_nodes or 0 number_of_nodes = config . number_of_nodes if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" ) GNP # Bases: DAGBuilderBase G(n, p) class. Source code in src\\dag_builder\\g_n_p.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class GNP ( DAGBuilderBase ): \"\"\"G(n, p) class.\"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = config . number_of_entry_nodes or 0 number_of_exit_nodes = config . number_of_exit_nodes or 0 number_of_nodes = config . number_of_nodes if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" ) if config . probability_of_edge > 1.0 : logger . warning ( \"'Probability of edge' > 1.0\" ) def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using G(n, p) method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Determine number_of_nodes num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_entry = self . _config . number_of_entry_nodes if num_entry : num_entry = Util . random_choice ( num_entry ) num_nodes -= num_entry num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize DAG G = nx . DiGraph () for i in range ( num_nodes ): G . add_node ( G . number_of_nodes ()) # Add edge prob_edge = Util . random_choice ( self . _config . probability_of_edge ) for i in range ( num_nodes ): for j in range ( num_nodes ): if random . randint ( 1 , 100 ) < prob_edge * 100 and i < j : G . add_edge ( i , j ) # Add entry nodes (Optional) if num_entry : self . _force_create_entry_nodes ( G , num_entry ) # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : try : self . _ensure_weakly_connected ( G , bool ( num_entry ), bool ( num_exit )) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield G build () # Build DAG using G(n, p) method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields: Type Description Generator DAG generator. Raises: Type Description BuildFailedError The number of build failures exceeded the maximum number of attempts. Source code in src\\dag_builder\\g_n_p.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using G(n, p) method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Determine number_of_nodes num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_entry = self . _config . number_of_entry_nodes if num_entry : num_entry = Util . random_choice ( num_entry ) num_nodes -= num_entry num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize DAG G = nx . DiGraph () for i in range ( num_nodes ): G . add_node ( G . number_of_nodes ()) # Add edge prob_edge = Util . random_choice ( self . _config . probability_of_edge ) for i in range ( num_nodes ): for j in range ( num_nodes ): if random . randint ( 1 , 100 ) < prob_edge * 100 and i < j : G . add_edge ( i , j ) # Add entry nodes (Optional) if num_entry : self . _force_create_entry_nodes ( G , num_entry ) # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : try : self . _ensure_weakly_connected ( G , bool ( num_entry ), bool ( num_exit )) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield G validate_config ( config ) # Validate config. Parameters: Name Type Description Default config Config Inputted config. required Raises: Type Description InfeasibleConfigError An infeasible parameter was entered. Source code in src\\dag_builder\\g_n_p.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = config . number_of_entry_nodes or 0 number_of_exit_nodes = config . number_of_exit_nodes or 0 number_of_nodes = config . number_of_nodes if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" ) if config . probability_of_edge > 1.0 : logger . warning ( \"'Probability of edge' > 1.0\" )","title":"dag_builder"},{"location":"dag_builder/#src.dag_builder.Chain","text":"Bases: nx . DiGraph Chain class. Source code in src\\dag_builder\\chain_based.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Chain ( nx . DiGraph ): \"\"\"Chain class.\"\"\" def __init__ ( self , start_idx : int ) -> None : \"\"\"Constructor. Parameters ---------- start_idx : int Index of chain head. \"\"\" super () . __init__ () self . start_idx : int = start_idx self . end_idx : int self . main_tail : int @property def head ( self ) -> int : return self . start_idx @property def sub_sequence_tails ( self ) -> List [ int ]: tails = Util . get_exit_nodes ( self ) tails . remove ( self . main_tail ) return tails def build_chain ( self , main_sequence_length : int , number_of_sub_sequence : Optional [ int ] = None , ) -> None : \"\"\"Build chain. Build the chain so that the main sequence is the longest. Parameters ---------- main_sequence_length : int Main sequence length number_of_sub_sequence : Optional[int], optional Number of sub sequence, by default None \"\"\" def create_sequence ( start_idx : int , len_sequence : int ) -> None : self . add_node ( start_idx ) for i in range ( start_idx , start_idx + len_sequence - 1 ): self . add_edge ( i , i + 1 ) # Build main sequence main_seq_i = [ i for i in range ( self . start_idx , self . start_idx + main_sequence_length )] self . main_tail = self . end_idx = main_seq_i [ - 1 ] create_sequence ( self . start_idx , main_sequence_length ) # Build sub sequence (Optional) if number_of_sub_sequence : for _ in range ( number_of_sub_sequence ): src_i = random . choice ( main_seq_i [: - 1 ]) sub_seq_len = main_sequence_length - main_seq_i . index ( src_i ) - 1 sub_seq_start_idx = self . end_idx + 1 create_sequence ( sub_seq_start_idx , sub_seq_len ) self . add_edge ( src_i , sub_seq_start_idx ) self . end_idx = sub_seq_start_idx + sub_seq_len - 1","title":"Chain"},{"location":"dag_builder/#src.dag_builder.chain_based.Chain.__init__","text":"Constructor. Parameters: Name Type Description Default start_idx int Index of chain head. required Source code in src\\dag_builder\\chain_based.py 15 16 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , start_idx : int ) -> None : \"\"\"Constructor. Parameters ---------- start_idx : int Index of chain head. \"\"\" super () . __init__ () self . start_idx : int = start_idx self . end_idx : int self . main_tail : int","title":"__init__()"},{"location":"dag_builder/#src.dag_builder.chain_based.Chain.build_chain","text":"Build chain. Build the chain so that the main sequence is the longest. Parameters: Name Type Description Default main_sequence_length int Main sequence length required number_of_sub_sequence Optional [ int ], optional Number of sub sequence, by default None None Source code in src\\dag_builder\\chain_based.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def build_chain ( self , main_sequence_length : int , number_of_sub_sequence : Optional [ int ] = None , ) -> None : \"\"\"Build chain. Build the chain so that the main sequence is the longest. Parameters ---------- main_sequence_length : int Main sequence length number_of_sub_sequence : Optional[int], optional Number of sub sequence, by default None \"\"\" def create_sequence ( start_idx : int , len_sequence : int ) -> None : self . add_node ( start_idx ) for i in range ( start_idx , start_idx + len_sequence - 1 ): self . add_edge ( i , i + 1 ) # Build main sequence main_seq_i = [ i for i in range ( self . start_idx , self . start_idx + main_sequence_length )] self . main_tail = self . end_idx = main_seq_i [ - 1 ] create_sequence ( self . start_idx , main_sequence_length ) # Build sub sequence (Optional) if number_of_sub_sequence : for _ in range ( number_of_sub_sequence ): src_i = random . choice ( main_seq_i [: - 1 ]) sub_seq_len = main_sequence_length - main_seq_i . index ( src_i ) - 1 sub_seq_start_idx = self . end_idx + 1 create_sequence ( sub_seq_start_idx , sub_seq_len ) self . add_edge ( src_i , sub_seq_start_idx ) self . end_idx = sub_seq_start_idx + sub_seq_len - 1","title":"build_chain()"},{"location":"dag_builder/#src.dag_builder.ChainBased","text":"Bases: DAGBuilderBase Chain-based class. Source code in src\\dag_builder\\chain_based.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 class ChainBased ( DAGBuilderBase ): \"\"\"Chain-based class.\"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" main_sequence_length = config . main_sequence_length number_of_sub_sequences = config . number_of_sub_sequences if main_sequence_length == 1 and number_of_sub_sequences : raise InfeasibleConfigError ( \"Since the length of 'Main sequence length' is 1, \" \"the sub-sequence cannot be built.\" ) if config . vertically_link_chains : main_sequence_tail = config . main_sequence_tail sub_sequence_tail = config . sub_sequence_tail if main_sequence_tail is False and sub_sequence_tail is False : raise InfeasibleConfigError ( \"Either 'Main sequence tail' or 'Sub sequence tail' must be set to True.\" ) number_of_chains = config . number_of_chains number_of_entry_nodes = config . number_of_entry_nodes if number_of_chains < number_of_entry_nodes : raise InfeasibleConfigError ( \"'Number of chains' < 'Number of entry nodes.'\" ) if config . merge_chains : middle_of_chain = config . middle_of_chain exit_node = config . exit_node if middle_of_chain is False and exit_node is False : raise InfeasibleConfigError ( \"Either 'Middle of chain' or 'Exit node' must be set to True.\" ) number_of_chains = config . number_of_chains number_of_exit_nodes = config . number_of_exit_nodes if number_of_chains * number_of_sub_sequences < number_of_exit_nodes : raise InfeasibleConfigError ( \"'Number of chains' * 'Number of sub sequence' < 'Number of exit nodes.'\" ) def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using chain-based method. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Build each chain chains : List [ Chain ] = [] start_idx = 0 for _ in range ( self . _config . number_of_chains ): chain = Chain ( start_idx ) main_sequence_length = Util . random_choice ( self . _config . main_sequence_length ) number_of_sub_sequence = ( Util . random_choice ( self . _config . number_of_sub_sequences ) if self . _config . number_of_sub_sequences else None ) chain . build_chain ( main_sequence_length , number_of_sub_sequence ) chains . append ( chain ) start_idx = chain . end_idx + 1 # Create chain-based DAG chain_based_dag = ChainBasedDAG ( chains ) # Vertically link chains (optional) if self . _config . vertically_link_chains : chain_based_dag . vertically_link_chains ( Util . random_choice ( self . _config . number_of_entry_nodes ), self . _config . main_sequence_tail , self . _config . sub_sequence_tail , ) # Merge chains (optional) if self . _config . merge_chains : try : chain_based_dag . merge_chains ( Util . random_choice ( self . _config . number_of_exit_nodes ), self . _config . middle_of_chain , self . _config . exit_node , ) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield chain_based_dag","title":"ChainBased"},{"location":"dag_builder/#src.dag_builder.chain_based.ChainBased.build","text":"Build DAG using chain-based method. Yields: Type Description Generator DAG generator. Raises: Type Description BuildFailedError The number of build failures exceeded the maximum number of attempts. Source code in src\\dag_builder\\chain_based.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using chain-based method. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Build each chain chains : List [ Chain ] = [] start_idx = 0 for _ in range ( self . _config . number_of_chains ): chain = Chain ( start_idx ) main_sequence_length = Util . random_choice ( self . _config . main_sequence_length ) number_of_sub_sequence = ( Util . random_choice ( self . _config . number_of_sub_sequences ) if self . _config . number_of_sub_sequences else None ) chain . build_chain ( main_sequence_length , number_of_sub_sequence ) chains . append ( chain ) start_idx = chain . end_idx + 1 # Create chain-based DAG chain_based_dag = ChainBasedDAG ( chains ) # Vertically link chains (optional) if self . _config . vertically_link_chains : chain_based_dag . vertically_link_chains ( Util . random_choice ( self . _config . number_of_entry_nodes ), self . _config . main_sequence_tail , self . _config . sub_sequence_tail , ) # Merge chains (optional) if self . _config . merge_chains : try : chain_based_dag . merge_chains ( Util . random_choice ( self . _config . number_of_exit_nodes ), self . _config . middle_of_chain , self . _config . exit_node , ) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield chain_based_dag","title":"build()"},{"location":"dag_builder/#src.dag_builder.chain_based.ChainBased.validate_config","text":"Validate config. Parameters: Name Type Description Default config Config Inputted config. required Raises: Type Description InfeasibleConfigError An infeasible parameter was entered. Source code in src\\dag_builder\\chain_based.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" main_sequence_length = config . main_sequence_length number_of_sub_sequences = config . number_of_sub_sequences if main_sequence_length == 1 and number_of_sub_sequences : raise InfeasibleConfigError ( \"Since the length of 'Main sequence length' is 1, \" \"the sub-sequence cannot be built.\" ) if config . vertically_link_chains : main_sequence_tail = config . main_sequence_tail sub_sequence_tail = config . sub_sequence_tail if main_sequence_tail is False and sub_sequence_tail is False : raise InfeasibleConfigError ( \"Either 'Main sequence tail' or 'Sub sequence tail' must be set to True.\" ) number_of_chains = config . number_of_chains number_of_entry_nodes = config . number_of_entry_nodes if number_of_chains < number_of_entry_nodes : raise InfeasibleConfigError ( \"'Number of chains' < 'Number of entry nodes.'\" ) if config . merge_chains : middle_of_chain = config . middle_of_chain exit_node = config . exit_node if middle_of_chain is False and exit_node is False : raise InfeasibleConfigError ( \"Either 'Middle of chain' or 'Exit node' must be set to True.\" ) number_of_chains = config . number_of_chains number_of_exit_nodes = config . number_of_exit_nodes if number_of_chains * number_of_sub_sequences < number_of_exit_nodes : raise InfeasibleConfigError ( \"'Number of chains' * 'Number of sub sequence' < 'Number of exit nodes.'\" )","title":"validate_config()"},{"location":"dag_builder/#src.dag_builder.ChainBasedDAG","text":"Bases: nx . DiGraph Chain-based DAG class. Source code in src\\dag_builder\\chain_based.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 class ChainBasedDAG ( nx . DiGraph ): \"\"\"Chain-based DAG class.\"\"\" def __init__ ( self , chains : List [ Chain ]) -> None : super () . __init__ () self . _chains = chains for chain in self . _chains : self . add_nodes_from ( chain . nodes ) self . add_edges_from ( chain . edges ) def vertically_link_chains ( self , number_of_entry_nodes : int , link_main_tail : bool , link_sub_tail : bool ) -> None : \"\"\"Vertically link chains. Parameters ---------- number_of_entry_nodes : int Number of entry nodes. link_main_tail : bool Allow link in main sequence tails. link_sub_tail : bool Allow link in sub sequence tails. \"\"\" # Determine source option src_chains = set ( random . sample ( self . _chains , number_of_entry_nodes )) src_option = [] for chain in src_chains : if link_main_tail : src_option . append ( chain . main_tail ) if link_sub_tail : src_option += chain . sub_sequence_tails # Determine targets tgt_chains = set ( self . _chains ) - src_chains targets = [ chain . head for chain in tgt_chains ] # Add edges for tgt_i in targets : src_i = Util . get_min_out_node ( self , src_option ) self . add_edge ( src_i , tgt_i ) def merge_chains ( self , number_of_exit_nodes : int , merge_middle : bool , merge_exit : bool ) -> None : \"\"\"Merge chains. Parameters ---------- number_of_exit_nodes : int Number of exit nodes. merge_middle : bool Allow merge to middle nodes. merge_exit : bool Allow merge to exit nodes. Raises ------ BuildFailedError No merging is possible. \"\"\" selected_exits = set ( random . sample ( Util . get_exit_nodes ( self ), number_of_exit_nodes )) sources = set ( Util . get_exit_nodes ( self )) - set ( selected_exits ) # Determine target option tgt_option = set ( self . nodes ()) - set ( Util . get_entry_nodes ( self )) - sources if not merge_exit : tgt_option -= selected_exits if not merge_middle : tgt_option = selected_exits # Add edges for src_i in sources : _tgt_option = tgt_option - nx . ancestors ( self , src_i ) if not _tgt_option : raise BuildFailedError ( \"No merging is possible.\" ) tgt_i = Util . get_min_in_node ( self , _tgt_option ) self . add_edge ( src_i , tgt_i )","title":"ChainBasedDAG"},{"location":"dag_builder/#src.dag_builder.chain_based.ChainBasedDAG.merge_chains","text":"Merge chains. Parameters: Name Type Description Default number_of_exit_nodes int Number of exit nodes. required merge_middle bool Allow merge to middle nodes. required merge_exit bool Allow merge to exit nodes. required Raises: Type Description BuildFailedError No merging is possible. Source code in src\\dag_builder\\chain_based.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def merge_chains ( self , number_of_exit_nodes : int , merge_middle : bool , merge_exit : bool ) -> None : \"\"\"Merge chains. Parameters ---------- number_of_exit_nodes : int Number of exit nodes. merge_middle : bool Allow merge to middle nodes. merge_exit : bool Allow merge to exit nodes. Raises ------ BuildFailedError No merging is possible. \"\"\" selected_exits = set ( random . sample ( Util . get_exit_nodes ( self ), number_of_exit_nodes )) sources = set ( Util . get_exit_nodes ( self )) - set ( selected_exits ) # Determine target option tgt_option = set ( self . nodes ()) - set ( Util . get_entry_nodes ( self )) - sources if not merge_exit : tgt_option -= selected_exits if not merge_middle : tgt_option = selected_exits # Add edges for src_i in sources : _tgt_option = tgt_option - nx . ancestors ( self , src_i ) if not _tgt_option : raise BuildFailedError ( \"No merging is possible.\" ) tgt_i = Util . get_min_in_node ( self , _tgt_option ) self . add_edge ( src_i , tgt_i )","title":"merge_chains()"},{"location":"dag_builder/#src.dag_builder.chain_based.ChainBasedDAG.vertically_link_chains","text":"Vertically link chains. Parameters: Name Type Description Default number_of_entry_nodes int Number of entry nodes. required link_main_tail bool Allow link in main sequence tails. required link_sub_tail bool Allow link in sub sequence tails. required Source code in src\\dag_builder\\chain_based.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def vertically_link_chains ( self , number_of_entry_nodes : int , link_main_tail : bool , link_sub_tail : bool ) -> None : \"\"\"Vertically link chains. Parameters ---------- number_of_entry_nodes : int Number of entry nodes. link_main_tail : bool Allow link in main sequence tails. link_sub_tail : bool Allow link in sub sequence tails. \"\"\" # Determine source option src_chains = set ( random . sample ( self . _chains , number_of_entry_nodes )) src_option = [] for chain in src_chains : if link_main_tail : src_option . append ( chain . main_tail ) if link_sub_tail : src_option += chain . sub_sequence_tails # Determine targets tgt_chains = set ( self . _chains ) - src_chains targets = [ chain . head for chain in tgt_chains ] # Add edges for tgt_i in targets : src_i = Util . get_min_out_node ( self , src_option ) self . add_edge ( src_i , tgt_i )","title":"vertically_link_chains()"},{"location":"dag_builder/#src.dag_builder.DAGBuilderBase","text":"DAG builder base class. Source code in src\\dag_builder\\dag_builder_base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class DAGBuilderBase ( metaclass = ABCMeta ): \"\"\"DAG builder base class.\"\"\" def __init__ ( self , config : Config , max_try : int = 100 ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. max_try : int, optional Maximum number of build attempts for a single DAG, by default 100 \"\"\" self . validate_config ( config ) self . _config = config self . _max_try = max_try @abstractmethod def build ( self ) -> Generator [ nx . DiGraph , None , None ]: raise NotImplementedError @abstractmethod def validate_config ( self , config : Config ): raise NotImplementedError @staticmethod def _force_create_entry_nodes ( G : nx . DiGraph , number_of_entry_nodes : int ) -> None : \"\"\"Create an entry node forcibly. Add 'number_of_entry_nodes' number of new nodes to the DAG and make them entry nodes. All original entry nodes are connected to the newly added node. Parameters ---------- G : nx.DiGraph DAG. number_of_entry_nodes : int Number of entry nodes. \"\"\" original_entries = Util . get_entry_nodes ( G ) new_entries = [ G . number_of_nodes () + i for i in range ( number_of_entry_nodes )] G . add_nodes_from ( new_entries ) DAGBuilderBase . _add_minimum_edges ( new_entries , original_entries , G ) @staticmethod def _force_create_exit_nodes ( G : nx . DiGraph , number_of_exit_nodes : int ) -> None : \"\"\"Create an exit node forcibly. Add 'number_of_exit_nodes' number of new nodes to the DAG and make them exit nodes. All original exit nodes are connected to the newly added node. Parameters ---------- G : nx.DiGraph DAG. number_of_exit_nodes : int Number of exit nodes. \"\"\" original_exits = Util . get_exit_nodes ( G ) new_exits = [ G . number_of_nodes () + i for i in range ( number_of_exit_nodes )] G . add_nodes_from ( new_exits ) DAGBuilderBase . _add_minimum_edges ( original_exits , new_exits , G ) @staticmethod def _add_minimum_edges ( src_layer : List [ int ], tgt_layer : List [ int ], G : nx . DiGraph ) -> None : \"\"\"Add minimum edges Connects the source and target layers with a minimum number of edges. The function terminates when the out-degree of the source layer is greater than or equal to 1 and the in-degree of the target layer is greater than or equal to 1. Parameters ---------- src_layer : List[int] Indices of nodes that are the source of the edge. tgt_layer : List[int] Indices of nodes that are the target of the edge. G : nx.DiGraph DAG. \"\"\" def is_finish () -> bool : for src_node_i in src_layer : if G . out_degree ( src_node_i ) == 0 : return False for tgt_node_i in tgt_layer : if G . in_degree ( tgt_node_i ) == 0 : return False return True while not is_finish (): min_out_src_i = Util . get_min_out_node ( G , src_layer ) min_in_tgt_i = Util . get_min_in_node ( G , tgt_layer ) G . add_edge ( min_out_src_i , min_in_tgt_i ) @staticmethod def _ensure_weakly_connected ( G : nx . DiGraph , keep_num_entry : bool , keep_num_exit : bool ) -> None : \"\"\"Ensure weakly connected. Parameters ---------- G : nx.DiGraph DAG. keep_num_entry : bool Keep the number of entry nodes. keep_num_exit : bool Keep the number of exit nodes. Raises ------ BuildFailedError The number of entry nodes and the number of exit nodes cannot be kept because of the size 1 component. \"\"\" comps = list ( nx . weakly_connected_components ( G )) if len ( comps ) == 1 : return None comps . sort ( key = lambda x : len ( x )) tgt_comp = comps . pop ( - 1 ) # Most big component entry_nodes = set ( Util . get_entry_nodes ( G )) exit_nodes = set ( Util . get_exit_nodes ( G )) if keep_num_entry and keep_num_exit and ( entry_nodes & exit_nodes ): raise BuildFailedError ( \"The number of entry nodes and the number of exit nodes\" \"cannot be maintained because of the size 1 component.\" ) for src_comp in comps : src_option = src_comp - exit_nodes if keep_num_exit else src_comp tgt_option = tgt_comp - entry_nodes if keep_num_entry else tgt_comp src_i = Util . get_min_out_node ( G , src_option ) tgt_i = Util . get_min_in_node ( G , tgt_option ) G . add_edge ( src_i , tgt_i )","title":"DAGBuilderBase"},{"location":"dag_builder/#src.dag_builder.dag_builder_base.DAGBuilderBase.__init__","text":"Constructor. Parameters: Name Type Description Default config Config Config. required max_try int , optional Maximum number of build attempts for a single DAG, by default 100 100 Source code in src\\dag_builder\\dag_builder_base.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , config : Config , max_try : int = 100 ) -> None : \"\"\"Constructor. Parameters ---------- config : Config Config. max_try : int, optional Maximum number of build attempts for a single DAG, by default 100 \"\"\" self . validate_config ( config ) self . _config = config self . _max_try = max_try","title":"__init__()"},{"location":"dag_builder/#src.dag_builder.DAGBuilderFactory","text":"DAG builder factory class. Source code in src\\dag_builder\\dag_builder_factory.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class DAGBuilderFactory : \"\"\"DAG builder factory class.\"\"\" @staticmethod def create_instance ( config : Config ) -> DAGBuilderBase : \"\"\"Create DAG builder instance. Currently supported generation methods: - Fan-in/fan-out method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - G(n, p) method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - Chain-based method Parameters ---------- config : Config Config. Returns ------- DAGBuilderBase DAG builder. Raises ------ NotImplementedError Not implement. \"\"\" generation_method = config . generation_method if Util . ambiguous_equals ( generation_method , \"fan-in/fan-out\" ): return FanInFanOut ( config ) elif Util . ambiguous_equals ( generation_method , \"g(n, p)\" ): return GNP ( config ) elif Util . ambiguous_equals ( generation_method , \"chain-based\" ): return ChainBased ( config ) else : raise NotImplementedError","title":"DAGBuilderFactory"},{"location":"dag_builder/#src.dag_builder.dag_builder_factory.DAGBuilderFactory.create_instance","text":"Create DAG builder instance. Currently supported generation methods: - Fan-in/fan-out method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - G(n, p) method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - Chain-based method Parameters: Name Type Description Default config Config Config. required Returns: Type Description DAGBuilderBase DAG builder. Raises: Type Description NotImplementedError Not implement. Source code in src\\dag_builder\\dag_builder_factory.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 @staticmethod def create_instance ( config : Config ) -> DAGBuilderBase : \"\"\"Create DAG builder instance. Currently supported generation methods: - Fan-in/fan-out method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - G(n, p) method (see https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf) - Chain-based method Parameters ---------- config : Config Config. Returns ------- DAGBuilderBase DAG builder. Raises ------ NotImplementedError Not implement. \"\"\" generation_method = config . generation_method if Util . ambiguous_equals ( generation_method , \"fan-in/fan-out\" ): return FanInFanOut ( config ) elif Util . ambiguous_equals ( generation_method , \"g(n, p)\" ): return GNP ( config ) elif Util . ambiguous_equals ( generation_method , \"chain-based\" ): return ChainBased ( config ) else : raise NotImplementedError","title":"create_instance()"},{"location":"dag_builder/#src.dag_builder.FanInFanOut","text":"Bases: DAGBuilderBase Fan-in/fan-out class. Source code in src\\dag_builder\\fan_in_fan_out.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class FanInFanOut ( DAGBuilderBase ): \"\"\"Fan-in/fan-out class.\"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) self . _max_out = ( max ( self . _config . out_degree ) if isinstance ( self . _config . out_degree , list ) else self . _config . out_degree ) self . _max_in = ( max ( self . _config . in_degree ) if isinstance ( self . _config . in_degree , list ) else self . _config . in_degree ) def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = config . number_of_entry_nodes number_of_exit_nodes = config . number_of_exit_nodes or 0 number_of_nodes = config . number_of_nodes if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" ) def build ( self ) -> Generator : \"\"\"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): num_build_fail = 0 # Determine number_of_nodes (Loop finish condition) num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize dag num_entry = Util . random_choice ( self . _config . number_of_entry_nodes ) G = self . _init_dag ( num_entry ) while G . number_of_nodes () != num_nodes : if Util . true_or_false (): # Fan-out max_diff_node_i , diff = self . _search_max_diff_node ( G ) num_add = random . randint ( 1 , diff ) add_node_i_list = [ G . number_of_nodes () + i for i in range ( num_add )] nx . add_star ( G , [ max_diff_node_i ] + add_node_i_list ) else : # Fan-in num_sources = random . randint ( 1 , self . _max_in ) nodes = list ( G . nodes ()) random . shuffle ( nodes ) sources = [] for node_i in nodes : if G . out_degree ( node_i ) < self . _max_out : sources . append ( node_i ) if len ( sources ) == num_sources : break add_node_i = G . number_of_nodes () G . add_node ( add_node_i ) for source_node_i in sources : G . add_edge ( source_node_i , add_node_i ) # Check build fail if G . number_of_nodes () > num_nodes : num_build_fail += 1 if num_build_fail == self . _max_try : msg = ( \"A DAG satisfying 'Number of nodes' could not be built \" f \"in { self . _max_try } tries.\" ) raise BuildFailedError ( msg ) else : G = self . _init_dag ( num_entry ) # reset # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : self . _ensure_weakly_connected ( G , True , bool ( num_exit )) yield G def _search_max_diff_node ( self , G : nx . DiGraph ) -> Tuple [ int , int ]: \"\"\"Search max difference node. Find the node with the biggest difference between its out-degree and max value of 'out-degree' parameter. Returns ------- Tuple[int, int] - Index of node with the biggest difference - Difference size \"\"\" min_out_i = Util . get_min_out_node ( G , G . nodes ) max_diff = self . _max_out - G . out_degree ( min_out_i ) return min_out_i , max_diff def _init_dag ( self , num_entry : int ) -> nx . DiGraph : G = nx . DiGraph () for _ in range ( num_entry ): G . add_node ( G . number_of_nodes ()) return G","title":"FanInFanOut"},{"location":"dag_builder/#src.dag_builder.fan_in_fan_out.FanInFanOut.build","text":"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields: Type Description Generator DAG generator. Raises: Type Description BuildFailedError The number of build failures exceeded the maximum number of attempts. Source code in src\\dag_builder\\fan_in_fan_out.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def build ( self ) -> Generator : \"\"\"Build DAG using fan-in/fan-out method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): num_build_fail = 0 # Determine number_of_nodes (Loop finish condition) num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize dag num_entry = Util . random_choice ( self . _config . number_of_entry_nodes ) G = self . _init_dag ( num_entry ) while G . number_of_nodes () != num_nodes : if Util . true_or_false (): # Fan-out max_diff_node_i , diff = self . _search_max_diff_node ( G ) num_add = random . randint ( 1 , diff ) add_node_i_list = [ G . number_of_nodes () + i for i in range ( num_add )] nx . add_star ( G , [ max_diff_node_i ] + add_node_i_list ) else : # Fan-in num_sources = random . randint ( 1 , self . _max_in ) nodes = list ( G . nodes ()) random . shuffle ( nodes ) sources = [] for node_i in nodes : if G . out_degree ( node_i ) < self . _max_out : sources . append ( node_i ) if len ( sources ) == num_sources : break add_node_i = G . number_of_nodes () G . add_node ( add_node_i ) for source_node_i in sources : G . add_edge ( source_node_i , add_node_i ) # Check build fail if G . number_of_nodes () > num_nodes : num_build_fail += 1 if num_build_fail == self . _max_try : msg = ( \"A DAG satisfying 'Number of nodes' could not be built \" f \"in { self . _max_try } tries.\" ) raise BuildFailedError ( msg ) else : G = self . _init_dag ( num_entry ) # reset # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : self . _ensure_weakly_connected ( G , True , bool ( num_exit )) yield G","title":"build()"},{"location":"dag_builder/#src.dag_builder.fan_in_fan_out.FanInFanOut.validate_config","text":"Validate config. Parameters: Name Type Description Default config Config Inputted config. required Raises: Type Description InfeasibleConfigError An infeasible parameter was entered. Source code in src\\dag_builder\\fan_in_fan_out.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = config . number_of_entry_nodes number_of_exit_nodes = config . number_of_exit_nodes or 0 number_of_nodes = config . number_of_nodes if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" )","title":"validate_config()"},{"location":"dag_builder/#src.dag_builder.GNP","text":"Bases: DAGBuilderBase G(n, p) class. Source code in src\\dag_builder\\g_n_p.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class GNP ( DAGBuilderBase ): \"\"\"G(n, p) class.\"\"\" def __init__ ( self , config : Config ) -> None : super () . __init__ ( config ) def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = config . number_of_entry_nodes or 0 number_of_exit_nodes = config . number_of_exit_nodes or 0 number_of_nodes = config . number_of_nodes if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" ) if config . probability_of_edge > 1.0 : logger . warning ( \"'Probability of edge' > 1.0\" ) def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using G(n, p) method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Determine number_of_nodes num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_entry = self . _config . number_of_entry_nodes if num_entry : num_entry = Util . random_choice ( num_entry ) num_nodes -= num_entry num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize DAG G = nx . DiGraph () for i in range ( num_nodes ): G . add_node ( G . number_of_nodes ()) # Add edge prob_edge = Util . random_choice ( self . _config . probability_of_edge ) for i in range ( num_nodes ): for j in range ( num_nodes ): if random . randint ( 1 , 100 ) < prob_edge * 100 and i < j : G . add_edge ( i , j ) # Add entry nodes (Optional) if num_entry : self . _force_create_entry_nodes ( G , num_entry ) # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : try : self . _ensure_weakly_connected ( G , bool ( num_entry ), bool ( num_exit )) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield G","title":"GNP"},{"location":"dag_builder/#src.dag_builder.g_n_p.GNP.build","text":"Build DAG using G(n, p) method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields: Type Description Generator DAG generator. Raises: Type Description BuildFailedError The number of build failures exceeded the maximum number of attempts. Source code in src\\dag_builder\\g_n_p.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def build ( self ) -> Generator [ nx . DiGraph , None , None ]: \"\"\"Build DAG using G(n, p) method. See https://hal.archives-ouvertes.fr/hal-00471255/file/ggen.pdf. Yields ------ Generator DAG generator. Raises ------ BuildFailedError The number of build failures exceeded the maximum number of attempts. \"\"\" for _ in range ( self . _config . number_of_dags ): for try_i in range ( 1 , self . _max_try + 1 ): # Determine number_of_nodes num_nodes = Util . random_choice ( self . _config . number_of_nodes ) num_entry = self . _config . number_of_entry_nodes if num_entry : num_entry = Util . random_choice ( num_entry ) num_nodes -= num_entry num_exit = self . _config . number_of_exit_nodes if num_exit : num_exit = Util . random_choice ( num_exit ) num_nodes -= num_exit # Initialize DAG G = nx . DiGraph () for i in range ( num_nodes ): G . add_node ( G . number_of_nodes ()) # Add edge prob_edge = Util . random_choice ( self . _config . probability_of_edge ) for i in range ( num_nodes ): for j in range ( num_nodes ): if random . randint ( 1 , 100 ) < prob_edge * 100 and i < j : G . add_edge ( i , j ) # Add entry nodes (Optional) if num_entry : self . _force_create_entry_nodes ( G , num_entry ) # Add exit nodes (Optional) if num_exit : self . _force_create_exit_nodes ( G , num_exit ) # Ensure weakly connected (Optional) if self . _config . ensure_weakly_connected : try : self . _ensure_weakly_connected ( G , bool ( num_entry ), bool ( num_exit )) break except BuildFailedError : if try_i == self . _max_try : raise BuildFailedError ( f \"A DAG could not be built in { self . _max_try } tries.\" ) continue yield G","title":"build()"},{"location":"dag_builder/#src.dag_builder.g_n_p.GNP.validate_config","text":"Validate config. Parameters: Name Type Description Default config Config Inputted config. required Raises: Type Description InfeasibleConfigError An infeasible parameter was entered. Source code in src\\dag_builder\\g_n_p.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def validate_config ( self , config : Config ): \"\"\"Validate config. Parameters ---------- config : Config Inputted config. Raises ------ InfeasibleConfigError An infeasible parameter was entered. \"\"\" number_of_entry_nodes = config . number_of_entry_nodes or 0 number_of_exit_nodes = config . number_of_exit_nodes or 0 number_of_nodes = config . number_of_nodes if number_of_entry_nodes + number_of_exit_nodes > number_of_nodes : raise InfeasibleConfigError ( \"'Number of entry nodes' + 'Number of exit nodes' > 'Number of nodes'\" ) if config . probability_of_edge > 1.0 : logger . warning ( \"'Probability of edge' > 1.0\" )","title":"validate_config()"},{"location":"exceptions/","text":"BuildFailedError # Bases: Error Failed to build. Source code in src\\exceptions.py 12 13 14 15 16 class BuildFailedError ( Error ): \"\"\"Failed to build.\"\"\" def __init__ ( self , message : str ) -> None : self . message = message Error # Bases: Exception Base class for exception. Source code in src\\exceptions.py 1 2 class Error ( Exception ): \"\"\"Base class for exception.\"\"\" InfeasibleConfigError # Bases: Error Infeasible parameters entered. Source code in src\\exceptions.py 5 6 7 8 9 class InfeasibleConfigError ( Error ): \"\"\"Infeasible parameters entered.\"\"\" def __init__ ( self , message : str ) -> None : self . message = message","title":"exceptions"},{"location":"exceptions/#src.exceptions.BuildFailedError","text":"Bases: Error Failed to build. Source code in src\\exceptions.py 12 13 14 15 16 class BuildFailedError ( Error ): \"\"\"Failed to build.\"\"\" def __init__ ( self , message : str ) -> None : self . message = message","title":"BuildFailedError"},{"location":"exceptions/#src.exceptions.Error","text":"Bases: Exception Base class for exception. Source code in src\\exceptions.py 1 2 class Error ( Exception ): \"\"\"Base class for exception.\"\"\"","title":"Error"},{"location":"exceptions/#src.exceptions.InfeasibleConfigError","text":"Bases: Error Infeasible parameters entered. Source code in src\\exceptions.py 5 6 7 8 9 class InfeasibleConfigError ( Error ): \"\"\"Infeasible parameters entered.\"\"\" def __init__ ( self , message : str ) -> None : self . message = message","title":"InfeasibleConfigError"}]}